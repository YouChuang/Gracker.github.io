<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Android Perofrmance]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://androidperformance.com/"/>
  <updated>2015-04-01T10:15:07.000Z</updated>
  <id>http://androidperformance.com/</id>
  
  <author>
    <name><![CDATA[Gracker]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android性能优化后续]]></title>
    <link href="http://androidperformance.com/2015/03/31/android-performance-case-study-follow-up/"/>
    <id>http://androidperformance.com/2015/03/31/android-performance-case-study-follow-up/</id>
    <published>2015-03-31T01:29:00.000Z</published>
    <updated>2015-04-01T10:15:07.000Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>本文是一篇译文，原文<a href="http://www.curious-creature.com/2015/03/25/android-performance-case-study-follow-up/?utm_source=Android+Weekly&amp;utm_campaign=0692ef161b-Android_Weekly_146&amp;utm_medium=email&amp;utm_term=0_4eb677ad19-0692ef161b-337850757" target="_blank" rel="external">Android Performance Case Study Follow-up</a>的作者是大名鼎鼎的<a href="http://www.curious-creature.com/" target="_blank" rel="external">Romain Guy</a>。本文讲述了Android性能优化的一些技巧、方法和工具。</p>
<h1 id="译文正文">译文正文</h1><p>两年前，我发表了一篇名为<a href="http://www.curious-creature.com/2012/12/01/android-performance-case-study/" target="_blank" rel="external">Android Performance Case Study</a> 的文章，来帮助Android开发者了解需要使用什么工具和技术手段来确定、追踪和优化性能问题。</p>
<p>那篇文章以一个Twitter客户端 <a href="https://play.google.com/store/apps/details?id=com.jv.materialfalcon" target="_blank" rel="external">Falcon Pro</a>为典范，其开发人员为 Joaquim Vergès. Joaquim人不错，他允许我在我的文章中使用它的程序作为例子，并且快速处理了我发现的所有问题。一切都OK，直到Joaquim 从头开始开发Falcon Pro 3，前不久在他准备发布它的新应用的时候，他联系了我，因为他有一个和滚动相关的性能问题需要我来帮助他，这一次我依然没有源代码可以参考。</p>
<a id="more"></a>
<p>Joaquim使用了所有的工具来找出问题所在，他发现Overdraw不是问题的原因，他觉得是 <a href="http://developer.android.com/reference/android/support/v4/view/ViewPager.html" target="_blank" rel="external">ViewPager</a> 的用法导致了这个问题。他给我发来了下面的截图：</p>
<p><img src="/images/android-performance-case-study-follow-up/falconpro3.png" alt="Falcon Pro"></p>
<p>Joaquim使用了系统内置的GPU profiling工具来发现掉帧现象， 左边的截图是在没有ViewPager 的情况下滑动时间线，右边的截图是有ViewPager的情况下滑动（他使用的是2014年的Moto x来截的图），问题看起来很明显。</p>
<p>我最先想到的是查看ViewPager是不是由于滥用硬件加速导致，这个性能问题看起来像是在滑动的过程中每一帧都使用了硬件加速。系统的 <a href="http://www.curious-creature.com/2013/09/13/optimizing-hardware-layers/" target="_blank" rel="external">hardware layers updates debugging tool</a>没有显示什么有用的信息。我反复使用HierarchyViewer 查看布局情况，令我满意的是ViewPager的表现很正确（相反，不太可能会出问题）</p>
<p>之后我打开了另一个强大的工具却很少用到的工具：Tracer for OpenGL 。我之前的那篇<a href="http://www.curious-creature.com/2012/12/01/android-performance-case-study" target="_blank" rel="external">文章</a>解释了如何使用工具获得更多细节。你首先需要知道的是这个工具收集了所有UI界面发给GPU的绘制命令。</p>
<blockquote>
<p><strong>Android 4.3 and up</strong>: <em>Tracer</em> has unfortunately become a little more difficult to use since Android 4.3 when we introduced<a href="https://developers.google.com/events/io/sessions/325418001" target="_blank" rel="external">reordering and merging of drawing commands</a>. It’s an amazingly useful optimization but it prevents <em>Tracer</em> from grouping drawing commands by view. You can restore the old behavior by disabling display lists optimization using the following command (before you start your application)(意思是说Android4.3之后，这个工具不太好用了，因为有reordering and merging 机制的引进)</p>
<p><strong>Reading OpenGL traces</strong>: Commands shown in blue are GL operations that draw pixels on screen. All other commands are used to transfer data or set state and can easily be ignored. Every time you click on one of the blue commands, Tracer will update the Details tab and show you the content of the current render target right after the command you clicked is executed. You can thus reconstruct a frame by clicking on each blue command one after another. It’s pretty much how I analyze performance issues with Tracer. Seeing how a frame is rendered gives a lot of insight on what the application is doing.(意思是说只蓝色的行是真正进行绘制的命令，点击可以看到绘制的这一帧的图像，其他的命令都是一些数据的转换)</p>
</blockquote>
<p>滑动一段时间Falcon Pro应用后，我仔细查看Gl Trace收集到的数据，我很惊奇地发现很多SaveLayer/ComposeLayer阻塞命令。</p>
<p><img src="/images/android-performance-case-study-follow-up/glTrace.png" alt="Paste_Image.png"></p>
<p>这些命令表明应用在生成一个临时的Hardware Layer。这些临时的Layer被不同的 <a href="http://developer.android.com/reference/android/graphics/Canvas.html#saveLayer(float, float, float, float, android.graphics.Paint, int" target="_blank" rel="external">Canvas.saveLayer()</a>)所创建，这些UI控件在下面的情况下使用Canvas.saveLayer()方法去绘制 alpha &lt; 1 (see<a href="http://developer.android.com/reference/android/view/View.html#setAlpha(float" target="_blank" rel="external">View.setAlpha()</a>)的View(即半透明View)：</p>
<ul>
<li><a href="http://developer.android.com/reference/android/view/View.html#getAlpha(" target="_blank" rel="external">getAlpha()</a> returns a value &lt; 1</li>
<li><a href="http://developer.android.com/reference/android/view/View.html#onSetAlpha(int" target="_blank" rel="external">onSetAlpha()</a> returns false</li>
<li><a href="http://developer.android.com/reference/android/view/View.html#getLayerType(" target="_blank" rel="external">getLayerType()</a> returns LAYER_TYPE_NONE</li>
<li><a href="http://developer.android.com/reference/android/view/View.html#hasOverlappingRendering(" target="_blank" rel="external">hasOverlappingRendering()</a> returns true</li>
</ul>
<p>我和Chet 在很多演示中解释过为什么你应该 <a href="https://youtu.be/vQZFaec9NpA?t=29m51s" target="_blank" rel="external">use alpha with care</a>，每次UI控件使用一个临时的Layer，绘制命令会发送不同的渲染目标，对GPU来说，切换渲染目标是很昂贵的操作,这对于使用tiling/deferred架构的GPU（ImaginationTech’s SGX, Qualcomm’s Adreno, etc）等是硬伤，直接渲染架构的GPU，比如 Nvidia，则会好一点。因为我和Joaquim 使用的是搭载高通处理器的Moto X 2014版本，所以使用多个临时硬件层是最有可能的性能问题的根源。</p>
<p>那么问题来了，是什么创建了这些临时的Layer呢？<em>Tracer</em>告诉我们了答案，如果你看了刚刚上面那张<a href="http://www.curious-creature.com/blog/wp-content/uploads/2015/03/Screen-Shot-2015-03-25-at-11.00.53-AM-950x552.png" target="_blank" rel="external">图</a>,你可以看到只有SaveLayer这个组中OpenGl命令绘制了一个小圆圈（图被工具放大了），我们来看一下应用截图：</p>
<p><img src="/images/android-performance-case-study-follow-up/before.png" alt="Falcon Pro 3"></p>
<p>你看到最上面的小圆圈了么？那是ViewPager的指示器，来显示当前的位置。Joaquim 使用了一个第三方库来绘制这些指示器，有趣的是这些库如何绘制指示器的：当前的Page用一个白色的圈指示，其他的页用类似灰色的圆圈来指示。我说类似灰色因为这个圆圈其实是半透明的白色圆圈。这个库使用 setAlpha()方法来给每个圆圈设置颜色。</p>
<p>有下面几种方法来解决这个问题：</p>
<ul>
<li>Use a customizable “inactive” color instead of setting an opacity on the View（ 使用动态的“inactive”颜色(即根据状态来设置View的颜色)而不是设置透明度。）</li>
<li><p>Return false from hasOverlappingRendering() and the framework will set the proper alpha on the Paint<br>for you（使hasOverlappingRendering()返回false，这样系统会设置适当的alpha，关于这个的用法，这篇<a href="http://imid.me/blog/2014/01/17/best-practices-for-using-alpha/" target="_blank" rel="external">文章</a>中有提到：同时Android提供了hasOverlappingRendering()接口，通过重写该接口可以告知系统当前View是否存在内容重叠的情况，帮助系统优化绘制流程，原理是这样的：对于有重叠内容的View，系统简单粗暴的使用 offscreen buffer来协助处理。当告知系统该View无重叠内容时，系统会分别使用合适的alpha值绘制每一层。）</p>
 <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns whether this View has content which overlaps. This function, intended <span class="keyword">to</span> be</span><br><span class="line"> * overridden <span class="keyword">by</span> specific View types, <span class="keyword">is</span> an optimization when alpha <span class="keyword">is</span> <span class="keyword">set</span> <span class="function_start"><span class="keyword">on</span></span> a view. If</span><br><span class="line"> * rendering overlaps <span class="keyword">in</span> a view <span class="keyword">with</span> alpha &lt; <span class="number">1</span>, <span class="keyword">that</span> view <span class="keyword">is</span> drawn <span class="keyword">to</span> an offscreen buffer</span><br><span class="line"> * <span class="keyword">and</span> <span class="keyword">then</span> composited <span class="keyword">it</span> <span class="keyword">into</span> place, which can be expensive. If <span class="keyword">the</span> view has no overlapping</span><br><span class="line"> * rendering, <span class="keyword">the</span> view can draw each primitive <span class="keyword">with</span> <span class="keyword">the</span> appropriate alpha value directly.</span><br><span class="line"> * An example <span class="keyword">of</span> overlapping rendering <span class="keyword">is</span> a TextView <span class="keyword">with</span> a background image, such <span class="keyword">as</span> a</span><br><span class="line"> * Button. An example <span class="keyword">of</span> non-overlapping rendering <span class="keyword">is</span> a TextView <span class="keyword">with</span> no background, <span class="keyword">or</span></span><br><span class="line"> * an ImageView <span class="keyword">with</span> only <span class="keyword">the</span> foreground image. The default implementation returns <span class="constant">true</span>;</span><br><span class="line"> * subclasses should override <span class="keyword">if</span> they have cases which can be optimized.</span><br><span class="line"> *</span><br><span class="line"> * @<span class="constant">return</span> <span class="constant">true</span> <span class="keyword">if</span> <span class="keyword">the</span> content <span class="keyword">in</span> this view might overlap, <span class="constant">false</span> otherwise.</span><br><span class="line"> */</span><br><span class="line">public <span class="type">boolean</span> hasOverlappingRendering() &#123;</span><br><span class="line"><span class="command">    return</span> <span class="constant">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Return true from onSetAlpha() and set an alpha on the Paint used to draw the “gray” circles（使onSetAlpha() 返回True并对Paint设置alpha来绘制“gray”圆圈）</p>
 <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paint.setAlpha((int) alpha * <span class="number">255</span>);</span><br><span class="line">canvas.draw*(<span class="keyword">...</span>, paint);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最简单的方法是使用第二种，但是他只能在API16以上使用，如果你要支持旧版本的Android，使用其他两个方法，我相信Joaquim 已经丢弃那个第三方库并使用自己的指示器了。</p>
<p>我希望这篇文章能让大家清楚如何从看似无辜的和无害的操作中寻找可能会出现性能问题。所以请记住:不要仅仅做出假设,要实际去验证、测量。</p>
<h1 id="附录">附录</h1><p>更多关于Alpha的使用，可以参考这篇文章：<br><a href="http://imid.me/blog/2014/01/17/best-practices-for-using-alpha/" target="_blank" rel="external">Android Tips: Best Practices for Using Alpha</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前言">前言</h1><p>本文是一篇译文，原文<a href="http://www.curious-creature.com/2015/03/25/android-performance-case-study-follow-up/?utm_source=Android+Weekly&amp;utm_campaign=0692ef161b-Android_Weekly_146&amp;utm_medium=email&amp;utm_term=0_4eb677ad19-0692ef161b-337850757">Android Performance Case Study Follow-up</a>的作者是大名鼎鼎的<a href="http://www.curious-creature.com/">Romain Guy</a>。本文讲述了Android性能优化的一些技巧、方法和工具。</p>
<h1 id="译文正文">译文正文</h1><p>两年前，我发表了一篇名为<a href="http://www.curious-creature.com/2012/12/01/android-performance-case-study/">Android Performance Case Study</a> 的文章，来帮助Android开发者了解需要使用什么工具和技术手段来确定、追踪和优化性能问题。</p>
<p>那篇文章以一个Twitter客户端 <a href="https://play.google.com/store/apps/details?id=com.jv.materialfalcon">Falcon Pro</a>为典范，其开发人员为 Joaquim Vergès. Joaquim人不错，他允许我在我的文章中使用它的程序作为例子，并且快速处理了我发现的所有问题。一切都OK，直到Joaquim 从头开始开发Falcon Pro 3，前不久在他准备发布它的新应用的时候，他联系了我，因为他有一个和滚动相关的性能问题需要我来帮助他，这一次我依然没有源代码可以参考。</p>]]>
    
    </summary>
    
      <category term="Android,Performance,性能优化" scheme="http://androidperformance.com/tags/Android-Performance-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(5)]]></title>
    <link href="http://androidperformance.com/2015/03/15/android-tips-round-up-5/"/>
    <id>http://androidperformance.com/2015/03/15/android-tips-round-up-5/</id>
    <published>2015-03-14T16:32:11.000Z</published>
    <updated>2015-03-27T05:35:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第五篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="https://developer.android.com/reference/android/support/v4/widget/ViewDragHelper.html" target="_blank" rel="external">ViewDragHelper</a> ——视图拖动是一个比较复杂的问题。这个类可以帮助解决不少问题。如果你需要一个例子，<a href="https://developer.android.com/reference/android/support/v4/widget/DrawerLayout.html" target="_blank" rel="external">DrawerLayout</a>就是利用它实现扫滑。Flavient Laurent 还写了一些关于这方面的<a href="http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper/" target="_blank" rel="external">优秀文章</a>。</p>
<a id="more"></a>
<p><a href="https://developer.android.com/reference/android/widget/PopupWindow.html" target="_blank" rel="external">PopupWindow</a>——Android到处都在使用PopupWindow ，甚至你都没有意识到（标题导航条ActionBar，自动补全AutoComplete，编辑框错误提醒Edittext Errors）。这个类是创建浮层内容的主要方法。</p>
<p><a href="https://developer.android.com/reference/android/app/ActionBar.htmlgetThemedContext%28%29" target="_blank" rel="external">Actionbar.getThemrContext()</a>——导航栏的主题化是很复杂的（不同于Activity其他部分的主题化）。你可以得到一个上下文（Context），用这个上下文创建的自定义组件可以得到正确的主题。</p>
<p><a href="https://developer.android.com/reference/android/media/ThumbnailUtils.html" target="_blank" rel="external">ThumbnailUtils</a>——帮助创建缩略图。通常我都是用现有的图片加载库（比如，Picasso 或者 Volley），不过这个ThumbnaiUtils可以创建视频缩略图。<strong>译者注：</strong>该API从V8才开始支持。</p>
<p><a href="https://developer.android.com/reference/android/content/Context.htmlgetExternalFilesDir%28java.lang.String%29" target="_blank" rel="external">Context.getExternalFilesDir()</a>———— 申请了SD卡写权限后，你可以在SD的任何地方写数据，把你的数据写在设计好的合适位置会更加有礼貌。这样数据可以及时被清理，也会有更好的用户体验。此外，Android 4.0 Kitkat中在这个文件夹下写数据是不需要权限的，每个用户有自己的独立的数据存储路径。<strong>译者注：</strong>该API从V8才开始支持。</p>
<p><a href="https://developer.android.com/reference/android/util/SparseArray.html" target="_blank" rel="external">SparseArray</a>——Map的高效优化版本。推荐了解姐妹类SparseBooleanArray、SparseIntArray和SparseLongArray。</p>
<p><a href="https://developer.android.com/reference/android/content/pm/PackageManager.htmlsetComponentEnabledSetting%28android.content.ComponentName,%20int,%20int%29" target="_blank" rel="external">PackageManager.setComponentEnabledSetting()</a>——可以用来启动或者禁用程序清单中的组件。对于关闭不需要的功能组件是非常赞的，比如关掉一个当前不用的广播接收器。</p>
<p><a href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.htmlyieldIfContendedSafely%28%29" target="_blank" rel="external">SQLiteDatabase.yieldIfContendedSafely()</a>——让你暂时停止一个数据库事务， 这样你可以就不会占用太多的系统资源。</p>
<p><a href="https://developer.android.com/reference/android/os/Environment.html#getExternalStoragePublicDirectory%28java.lang.String%29" target="_blank" rel="external">Environment.getExternalStoragePublicDirectory()</a>——还是那句话，用户期望在SD卡上得到统一的用户体验。用这个方法可以获得在用户设备上放置指定类型文件（音乐、图片等）的正确目录。</p>
<p><a href="https://developer.android.com/reference/android/view/View.htmlgenerateViewId%28%29" target="_blank" rel="external">View.generateViewId()</a>——每次我都想要推荐动态生成控件的ID。需要注意的是，不要和已经存在的控件ID或者其他已经生成的控件ID重复。</p>
<p><a href="https://developer.android.com/reference/android/app/ActivityManager.htmlclearApplicationUserData%28%29" target="_blank" rel="external">ActivityManager.clearApplicationUserData()</a>—— 一键清理你的app产生的用户数据，可能是做用户退出登录功能，有史以来最简单的方式了。</p>
<p><a href="http://developer.android.com/reference/android/content/Context.htmlcreateConfigurationContext%28android.%E2%80%94%E2%80%94ontent.res.Configuration%29" target="_blank" rel="external">Context.createConfigurationContext()</a> ——自定义你的配置环境信息。我通常会遇到这样的问题：强制让一部分显示在某个特定的环境下（倒不是我一直这样瞎整，说来话长，你很难理解）。用这个实现起来可以稍微简单一点。</p>
<p><a href="http://developer.android.com/reference/android/app/ActivityOptions.html" target="_blank" rel="external">ActivityOptions</a> ——方便的定义两个Activity切换的动画。 使用<a href="http://developer.android.com/reference/android/support/v4/app/ActivityOptionsCompat.html" target="_blank" rel="external">ActivityOptionsCompat</a> 可以很好解决旧版本的兼容问题。</p>
<p><a href="http://developer.android.com/reference/android/widget/AdapterViewFlipper.htmlfyiWillBeAdvancedByHostKThx%28%29" target="_blank" rel="external">AdapterViewFlipper.fyiWillBeAdvancedByHostKThx()</a>——仅仅因为很好玩，没有其他原因。在整个安卓开源项目中（AOSP the Android ——pen Source Project Android开放源代码项目）中还有其他很有意思的东西（比如<br><a href="http://developer.android.com/reference/android/hardware/SensorManager.htmlGRAVITY_DEATH_STAR_I" target="_blank" rel="external">GRAVITY_DEATH_STAR_I</a>）。不过，都不像这个这样，这个确实有用</p>
<p><a href="http://developer.android.com/reference/android/view/ViewParent.htmlrequestDisallowInterceptTouchEvent%28boolean%29" target="_blank" rel="external">ViewParent.requestDisallowInterceptTouchEvent()</a> ——Android系统触摸事件机制大多时候能够默认处理，不过有时候你需要使用这个方法来剥夺父级控件的控制权（顺便说一下，如果你想对Android触摸机制了解更多，<a href="https://www.youtube.com/watch?v=EZAoJU-nUyI" target="_blank" rel="external">这个演讲</a>会令你惊叹不已。）</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-5/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-5/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-5.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第五篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="https://developer.android.com/reference/android/support/v4/widget/ViewDragHelper.html">ViewDragHelper</a> ——视图拖动是一个比较复杂的问题。这个类可以帮助解决不少问题。如果你需要一个例子，<a href="https://developer.android.com/reference/android/support/v4/widget/DrawerLayout.html">DrawerLayout</a>就是利用它实现扫滑。Flavient Laurent 还写了一些关于这方面的<a href="http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper/">优秀文章</a>。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(4)]]></title>
    <link href="http://androidperformance.com/2015/03/15/android-tips-round-up-4/"/>
    <id>http://androidperformance.com/2015/03/15/android-tips-round-up-4/</id>
    <published>2015-03-14T16:31:02.000Z</published>
    <updated>2015-03-27T05:35:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第四篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/app/Activity.html#isChangingConfigurations%28%29" target="_blank" rel="external">Activity.isChangingConfigurations ()</a>——如果在 Activity 中 configuration 会经常改变的话，使用这个方法就可以不用手动做保存状态的工作了。</p>
<a id="more"></a>
<p><a href="http://developer.android.com/reference/android/content/SearchRecentSuggestionsProvider.html" target="_blank" rel="external">SearchRecentSuggestionsProvider</a>——可以创建最近提示效果的 provider，是一个简单快速的方法。</p>
<p><a href="http://developer.android.com/reference/android/view/ViewTreeObserver.html" target="_blank" rel="external">ViewTreeObserver</a>——这是一个很棒的工具。可以进入到 VIew 里面，并监控 View 结构的各种状态，通常我都用来做 View 的测量操作（自定义视图中经常用到）。</p>
<p><a href="https://www.timroes.de/2013/09/12/speed-up-gradle/" target="_blank" rel="external">org.gradle.daemon=true</a>——这句话可以帮助减少 Gradle 构建的时间，仅在命令行编译的时候用到，因为 Android Studio 已经这样使用了。</p>
<p><a href="http://developer.android.com/reference/android/database/DatabaseUtils.html" target="_blank" rel="external">DatabaseUtils</a>——一个包含各种数据库操作的使用工具。</p>
<p><a href="http://developer.android.com/reference/android/widget/LinearLayout.html#attr_android:weightSum" target="_blank" rel="external">android:weightSum (LinearLayout)</a>——如果想使用 layout weights，但是却不想填充整个 LinearLayout 的话，就可以用 weightSum 来定义总的 weight 大小。</p>
<p><a href="http://developer.android.com/reference/android/view/View.html#attr_android:duplicateParentState" target="_blank" rel="external">android:duplicateParentState (View)</a>——此方法可以使得子 View 可以复制父 View 的状态。比如如果一个 ViewGroup 是可点击的，那么可以用这个方法在它被点击的时候让它的子 View 都改变状态。</p>
<p><a href="http://developer.android.com/reference/android/view/ViewGroup.html#attr_android:clipChildren" target="_blank" rel="external">android:clipChildren (ViewGroup)</a>——如果此属性设置为不可用，那么 ViewGroup 的子 View 在绘制的时候会超出它的范围，在做动画的时候需要用到。</p>
<p><a href="http://developer.android.com/reference/android/widget/ScrollView.html#attr_android:fillViewport" target="_blank" rel="external">android:fillViewport (ScrollView)</a>——在这片文章中有详细介绍<a href="http://www.curious-creature.org/2010/08/15/scrollviews-handy-trick/" target="_blank" rel="external">文章链接</a>，可以解决在 ScrollView 中当内容不足的时候填不满屏幕的问题。</p>
<p><a href="http://developer.android.com/guide/topics/resources/drawable-resource.html#Bitmap" target="_blank" rel="external">android:tileMode (BitmapDrawable)</a>——可以指定图片使用重复填充的模式。</p>
<p><a href="http://developer.android.com/reference/android/R.attr.html#exitFadeDuration" target="_blank" rel="external">android:enterFadeDuration/android:exitFadeDuration (Drawables)</a>——此属性在 Drawable 具有多种状态的时候，可以定义它展示前的淡入淡出效果。</p>
<p><a href="http://developer.android.com/reference/android/widget/ImageView.html#attr_android:scaleType" target="_blank" rel="external">android:scaleType (ImageView)</a>——定义在 ImageView 中怎么缩放/剪裁图片，一般用的比较多的是“centerCrop”和“centerInside”。</p>
<p><a href="http://developer.android.com/training/improving-layouts/reusing-layouts.html#Merge" target="_blank" rel="external">Merge</a>——此标签可以在另一个布局文件中包含别的布局文件，而不用再新建一个 ViewGroup，对于自定义 ViewGroup 的时候也需要用到；可以通过载入一个带有标签的布局文件来自动定义它的子部件。</p>
<p><a href="http://developer.android.com/reference/android/util/AtomicFile.html" target="_blank" rel="external">AtomicFile</a>——通过使用备份文件进行文件的原子化操作。这个知识点之前我也写过，不过最好还是有出一个官方的版本比较好。</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-4/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-4/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-4.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第四篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/app/Activity.html#isChangingConfigurations%28%29">Activity.isChangingConfigurations ()</a>——如果在 Activity 中 configuration 会经常改变的话，使用这个方法就可以不用手动做保存状态的工作了。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(3)]]></title>
    <link href="http://androidperformance.com/2015/03/15/android-tips-round-up-3/"/>
    <id>http://androidperformance.com/2015/03/15/android-tips-round-up-3/</id>
    <published>2015-03-14T16:29:57.000Z</published>
    <updated>2015-03-27T05:35:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第三篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/net/UrlQuerySanitizer.html" target="_blank" rel="external">UrlQuerySanitizer</a>——使用这个工具可以方便对 URL 进行检查。</p>
<a id="more"></a>
<p><a href="http://developer.android.com/reference/android/app/Fragment.html#setArguments%28android.os.Bundle%29" target="_blank" rel="external">Fragment.setArguments</a>——因为在构建 Fragment 的时候不能加参数，所以这是个很好的东西，可以在创建 Fragment 之前设置参数（即使在 configuration 改变的时候仍然会导致销毁/重建）。</p>
<p><a href="http://developer.android.com/reference/android/app/DialogFragment.html#setShowsDialog%28boolean%29" target="_blank" rel="external">DialogFragment.setShowsDialog ()</a>—— 这是一个很巧妙的方式，DialogFragment 可以作为正常的 Fragment 显示！这里可以让 Fragment 承担双重任务。我通常在创建 Fragment 的时候把 onCreateView ()和 onCreateDialog ()都加上，就可以创建一个具有双重目的的 Fragment。</p>
<p><a href="http://developer.android.com/reference/android/app/FragmentManager.html#enableDebugLogging%28boolean%29" target="_blank" rel="external">FragmentManager.enableDebugLogging ()</a>——在需要观察 Fragment 状态的时候会有帮助。</p>
<p><a href="http://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html" target="_blank" rel="external">LocalBroadcastManager</a>——这个会比全局的 broadcast 更加安全，简单，快速。像 <a href="http://square.github.io/otto/" target="_blank" rel="external">otto</a> 这样的 Event buses 机制对你的应用场景更加有用。</p>
<p><a href="http://developer.android.com/reference/android/telephony/PhoneNumberUtils.html#formatNumber%28java.lang.String%29" target="_blank" rel="external">PhoneNumberUtils.formatNumber ()</a>——顾名思义，这是对数字进行格式化操作的时候用的。</p>
<p><a href="http://developer.android.com/reference/android/graphics/Region.html#op%28android.graphics.Region,%20android.graphics.Region,%20android.graphics.Region.Op%29" target="_blank" rel="external">Region.op()</a>——我发现在对比两个渲染之前的区域的时候很实用，如果你有两条路径，那么怎么知道它们是不是会重叠呢？使用这个方法就可以做到。</p>
<p><a href="http://developer.android.com/reference/android/app/Application.html#registerActivityLifecycleCallbacks%28android.app.Application.ActivityLifecycleCallbacks%29" target="_blank" rel="external">Application.registerActivityLifecycleCallbacks</a>——虽然缺少官方文档解释，不过我想它就是注册 Activity 的生命周期的一些回调方法（顾名思义），就是一个方便的工具。</p>
<p><a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Build-Types" target="_blank" rel="external">versionNameSuffix</a>——这个 gradle 设置可以让你在基于不同构建类型的 manifest 中修改版本名这个属性，例如，如果需要在在 debug 版本中以”-SNAPSHOT”结尾，那么就可以轻松的看出当前是 debug 版还是 release 版。</p>
<p><a href="http://developer.android.com/reference/android/database/CursorJoiner.html" target="_blank" rel="external">CursorJoiner</a>——如果你是只使用一个数据库的话，使用 SQL 中的 join 就可以了，但是如果收到的数据是来自两个独立的 ContentProvider，那么 CursorJoiner 就很实用了。</p>
<p><a href="http://www.genymotion.com/" target="_blank" rel="external">Genymotion</a>——一个非常快的 Android 模拟器，本人一直在用。</p>
<p><a href="http://developer.android.com/guide/practices/screens_support.html#qualifiers" target="_blank" rel="external">-nodpi</a>——在没有特别定义的情况下，很多修饰符(-mdpi,-hdpi,-xdpi等等)都会默认自动缩放 assets/dimensions，有时候我们需要保持显示一致，这种情况下就可以使用 -nodpi。</p>
<p><a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#setDebugUnregister%28boolean%29" target="_blank" rel="external">BroadcastRecevier.setDebugUnregister ()</a>——又一个方便的调试工具。</p>
<p><a href="http://developer.android.com/reference/android/app/Activity.html#recreate%28%29" target="_blank" rel="external">Activity.recreate ()</a>——强制让 Activity 重建。</p>
<p><a href="http://developer.android.com/reference/android/content/pm/PackageManager.html#checkSignatures%28java.lang.String,%20java.lang.String%29" target="_blank" rel="external">PackageManager.checkSignatures ()</a>——如果同时安装了两个 app 的话，可以用这个方法检查。如果不进行签名检查的话，其他人可以轻易通过使用一样的包名来模仿你的 app。</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-3/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-3/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-3.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第三篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/net/UrlQuerySanitizer.html">UrlQuerySanitizer</a>——使用这个工具可以方便对 URL 进行检查。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为Nexus5编译AndroidL固件]]></title>
    <link href="http://androidperformance.com/2015/02/04/build-rom-for-nexus5/"/>
    <id>http://androidperformance.com/2015/02/04/build-rom-for-nexus5/</id>
    <published>2015-02-04T12:51:19.000Z</published>
    <updated>2015-04-01T13:11:05.000Z</updated>
    <content type="html"><![CDATA[<p>接前一篇文章<a href="http://www.androidperformance.com/view-android-source-code-with-androidstudio.html" target="_blank" rel="external">使用Android Studio查看Android Lollipop源码</a>, 我们知道,仅仅看代码,提高是比较有限的,而且理解起来也比较肤浅,往往过目就忘. 而自己写过的代码,往往会印象比较深刻,在写的时候也会比较容易理解流程. 所以我们在看代码的同时, 如果能修改代码, 在手机上跑起来并看到修改的效果,这无疑会加快看代码的效率和积极性. 所以这篇文章,就讲解一下如何自己编译AndroidL的源码,并且在Nexus5上跑起来. 至于为何需要自己编译固件,而不是直接安装Google给出的工厂固件?原因是Google给出的工厂固件是User版本,是没法随心所欲Push东西进去的. 所以我们需要编译自己的Userdebug版本.</p>
<p>本文假设你已经下载了AndroidL的源码,并且有一台Nexus5手机(手机系统开发人员必备), 如果你还没有AndroidL的源码,或者你有源码但是没有配置编译的环境,那么 <a href="https://source.android.com/source/initializing.html" target="_blank" rel="external">Initializing a Build Environment</a> 和<a href="https://source.android.com/source/downloading.html" target="_blank" rel="external">Downloading the Source</a>这两篇文章你应该先去看一下(我又一次假设你会翻墙,如果你不会翻墙,那么下代码也是一个痛苦的事情). 这后面的教程Google官网也有教程.所以我只针对Nexus5进行讲解.</p>
<p>另外你需要知道AOSP,AOSP即Android Open Source Project 汉语意思是：谷歌开放源代码项目.我们通过Google官方下载的源代码,就是AOSP的代码, 其中是不包含Google开发的那些个应用的,各个厂商拿到的也是这个版本,在这个版本的基础上进行修改. 而Google发布的工厂固件则是包含全套Google服务的. 厂商如果想安装Google服务,就需要过Google的那一套认证,比较麻烦,而且价格不菲,鉴于Google在国内的尴尬地位,国内很多厂商都没有过这个认证.</p>
<a id="more"></a>
<h3 id="1-_初始化编译环境">1. 初始化编译环境</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">. </span>build/envsetup.sh</span><br></pre></td></tr></table></figure>
<h3 id="2-_加载机型">2. 加载机型</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lunch</span><br></pre></td></tr></table></figure>
<h3 id="3-_选择要编译的机器">3. 选择要编译的机器</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">You're building <span class="function_start"><span class="keyword">on</span></span> Linux</span><br><span class="line"></span><br><span class="line">Lunch menu... pick a combo:</span><br><span class="line">     <span class="number">1.</span> aosp_arm-eng</span><br><span class="line">     <span class="number">2.</span> aosp_arm64-eng</span><br><span class="line">     <span class="number">3.</span> aosp_mips-eng</span><br><span class="line">     <span class="number">4.</span> aosp_mips64-eng</span><br><span class="line">     <span class="number">5.</span> aosp_x86-eng</span><br><span class="line">     <span class="number">6.</span> aosp_x86_64-eng</span><br><span class="line">     <span class="number">7.</span> aosp_shamu-userdebug</span><br><span class="line">     <span class="number">8.</span> aosp_manta-userdebug</span><br><span class="line">     <span class="number">9.</span> full_fugu-userdebug</span><br><span class="line">     <span class="number">10.</span> aosp_fugu-userdebug</span><br><span class="line">     <span class="number">11.</span> aosp_grouper-userdebug</span><br><span class="line">     <span class="number">12.</span> aosp_tilapia-userdebug</span><br><span class="line">     <span class="number">13.</span> aosp_deb-userdebug</span><br><span class="line">     <span class="number">14.</span> aosp_flo-userdebug</span><br><span class="line">     <span class="number">15.</span> aosp_mako-userdebug</span><br><span class="line">     <span class="number">16.</span> aosp_hammerhead-userdebug</span><br><span class="line">     <span class="number">17.</span> aosp_flounder-userdebug</span><br><span class="line">     <span class="number">18.</span> mini_emulator_x86_64-userdebug</span><br><span class="line">     <span class="number">19.</span> mini_emulator_arm-userdebug</span><br><span class="line">     <span class="number">20.</span> mini_emulator_x86-userdebug</span><br><span class="line">     <span class="number">21.</span> mini_emulator_mips-userdebug</span><br><span class="line">     <span class="number">22.</span> mini_emulator_arm64-userdebug</span><br></pre></td></tr></table></figure>
<h4 id="3-1_机型对照表">3.1 机型对照表</h4><table>
<thead>
<tr>
<th>DEVICE</th>
<th>CODE NAME</th>
<th>BUILD CONFIGURATION</th>
</tr>
</thead>
<tbody>
<tr>
<td>Nexus 6</td>
<td>shamu</td>
<td>aosp_shamu-userdebug</td>
</tr>
<tr>
<td>Nexus Player</td>
<td>fugu</td>
<td>aosp_fugu-userdebug</td>
</tr>
<tr>
<td>Nexus 9</td>
<td>volantis (flounder)</td>
<td>aosp_flounder-userdebug</td>
</tr>
<tr>
<td>Nexus 5 (GSM/LTE)</td>
<td>hammerhead</td>
<td>aosp_hammerhead-userdebug</td>
</tr>
<tr>
<td>Nexus 7 (Wi-Fi)</td>
<td>razor (flo)</td>
<td>aosp_flo-userdebug</td>
</tr>
<tr>
<td>Nexus 7 (Mobile)</td>
<td>razorg (deb)</td>
<td>aosp_deb-userdebug</td>
</tr>
<tr>
<td>Nexus 10</td>
<td>mantaray (manta)</td>
<td>full_manta-userdebug</td>
</tr>
<tr>
<td>Nexus 4</td>
<td>occam (mako)</td>
<td>full_mako-userdebug</td>
</tr>
<tr>
<td>Nexus 7 (Wi-Fi)</td>
<td>nakasi (grouper)</td>
<td>full_grouper-userdebug</td>
</tr>
<tr>
<td>Nexus 7 (Mobile)</td>
<td>nakasig (tilapia)</td>
<td>full_tilapia-userdebug</td>
</tr>
<tr>
<td>Galaxy Nexus (GSM/HSPA+)</td>
<td>yakju (maguro)</td>
<td>full_maguro-userdebug</td>
</tr>
<tr>
<td>Galaxy Nexus (Verizon)</td>
<td>mysid (toro)</td>
<td>aosp_toro-userdebug</td>
</tr>
<tr>
<td>Galaxy Nexus (Experimental)</td>
<td>mysidspr (toroplus)</td>
<td>aosp_toroplus-userdebug</td>
</tr>
<tr>
<td>PandaBoard (Archived)</td>
<td>panda</td>
<td>aosp_panda-userdebug</td>
</tr>
<tr>
<td>Motorola Xoom (U.S. Wi-Fi)</td>
<td>wingray</td>
<td>full_wingray-userdebug</td>
</tr>
<tr>
<td>Nexus S</td>
<td>soju (crespo)</td>
<td>full_crespo-userdebug</td>
</tr>
<tr>
<td>Nexus S 4G</td>
<td>sojus (crespo4g)</td>
<td>full_crespo4g-userdebug3.2</td>
</tr>
</tbody>
</table>
<h4 id="3-2_三个版本说明版本">3.2 三个版本说明版本</h4><table>
<thead>
<tr>
<th>BUILDTYPE</th>
<th>USE</th>
</tr>
</thead>
<tbody>
<tr>
<td>user</td>
<td>limited access; suited for production</td>
</tr>
<tr>
<td>userdebug</td>
<td>like “user” but with root access and debuggability; preferred for debugging</td>
</tr>
<tr>
<td>eng</td>
<td>development configuration with additional debugging tools</td>
</tr>
</tbody>
</table>
<p>选择aosp_hammerhead-userdebug之后,会有下面的确认信息:</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">============================================</span><br><span class="line"><span class="variable">PLATFORM_VERSION_CODENAME=</span>REL</span><br><span class="line"><span class="variable">PLATFORM_VERSION=</span><span class="number">5.0</span>.<span class="number">50.50</span>.<span class="number">50.50</span></span><br><span class="line"><span class="variable">TARGET_PRODUCT=</span>aosp_hammerhead</span><br><span class="line"><span class="variable">TARGET_BUILD_VARIANT=</span>userdebug</span><br><span class="line"><span class="variable">TARGET_BUILD_TYPE=</span>release</span><br><span class="line"><span class="variable">TARGET_BUILD_APPS=</span></span><br><span class="line"><span class="variable">TARGET_ARCH=</span>arm</span><br><span class="line"><span class="variable">TARGET_ARCH_VARIANT=</span>armv7-a-neon</span><br><span class="line"><span class="variable">TARGET_CPU_VARIANT=</span>krait</span><br><span class="line"><span class="variable">TARGET_2ND_ARCH=</span></span><br><span class="line"><span class="variable">TARGET_2ND_ARCH_VARIANT=</span></span><br><span class="line"><span class="variable">TARGET_2ND_CPU_VARIANT=</span></span><br><span class="line"><span class="variable">HOST_ARCH=</span>x86_64</span><br><span class="line"><span class="variable">HOST_OS=</span>linux</span><br><span class="line"><span class="variable">HOST_OS_EXTRA=</span>Linux-<span class="number">3.13</span>.<span class="number">0</span>-<span class="number">37</span>-generic-x86_64-<span class="keyword">with</span>-Ubuntu-<span class="number">14.10</span>-utopic</span><br><span class="line"><span class="variable">HOST_BUILD_TYPE=</span>release</span><br><span class="line"><span class="variable">BUILD_ID=</span>AOSP</span><br><span class="line"><span class="variable">OUT_DIR=</span><span class="variable">out</span><br><span class="line">=</span>===========================================</span><br></pre></td></tr></table></figure>
<h3 id="4-_生成驱动目录">4. 生成驱动目录</h3><p>接下来需要在<a href="https://developers.google.com/android/nexus/drivers#hammerheadlrx22c" target="_blank" rel="external">Android官网</a>下载 Nexus5所需要的驱动:</p>
<table>
<thead>
<tr>
<th>HARDWARE COMPONENT</th>
<th>COMPANY</th>
<th>DOWNLOAD</th>
<th>MD5 CHECKSUM</th>
<th>SHA-1 CHECKSUM</th>
</tr>
</thead>
<tbody>
<tr>
<td>NFC, Bluetooth, Wi-Fi</td>
<td>Broadcom</td>
<td><a href="https://dl.google.com/dl/android/aosp/broadcom-hammerhead-lrx22c-964d941e.tgz" target="_blank" rel="external">Link</a></td>
<td>2c398994e37093df51b105d63f0eb611</td>
<td>991346159c95ae75f760014a6822b8b3e8667700</td>
</tr>
<tr>
<td>Camera, Sensors, Audio</td>
<td>LG</td>
<td><a href="https://dl.google.com/dl/android/aosp/lge-hammerhead-lrx22c-95a9d465.tgz" target="_blank" rel="external">Link</a></td>
<td>74cf8235e6bb04da28b2ff738b13eee9</td>
<td>175dd5bae81bb54030d072cb0f0b4ec81eb3f71f</td>
</tr>
<tr>
<td>Graphics, GSM, Camera, GPS, Sensors, Media, DSP, USB</td>
<td>Qualcomm</td>
<td><a href="https://dl.google.com/dl/android/aosp/lge-hammerhead-lrx22c-95a9d465.tgz" target="_blank" rel="external">Link</a></td>
<td>0a43395e175d3de3dc312d8abdcb4f20</td>
<td>007cf9d49f0409d5c703e7f2811fd153fee22353</td>
</tr>
</tbody>
</table>
<p>下载完成后,解压出来是三个.sh文件,放到Android源码目录下面,然后执行.会将相关驱动放到vender目录下面.</p>
<h3 id="5-_执行编译命令">5. 执行编译命令</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span> -j8</span><br></pre></td></tr></table></figure>
<p>如果没有出错的话,在经过漫长的时间之后,编译成功:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Installed file <span class="string">list:</span> out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>installed-files.txt</span><br><span class="line">Target system fs <span class="string">image:</span> out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>obj<span class="regexp">/PACKAGING/</span>systemimage_intermediates/system.img</span><br><span class="line"><span class="string">Running:</span>  mkuserimg.sh -s out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>system out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>obj<span class="regexp">/PACKAGING/</span>systemimage_intermediates<span class="regexp">/system.img ext4 system 1073741824 -L system out/</span>target<span class="regexp">/product/</span>hammerhead<span class="regexp">/root/</span>file_contexts</span><br><span class="line">make_ext4fs -s -T -<span class="number">1</span> -S out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>root<span class="regexp">/file_contexts -L system -l 1073741824 -a system out/</span>target<span class="regexp">/product/</span>hammerhead<span class="regexp">/obj/</span>PACKAGING<span class="regexp">/systemimage_intermediates/</span>system.img out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>system</span><br><span class="line">Creating filesystem with <span class="string">parameters:</span></span><br><span class="line"><span class="label">    Size:</span> <span class="number">1073741824</span></span><br><span class="line">    Block <span class="string">size:</span> <span class="number">4096</span></span><br><span class="line">    Blocks per <span class="string">group:</span> <span class="number">32768</span></span><br><span class="line">    Inodes per <span class="string">group:</span> <span class="number">8192</span></span><br><span class="line">    Inode <span class="string">size:</span> <span class="number">256</span></span><br><span class="line">    Journal <span class="string">blocks:</span> <span class="number">4096</span></span><br><span class="line"><span class="label">    Label:</span> system</span><br><span class="line"><span class="label">    Blocks:</span> <span class="number">262144</span></span><br><span class="line">    Block <span class="string">groups:</span> <span class="number">8</span></span><br><span class="line">    Reserved block group <span class="string">size:</span> <span class="number">63</span></span><br><span class="line">Created filesystem with <span class="number">1445</span><span class="regexp">/65536 inodes and 85879/</span><span class="number">262144</span> blocks</span><br><span class="line">Install system fs <span class="string">image:</span> out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>system.img</span><br><span class="line">out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>system.img+out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>obj<span class="regexp">/PACKAGING/</span>recovery_patch_intermediates/recovery_from_boot.p maxsize=<span class="number">1096212480</span> blocksize=<span class="number">135168</span> total=<span class="number">336629666</span> reserve=<span class="number">11083776</span></span><br></pre></td></tr></table></figure>
<h3 id="6-_刷机命令">6. 刷机命令</h3><p>Nexus5关机状态下,长按音量下+电源,即可进入recovery模式, 然后在源码根目录下执行下面命令:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fastboot</span> -w flashall</span><br></pre></td></tr></table></figure>
<p>刷机成功后会自动重启</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">~/Android-SourceCode fastboot -w flashall</span><br><span class="line">target reported max download size of <span class="number">1073741824</span> bytes</span><br><span class="line">Creating filesystem with parameters:</span><br><span class="line">    Size: <span class="number">13725835264</span></span><br><span class="line">    Block size: <span class="number">4096</span></span><br><span class="line">    Blocks per group: <span class="number">32768</span></span><br><span class="line">    Inodes per group: <span class="number">8144</span></span><br><span class="line">    Inode size: <span class="number">256</span></span><br><span class="line">    Journal blocks: <span class="number">32768</span></span><br><span class="line">    Label: </span><br><span class="line">    Blocks: <span class="number">3351034</span></span><br><span class="line">    Block groups: <span class="number">103</span></span><br><span class="line">    Reserved block group size: <span class="number">823</span></span><br><span class="line">Created filesystem with <span class="number">11</span>/<span class="number">838832</span> inodes and <span class="number">93654</span>/<span class="number">3351034</span> blocks</span><br><span class="line">Creating filesystem with parameters:</span><br><span class="line">    Size: <span class="number">734003200</span></span><br><span class="line">    Block size: <span class="number">4096</span></span><br><span class="line">    Blocks per group: <span class="number">32768</span></span><br><span class="line">    Inodes per group: <span class="number">7472</span></span><br><span class="line">    Inode size: <span class="number">256</span></span><br><span class="line">    Journal blocks: <span class="number">2800</span></span><br><span class="line">    Label: </span><br><span class="line">    Blocks: <span class="number">179200</span></span><br><span class="line">    Block groups: <span class="number">6</span></span><br><span class="line">    Reserved block group size: <span class="number">47</span></span><br><span class="line">Created filesystem with <span class="number">11</span>/<span class="number">44832</span> inodes and <span class="number">5813</span>/<span class="number">179200</span> blocks</span><br><span class="line">--------------------------------------------</span><br><span class="line">Bootloader Version...: HHZ12d</span><br><span class="line">Baseband Version.....: M8974A-<span class="number">2.0</span><span class="number">.50</span><span class="number">.2</span><span class="number">.22</span></span><br><span class="line">Serial Number........: 08ade1a513dc087b</span><br><span class="line">--------------------------------------------</span><br><span class="line">checking product...</span><br><span class="line">OKAY [  <span class="number">0.</span>100s]</span><br><span class="line">sending <span class="string">'boot'</span> (<span class="number">8950</span> KB)<span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">0.</span>500s]</span><br><span class="line">writing <span class="string">'boot'</span><span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">0.</span>784s]</span><br><span class="line">sending <span class="string">'recovery'</span> (<span class="number">9672</span> KB)<span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">0.</span>556s]</span><br><span class="line">writing <span class="string">'recovery'</span><span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">0.</span>814s]</span><br><span class="line">erasing <span class="string">'system'</span><span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">1.</span>166s]</span><br><span class="line">sending <span class="string">'system'</span> (<span class="number">328187</span> KB)<span class="keyword">...</span></span><br><span class="line">OKAY [ <span class="number">10.</span>501s]</span><br><span class="line">writing <span class="string">'system'</span><span class="keyword">...</span></span><br><span class="line">OKAY [ <span class="number">23.</span>623s]</span><br><span class="line">erasing <span class="string">'userdata'</span><span class="keyword">...</span></span><br><span class="line">OKAY [ <span class="number">14.</span>657s]</span><br><span class="line">sending <span class="string">'userdata'</span> (<span class="number">137318</span> KB)<span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">4.</span>520s]</span><br><span class="line">writing <span class="string">'userdata'</span><span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">9.</span>776s]</span><br><span class="line">erasing <span class="string">'cache'</span><span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">0.</span>618s]</span><br><span class="line">sending <span class="string">'cache'</span> (<span class="number">13348</span> KB)<span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">0.</span>630s]</span><br><span class="line">writing <span class="string">'cache'</span><span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">1.</span>070s]</span><br><span class="line">rebooting...</span><br><span class="line"></span><br><span class="line">finished. total time: <span class="number">70.</span>095s</span><br></pre></td></tr></table></figure>
<h3 id="7-秀桌面">7.秀桌面</h3><p><img src="/images/build-image-for-nexus-5/Nexus5.png" alt="image"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接前一篇文章<a href="http://www.androidperformance.com/view-android-source-code-with-androidstudio.html">使用Android Studio查看Android Lollipop源码</a>, 我们知道,仅仅看代码,提高是比较有限的,而且理解起来也比较肤浅,往往过目就忘. 而自己写过的代码,往往会印象比较深刻,在写的时候也会比较容易理解流程. 所以我们在看代码的同时, 如果能修改代码, 在手机上跑起来并看到修改的效果,这无疑会加快看代码的效率和积极性. 所以这篇文章,就讲解一下如何自己编译AndroidL的源码,并且在Nexus5上跑起来. 至于为何需要自己编译固件,而不是直接安装Google给出的工厂固件?原因是Google给出的工厂固件是User版本,是没法随心所欲Push东西进去的. 所以我们需要编译自己的Userdebug版本.</p>
<p>本文假设你已经下载了AndroidL的源码,并且有一台Nexus5手机(手机系统开发人员必备), 如果你还没有AndroidL的源码,或者你有源码但是没有配置编译的环境,那么 <a href="https://source.android.com/source/initializing.html">Initializing a Build Environment</a> 和<a href="https://source.android.com/source/downloading.html">Downloading the Source</a>这两篇文章你应该先去看一下(我又一次假设你会翻墙,如果你不会翻墙,那么下代码也是一个痛苦的事情). 这后面的教程Google官网也有教程.所以我只针对Nexus5进行讲解.</p>
<p>另外你需要知道AOSP,AOSP即Android Open Source Project 汉语意思是：谷歌开放源代码项目.我们通过Google官方下载的源代码,就是AOSP的代码, 其中是不包含Google开发的那些个应用的,各个厂商拿到的也是这个版本,在这个版本的基础上进行修改. 而Google发布的工厂固件则是包含全套Google服务的. 厂商如果想安装Google服务,就需要过Google的那一套认证,比较麻烦,而且价格不菲,鉴于Google在国内的尴尬地位,国内很多厂商都没有过这个认证.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之Systrace工具介绍(一)]]></title>
    <link href="http://androidperformance.com/2015/01/30/android-performance-tools-systrace-1/"/>
    <id>http://androidperformance.com/2015/01/30/android-performance-tools-systrace-1/</id>
    <published>2015-01-30T12:24:31.000Z</published>
    <updated>2015-04-01T13:17:14.000Z</updated>
    <content type="html"><![CDATA[<p> 本文是Android性能优化工具系列的第一篇，这个系列主要介绍Android性能优化过程中会使用到的一些工具，以及如何用这些工具来发现问题和解决问题。在性能优化方面，Android有不少性能工具供大家来使用，按照我们一贯地 “发现问题-解决问题”的思路来看，发现问题才是最主要的，一上来就想着如何去解决问题，反而会事倍功半。</p>
<p>这一篇先来简单介绍一下Systrace这个工具。</p>
<h2 id="Systrace简单介绍">Systrace简单介绍</h2><p>Systrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务，View系统等）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。</p>
<p>Systrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。在Android平台中，它主要由3部分组成：</p>
<ul>
<li>内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</li>
<li>数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。</li>
<li>数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录/tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。 从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用Android提供的Trace类来使用Systrace.<br>关于Systrace的官方介绍和使用可以看这里：<a href="http://developer.android.com/tools/help/systrace.html" title="SysTrace官方介绍" target="_blank" rel="external">Systrace</a></li>
</ul>
<a id="more"></a>
<h2 id="Systrace简单使用">Systrace简单使用</h2><p>使用Systrace前，要先了解一下Systrace在各个平台上的使用方法，鉴于大家使用Eclipse和Android Studio的居多，所以直接摘抄官网关于这个的使用方法，不过不管是什么工具，流程是一样的：</p>
<ul>
<li>手机准备好你要进行抓取的界面</li>
<li>点击开始抓取（命令行的话就是开始执行命令）</li>
<li>手机上开始操作</li>
<li>设定好的时间到了之后，会将生成Trace文件，使用Chrome将这个文件打开进行分析</li>
</ul>
<h4 id="Using_Eclipse">Using <strong>Eclipse</strong></h4><ol>
<li><p>In Eclipse, open an Android application project.</p>
<ol>
<li>Switch to the DDMS perspective, by selecting Window &gt; Perspectives &gt; DDMS.</li>
<li>In the Devices tab, select the device on which to run a trace. If no devices are listed, make sure your device is connected via USB cable and that debugging is enabled on the device.</li>
<li>Click the Systrace icon at the top of the Devices panel to configure tracing.</li>
<li>Set the tracing options and click OK to start the trace.</li>
</ol>
</li>
</ol>
<h4 id="Using_Android_Studio">Using <strong> Android Studio</strong></h4><ol>
<li><p>In Android Studio, open an Android application project.</p>
<ol>
<li>Open the Device Monitor by selecting Tools &gt; Android &gt; Monitor.</li>
<li>In the Devices tab, select the device on which to run a trace. If no devices are listed, make sure your device is connected via USB cable and that debugging is enabled on the device.</li>
<li>Click the Systrace icon at the top of the Devices panel to configure tracing.</li>
<li>Set the tracing options and click OK to start the trace.</li>
</ol>
</li>
</ol>
<h4 id="Using_Device_Monitor">Using <strong>Device Monitor</strong></h4><ol>
<li><p>Navigate to your SDK tools/ directory.</p>
<ol>
<li>Run the monitor program.</li>
<li>In the Devices tab, select the device on which to run a trace. If no devices are listed, make sure your device is connected via USB cable and that debugging is enabled on the device.</li>
<li>Click the Systrace icon at the top of the Devices panel to configure tracing.</li>
<li>Set the tracing options and click OK to start the trace.</li>
</ol>
</li>
</ol>
<h4 id="Command_Line_Usage">Command Line Usage</h4><p>命令行形式比较灵活，速度也比较快，一次性配置好之后，以后再使用的时候就会很快就出结果（<strong>强烈推荐</strong>）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd android-sdk/platform-tools/systrace</span><br><span class="line">$ python systrace<span class="class">.py</span> --time=<span class="number">10</span> -o mynewtrace<span class="class">.html</span> sched gfx view wm</span><br></pre></td></tr></table></figure>
<p>从上面的命令可以看到Systrace工具的位置，只需要在Bash中配置好对应的路径和Alias，使用起来还是很快速的。另外User版本是不可以抓Trace的，只有ENG版本或者Userdebug版本才可以。</p>
<p>抓取结束后，会生成对应的Trace文件，注意这个文件只能被Chrome打开。关于如何分析Trace文件，我们下面的章节会讲。不论使用那种工具，在抓取之前都会让选择参数，下面说一下这些参数的意思：</p>
<ul>
<li>-h, —help Show the help message.（帮助）</li>
<li>-o  Write the HTML trace report to the specified file.（即输出文件名，）</li>
<li>-t N, —time=N Trace activity for N seconds. The default value is 5 seconds. （Trace抓取的时间，一般是 ： -t 8）</li>
<li>-b N, —buf-size=N Use a trace buffer size of N kilobytes. This option lets you limit the total size of the data collected during a trace.</li>
<li>-k</li>
<li>—ktrace= Trace the activity of specific kernel functions, specified in a comma-separated list.</li>
<li><p>-l, —list-categories List the available tracing category tags. The available tags are(下面的参数不用翻译了估计大家也看得懂，贴官方的解释也会比较权威，后面分析的时候我们会看到这些参数的作业的):</p>
<ul>
<li><strong>gfx</strong> - Graphics</li>
<li><strong>input</strong> - Input</li>
<li><strong>view</strong> - View</li>
<li>webview - WebView</li>
<li><strong>wm</strong> - Window Manager</li>
<li><strong>am</strong> - Activity Manager</li>
<li>audio - Audio</li>
<li>video - Video</li>
<li>camera - Camera</li>
<li>hal - Hardware Modules</li>
<li>res - Resource Loading</li>
<li><strong>dalvik</strong> - Dalvik VM</li>
<li>rs - RenderScript</li>
<li><strong>sched</strong> - CPU Scheduling</li>
<li><strong>freq</strong> - CPU Frequency</li>
<li><strong>membus</strong> - Memory Bus Utilization</li>
<li><strong>idle</strong> - CPU Idle</li>
<li><strong>disk</strong> - Disk input and output</li>
<li><strong>load</strong> - CPU Load</li>
<li><strong>sync</strong> - Synchronization Manager</li>
<li><strong>workq</strong> - Kernel Workqueues Note: Some trace categories are not supported on all devices. Tip: If you want to see the names of tasks in the trace output, you must include the sched category in your command parameters.</li>
</ul>
</li>
<li><p>-a</p>
</li>
<li>—app= Enable tracing for applications, specified as a comma-separated list of package names. The apps must contain tracing instrumentation calls from the Trace class. For more information, see Analyzing Display and Performance.</li>
<li>—link-assets Link to the original CSS or JavaScript resources instead of embedding them in the HTML trace report.</li>
<li>—from-file= Create the interactive Systrace report from a file, instead of running a live trace.</li>
<li>—asset-dir= Specify a directory for the trace report assets. This option is useful for maintaining a single set of assets for multiple Systrace reports.</li>
<li>-e</li>
<li>—serial= Conduct the trace on a specific connected device, identified by its device serial number.<br>上面的参数虽然比较多，但使用工具的时候不需考虑这么多，在对应的项目前打钩即可，命令行的时候才会去手动加参数：</li>
</ul>
<p>我们一般会把这个命令配置成Alias，配置如下：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias <span class="keyword">st</span>-start=<span class="string">'python /home/gaojianwu/Software/android-studio/sdk/platform-tools/systrace/systrace.py'</span>  </span><br><span class="line">alias <span class="keyword">st</span>-start-gfx-trace = ‘<span class="keyword">st</span>-start -<span class="keyword">t</span> <span class="number">8</span> gfx <span class="built_in">input</span> <span class="keyword">view</span> sched freq wm <span class="keyword">am</span> hwui workq <span class="keyword">res</span> dalvik <span class="keyword">sync</span> disk load perf hal rs idle mmc’</span><br></pre></td></tr></table></figure>
<p>这样在使用的时候，可以直接敲 <strong>st-start-gfx-mx4</strong> 即可，当然为了区分和保持各个文件，还需要加上 <strong>-o xxx.Trace</strong> .上面的命令和参数不必一次就理解，只需要记住如何简单使用即可，在分析的过程中，这些东西都会慢慢熟悉的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 本文是Android性能优化工具系列的第一篇，这个系列主要介绍Android性能优化过程中会使用到的一些工具，以及如何用这些工具来发现问题和解决问题。在性能优化方面，Android有不少性能工具供大家来使用，按照我们一贯地 “发现问题-解决问题”的思路来看，发现问题才是最主要的，一上来就想着如何去解决问题，反而会事倍功半。</p>
<p>这一篇先来简单介绍一下Systrace这个工具。</p>
<h2 id="Systrace简单介绍">Systrace简单介绍</h2><p>Systrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务，View系统等）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。</p>
<p>Systrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。在Android平台中，它主要由3部分组成：</p>
<ul>
<li>内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</li>
<li>数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。</li>
<li>数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录/tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。 从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用Android提供的Trace类来使用Systrace.<br>关于Systrace的官方介绍和使用可以看这里：<a href="http://developer.android.com/tools/help/systrace.html" title="SysTrace官方介绍">Systrace</a></li>
</ul>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Android Studio查看Android Lollipop源码]]></title>
    <link href="http://androidperformance.com/2015/01/16/view-android-source-code-with-androidstudio/"/>
    <id>http://androidperformance.com/2015/01/16/view-android-source-code-with-androidstudio/</id>
    <published>2015-01-16T13:54:32.000Z</published>
    <updated>2015-04-01T13:25:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Android_Studio">Android Studio</h2><p>作为Google的亲儿子,Nexus手机系列所收到的待遇大家有目共睹.Android5.0出来之后,Nexus5第一时间就升级到了最新的系统.那么作为Google亲儿子的Android Studio同样备受Google的重视,我也是第一时间从Eclipse转投到了Android Studio的怀抱中,从最初的测试版本一路升级到现在的1.0正式版本(今天发布了1.1,果断已经升级了),关于Android Studio的好处我就不用说了,下面两点就足矣让你转投Android Studio了:</p>
<ul>
<li>Android Studio是Google官方指定的,目前官网已经去掉了ADT, 大家可以在<a href="http://developer.android.com/sdk/installing/index.html" target="_blank" rel="external">Android开发者官网</a> 中进行查看,目前只有Android Studio提供下载了.</li>
<li>Google也表示ADT不再进行维护了.<br>转投Android Studio时大势所趋,网上关于如何使用Android Studio的帖子也是满天飞,所以我就不再啰嗦夸奖Android Studio了.看一下下面的图,估计你就会很有欲望了.想查看详细的内容,可以查看<a href="http://developer.android.com/tools/studio/index.html" target="_blank" rel="external">Android Studio官方文档</a></li>
</ul>
<p><img src="/images/view-android-source-code-with-androidstudio/androidstudio.png" alt="Android Studio Preview"></p>
<a id="more"></a>
<h2 id="Android_5-0_:_Lollipop">Android 5.0 : Lollipop</h2><p>Android Lollipop是Google在今年推出的,关于Lollipop的详细介绍可以查看<a href="\&quot;http://developer.android.com/about/versions/lollipop.html\&quot;">Lollipop官方介绍</a> ,我也就不多说了.作为一个开发者,我们不应该停留在表面(即Lollipop的绚丽的界面,和新奇的设计语言<a href="\&quot;http://developer.android.com/about/versions/lollipop.html#Material\&quot;">Material design</a>),我们更要了解其中的原理.</p>
<h2 id="准备工作">准备工作</h2><p>在使用Android Studio查看源码之前,你需要做下面几件事:</p>
<ul>
<li>下载Android Lollipop源码(当然不一定非要是Lollipop源码,其他的版本也是可以的)</li>
<li>进行过一次完整编译(不编译是无法进行源码导入工作的)<br>以上操作可以参考<a href="https://source.android.com/source/initializing.html" target="_blank" rel="external">Google 官方教程</a> 以确保万无一失(呵呵).上面的几个链接需要翻墙才可以访问,不过有兴趣看这篇文章的人,大部分应该都是知道VPN的.或者没有VPN不会翻墙的,速度去卖一个VPN,能花钱解决的事情,就不要花时间.</li>
</ul>
<h2 id="开始">开始</h2><ul>
<li>进入Android 源码根目录</li>
<li>执行<br><code>mmm development/tools/idegen/</code><br>这行命令的意思是编译idegen这个项目,生成idegen.jar文件.生成成功后,会显示这个jar包的位置,并显示<br><code>make completed successfully (43 seconds)</code> ,如果编译失败了,后面会讲到这种情况(比较少见)</li>
<li>执行<br><code>sh ./development/tools/idegen/idegen.sh</code><br>这行命令的意思是生成对应的文件:android.iws, android.ipr, android.iml .如果生成失败,后面也会讲到这种情况.</li>
<li>生成对应的文件后,打开Android Studio,选择打开一个现有的Android Studio项目,选择Android源码的根目录,导入即可(起作用的是android.irp文件).在配置sdk版本之后就可以查看Android 源码了.</li>
<li>已经完成了,没有下一步了.</li>
</ul>
<h2 id="问题">问题</h2><ul>
<li><p>执行第一个命令的时候编译不过,出现这种情况的原因有好几种:</p>
<ul>
<li>Android 源码没有下载完全</li>
<li>没有进行全部编译</li>
<li>环境变量配置有问题解决方法依问题而定,网上对应的帖子很多,可以自己去找. 推荐这种问题还是去<a href="\&quot;http://www.jianshu.com/p/www.google.com\&quot;">Google</a> 和<a href="\&quot;http://www.jianshu.com/p/www.stackoverflow.com\&quot;">StackOverFlow</a> 上去问.</li>
</ul>
</li>
<li><p>执行第二个命令的时候,碰到下面的问题:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread \<span class="string">"main\" java.io.FileNotFoundException: ./out/target/product/hammerhead/obj/GYP/shared_intermediates/res.java (Is a directory)</span><br><span class="line"></span>at java.io.FileInputStream.<span class="keyword">open</span>(Native Method)</span><br><span class="line">at java.io.FileInputStream.&amp;<span class="keyword">lt</span>;init&amp;gt;(FileInputStream.jav<span class="variable">a:138</span>)</span><br><span class="line">at java.io.FileReader.&amp;<span class="keyword">lt</span>;init&amp;gt;(FileReader.jav<span class="variable">a:72</span>)</span><br><span class="line">at Configuration.parsePackageName(Configuration.jav<span class="variable">a:204</span>)</span><br><span class="line">at Configuration.rootOf(Configuration.jav<span class="variable">a:180</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:140</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.&amp;<span class="keyword">lt</span>;init&amp;gt;(Configuration.jav<span class="variable">a:72</span>)</span><br><span class="line">at Main.main(Main.jav<span class="variable">a:37</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>解决办法是将<br><code>./out/target/product/hammerhead/obj/GYP/shared_intermediates/res.java</code><br>修改为:<br><code>./out/target/product/hammerhead/obj/GYP/shared_intermediates/res.j</code><br>即可.</p>
<h2 id="后记">后记</h2><p>使用Android Studio看Android源码很爽，下面是他们的优缺点：</p>
<h4 id="优点">优点</h4><ul>
<li>和Android 完美结合</li>
<li>代码提示很全</li>
<li>代码跳转很强</li>
<li>IDE比Eclipse好看(我说的是黑色主题)</li>
<li>插件很强大(底层是IDEA你懂得)</li>
<li>免费(SourceInsight负分,啥?你用的破解版? 当我没说)</li>
</ul>
<h4 id="缺点">缺点</h4><ul>
<li>对C＋＋代码的支持不是很好</li>
<li>有一定的上手难度</li>
</ul>
<p>本文简书地址：<a href="http://www.jianshu.com/p/c85984cf99e2" target="_blank" rel="external">http://www.jianshu.com/p/c85984cf99e2 </a>欢迎大家点喜欢</p>
<blockquote>
<p>作者：<a href="http://weibo.com/1315612820/profile?topnav=1&amp;wvr=6" target="_blank" rel="external">Gracker</a></p>
<p>出处：<a href="http://androidperformance.com/2015/01/16/view-android-source-code-with-androidstudio/" target="_blank" rel="external">androidperformance.com</a></p>
<p>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
<p>打赏一下： <a href="http://weibo.com/p/1001603801588257955883?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod" target="_blank" rel="external">微博打赏</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Android_Studio">Android Studio</h2><p>作为Google的亲儿子,Nexus手机系列所收到的待遇大家有目共睹.Android5.0出来之后,Nexus5第一时间就升级到了最新的系统.那么作为Google亲儿子的Android Studio同样备受Google的重视,我也是第一时间从Eclipse转投到了Android Studio的怀抱中,从最初的测试版本一路升级到现在的1.0正式版本(今天发布了1.1,果断已经升级了),关于Android Studio的好处我就不用说了,下面两点就足矣让你转投Android Studio了:</p>
<ul>
<li>Android Studio是Google官方指定的,目前官网已经去掉了ADT, 大家可以在<a href="http://developer.android.com/sdk/installing/index.html">Android开发者官网</a> 中进行查看,目前只有Android Studio提供下载了.</li>
<li>Google也表示ADT不再进行维护了.<br>转投Android Studio时大势所趋,网上关于如何使用Android Studio的帖子也是满天飞,所以我就不再啰嗦夸奖Android Studio了.看一下下面的图,估计你就会很有欲望了.想查看详细的内容,可以查看<a href="http://developer.android.com/tools/studio/index.html">Android Studio官方文档</a></li>
</ul>
<p><img src="/images/view-android-source-code-with-androidstudio/androidstudio.png" alt="Android Studio Preview"></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之过渡绘制( 二)]]></title>
    <link href="http://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2/"/>
    <id>http://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2/</id>
    <published>2015-01-13T11:38:53.000Z</published>
    <updated>2015-04-02T08:06:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>上一篇<a href="http://www.androidperformance.com/android-performance-optimization-overdraw-1.html" target="_blank" rel="external">文章</a>从理论的角度讲解了一下什么是过渡绘制，以及可以用来查看和确认过渡绘制的工具，还提供了一些优化过渡绘制的方法。对代码和布局比较熟悉的人，看完上一篇其实就已经可以对自己的应用进行优化了。我记得有人说过，用iphone你只需要保证苹果有节操即可，用Android你就得保证所有的Android开发者都有节操。但现实是残酷的，现在Android市场上，有很多粗制滥造的应用，其中不乏大厂之作，各位打开过渡绘制按钮，就知道我所言非虚。作为一个Android开发人员，我肯定是更希望Android能一步一步好起来，超越iphone。</p>
<p>这篇文章从实战的角度，讲解了一个过渡绘制的优化过程。当然这里用到的只是很少的一部分，毕竟每个应用差别很大，优化方式也各不一样。所以这篇文章仅供参考，想把这块做好还是要下功夫的。</p>
<p>如果没有看过前一篇，可以点这里：<a href="http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/" target="_blank" rel="external">Android性能优化之过渡绘制(一)</a></p>
<hr>
<a id="more"></a>
<h2 id="定位过渡绘制区域">定位过渡绘制区域</h2><h3 id="打开GPU过渡绘制选项:">打开GPU过渡绘制选项:</h3><p>设置—辅助功能—开发人员工具—硬件加速渲染—调试GPU过渡绘制— 显示过渡绘制区域.</p>
<h3 id="清理后台">清理后台</h3><p>Kill掉(即清后台)要测试的应用,重新打开就可以看到效果.下面以文件管理器和设置为例子,如下图</p>
<p><img src="/images/overdraw-1/filemanager-1.png" alt="文件管理器"><img src="/images/overdraw-1/settings.png" alt="设置"></p>
<p>从图上可以看出,按照过渡绘制从好到坏(蓝-绿-粉红-红)来看,文件管理器的过渡绘制是非常严重的,而设置界面的过渡绘制则在可以接受的范围内.下面就以文件管理器为主要分析对象,来看看如何对文件管理器的过渡绘制进行优化.</p>
<h3 id="从文件管理器的图,分析出过渡绘制区域:-">从文件管理器的图,分析出过渡绘制区域:.</h3><ul>
<li>首先看最上面的ActionBar和最下面的SmartBar,对比设置界面的ActionBar就可以知道,整个文件管理器存在一个不透明的背景,导致每次绘制时,都要先绘制这个看不见且不透明的背景.这个背景一般是应用的主题自带的背景,所以GPU过渡绘制显示其位蓝色,这个背景是可以进行优化的.</li>
<li>中间的内容部分,最底层是绿色,说明进行了2x的过渡绘制,去掉第一条我们提的那个全局背景,还有一层背景,也就是1x的过渡绘制,对比setting可知,这个背景色也是可以去掉的.</li>
<li>最容易看出的是这两条,我们先分析和优化这两条,然后再进行其他的优化.</li>
</ul>
<h2 id="优化过渡绘制区域">优化过渡绘制区域</h2><p>在进行位置确认后，我们大概确定了过渡绘制的区域,让我们来使用工具来进行验证和View确认.</p>
<p>打开Monitor(Eclipse和Android Studio中都有快捷打开按钮,即DDMS,右上角选择 Hierarchy View,大概使用如图</p>
<p><img src="/images/overdraw-1/HierarchyView-1.png" alt="Hierarchy View"></p>
<p>其中根节点:PhoneWindos$DecorView是整个视图的根节点,唯一的子节点是ActionBarOverlayLayout,这个Layout包含了ActionBar,应用程序,以及SmartBar.</p>
<p>下面讲述如何从Hierarchy View结合代码分析出需要进行修改的区域</p>
<h3 id="去除默认背景">去除默认背景</h3><p>上面分析过渡绘制区域的第一条,整个window存在一个背景,所以进行了一次重绘,这个背景的重绘是系统级别的,和主题有关,即这个背景是属于ActionBarOverlayLayout的.这种类型的过渡绘制解决也比较方便,在文件管理器的主Activity的onCreate方法中,加入</p>
<p><code>this.getWindow().setBackgroundDrawableResource(android.R.color.transparent);</code></p>
<p>就可以将这个看不见的主题背景去掉.下面是去掉主题背景后的效果图(一张是划开,一张是没有划开):</p>
<p><img src="/images/overdraw-1/filemanager-2.png" alt="文件管理器"><img src="/images/overdraw-1/filemanager-3.png" alt="文件管理器"></p>
<p>对比优化前的图可以发现,背景被去掉之后,少了一层过渡绘制. ActionBar上的蓝色已经消失了.中间的内容由绿色变为蓝色</p>
<h3 id="消除子控件背景">消除子控件背景</h3><p>上面分析的第二条说”<strong>中间的内容部分,最底层是绿色,说明进行了2x的过渡绘制</strong>”,现在中间部分变成了蓝色,但是这是一个全局的背景,导致右边的view拉过来之后,还是存在大量的红色和绿色. 继续分析Hierarchy View,找到中间view对应的视图:DragRelativeLayout,查看源码可知,DragRelativeLayout继承自公共控件:SlidingMenu ，SlidingMenu 由CustomViewAbove和CustomViewBehind组成,前者是上面可以左右拉动的那部分,后者是底部不能拉动的那部分(这个从HierarchyView中也可以看出来:如下图所示:</p>
<p><img src="/images/overdraw-1/HierarchyView-2.png" alt="Hierarchy View"></p>
<p>点击CustomViewBehind,查看其所占的区域,就可以发现背景是这个View进行绘制的,打开CustomViewBehind的代码可以发现其构造函数中包含下面的代码:<br><code>setBackgroundColor(getResources().getColor(R.color.mz_slidingmenu_background_light));</code><br>这个背景是不需要的,查看源码可知,这个view会在SlidingMenu.setMenu的时候,被覆盖掉,还是看不到的.所以这一层view是可以去掉的.下面是去掉一层背景之后的预览图:</p>
<p><img src="/images/overdraw-1/filemanager-4.png" alt="文件管理器"><img src="/images/overdraw-1/filemanager-5.png" alt="文件管理器"></p>
<p>可以看到这一层背景去掉之后,过渡绘制减轻了很多.</p>
<h3 id="进一步优化">进一步优化</h3><p>接着进行分析,可以看到CustomViewAbove也是存在一个过渡绘制的背景的,查看Hierarchy View的CustomViewAbove的子节点,可以看到过渡绘制是由ListView导致的.其id为:FilesList,在代码中找到它,并对他进行分析.在我将PartitionItemLayout中onDraw()函数的setBounds去掉之后,过渡绘制进一步改善了(但是ListItem的View的颜色也比之前要浅了,这一步优化需要根据具体情况进行) 下面是优化后的效果图:</p>
<p><img src="/images/overdraw-1/filemanager-6.png" alt="文件管理器"><img src="/images/overdraw-1/filemanager-7.png" alt="文件管理器"></p>
<p>可以看到图中的过渡绘制已经非常少了.!点个赞!</p>
<hr>
<h2 id="优化代码">优化代码</h2><h3 id="Lint工具">Lint工具</h3><p>Lint工具的使用比较简单,根据给出的提示做对应的修改即可.有时候需要工具具体情况来确定是否需要修改. 下图是一个简单地例子.箭头处提示这个Layout或者它的父Layout是不必须的.具体修改方法即去掉FrameLayout,将RelativeLayout提升为根VIew即可.</p>
<p><img src="/images/overdraw-1/lint-1.png" alt="Lint"></p>
<p>Lint工具还会针对代码中潜在的不合理或者Bed Code做出修改意见.比较重要的提示包括</p>
<ul>
<li>声明但是没有使用的变量</li>
<li>可能会产生的空指针</li>
<li>没必要书写的return,continue</li>
<li>复杂代码的简化写法</li>
<li>for循环的简化写法:foreach</li>
<li>无效的判空</li>
<li>空if</li>
<li>无效或者未使用的import</li>
</ul>
<h3 id="使用Tracer_For_OpenGL_ES">使用Tracer For OpenGL ES</h3><p>Tracer工具也在Android Device Monitor中.点击右上角的Tracer for OpenGL ES按钮就可以进入(如果没有这个按钮,点击旁边的Open Perspective按钮,从选项中选择Tracer for OpenGL ES即可).初次打开Tracer工具,里面是没有内容的,点击右上角的两个按钮(一个是打开现有的GLTrace文件,另一个是新建GLTrace文件)。点击Trace按钮, 手机会自动启动应用程序并启动对应的Activity,当手机上的内容完全绘制出来之后,就可以点击Stop按钮,生成GlTrace文件.文件会自动打开.</p>
<p><img src="/images/overdraw-1/Tracer-1.png" alt="Tracer"></p>
<p>分析GLTrace文件，下图是优化过后的图,对比优化前的图可以发现,优化后不会去绘制默认的背景图和CustomViewBehind的背景图.</p>
<p><img src="/images/overdraw-1/Tracer-2.png" alt="Tracer"></p>
<p>这只是一帧的绘制,如果多操作几下生成多个帧的绘制trace文件,会发现这两个背景会被多次的重绘,去掉后不仅会减轻过渡绘制,也会加快GUP的绘制速度.</p>
<hr>
<h2 id="参考资料">参考资料</h2><ol>
<li><a href="http://www.curious-creature.org/2012/12/01/android-performance-case-study/" target="_blank" rel="external">优化过程</a></li>
<li><a href="http://blog.csdn.net/yihongyuelan/article/details/12169647" target="_blank" rel="external">反编译并添加gpu显示</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/reusing-layouts.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/reusing-layouts.html </a></li>
<li><a href="http://developer.android.com/training/improving-layouts/loading-ondemand.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/loading-ondemand.html</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/smooth-scrolling.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/smooth-scrolling.html </a></li>
<li><a href="http://developer.android.com/tools/help/hierarchy-viewer.html" target="_blank" rel="external">http://developer.android.com/tools/help/hierarchy-viewer.html</a></li>
<li><a href="http://tools.android.com/tips/lint" target="_blank" rel="external">http://tools.android.com/tips/lint</a></li>
</ol>
<hr>
<blockquote>
<p>作者：<a href="http://weibo.com/1315612820/profile?topnav=1&amp;wvr=6" target="_blank" rel="external">Gracker</a></p>
<p>出处：<a href="http://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2/" target="_blank" rel="external">androidperformance.com</a></p>
<p>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
<p>打赏一下： <a href="http://weibo.com/p/1001603801588257955883?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod" target="_blank" rel="external">微博打赏</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>上一篇<a href="http://www.androidperformance.com/android-performance-optimization-overdraw-1.html">文章</a>从理论的角度讲解了一下什么是过渡绘制，以及可以用来查看和确认过渡绘制的工具，还提供了一些优化过渡绘制的方法。对代码和布局比较熟悉的人，看完上一篇其实就已经可以对自己的应用进行优化了。我记得有人说过，用iphone你只需要保证苹果有节操即可，用Android你就得保证所有的Android开发者都有节操。但现实是残酷的，现在Android市场上，有很多粗制滥造的应用，其中不乏大厂之作，各位打开过渡绘制按钮，就知道我所言非虚。作为一个Android开发人员，我肯定是更希望Android能一步一步好起来，超越iphone。</p>
<p>这篇文章从实战的角度，讲解了一个过渡绘制的优化过程。当然这里用到的只是很少的一部分，毕竟每个应用差别很大，优化方式也各不一样。所以这篇文章仅供参考，想把这块做好还是要下功夫的。</p>
<p>如果没有看过前一篇，可以点这里：<a href="http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/">Android性能优化之过渡绘制(一)</a></p>
<hr>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之过渡绘制(一)]]></title>
    <link href="http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/"/>
    <id>http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/</id>
    <published>2014-10-20T15:19:23.000Z</published>
    <updated>2015-04-02T02:29:23.000Z</updated>
    <content type="html"><![CDATA[<p>博客有一段时间没有更新了，到了新公司后，一直比较忙，博客也更新地不那么频繁了，倒是利用这个VPS搭建的VPN每天都在用，速度也蛮不错的。最近一直在看Android上和性能相关的部分，也就是所谓的Android性能优化，才发现Android性能这一块，自己懂得还是太少了，所以从上层开始看，也算是一点一点入门吧。这个系列将讲解学习过程中总结的和性能相关的内容。</p>
<p>首先将讲解一下GPU过渡绘制，也是开发者最直接接触的部分吧，这个内容将分为两个部分来将讲，第一部分初步讲解一下gpu过渡绘制的原理，和一些优化建议，第二部分将用实际例子来讲解优化GPU过渡绘制的一般步骤。</p>
<h2 id="过渡绘制概念">过渡绘制概念</h2><p>GPU过渡绘制的概念：GPU过度绘制指的是在屏幕一个像素上绘制多次(超过一次),比如一个TextView后有背景，那么显示文本的像素至少绘了两次，一次是背景，一次是文本。GPU过度绘制或多或少对性能有些影响,设备的内存带宽是有限的，当过度绘制导致应用需要更多的带宽(超过了可用带宽)的时候性能就会降低。带宽的限制每个设备都可能是不一样的。</p>
<a id="more"></a>
<h2 id="过渡绘制的原因">过渡绘制的原因</h2><ol>
<li>太多的View叠加</li>
<li>复杂的层级叠加</li>
<li>更长的inflation时间</li>
</ol>
<h2 id="过渡绘制和不合理的xml布局的影响">过渡绘制和不合理的xml布局的影响</h2><ol>
<li>布局文件是一个xml文件，inflate布局文件其实就是解析xml，根据标签信息创建相应的布局对象并做关联。xml中的标签和属性设置越多，节点树的深度越深，在解析时要执行的判断逻辑、函数的嵌套和递归就越多，所以时间消耗越多；</li>
<li>inflate操作只是布局影响的第一个环节，一个界面要显示出来，在requestLayout后还要执行一系列的measure、layout、draw的操作，每一步的执行时间都会受到布局本身的影响。而界面的最终显示是所有这些操作完成后才实现的，所以如果布局质量差，会增加每一步操作的时间成本，最终显示时间就会比较长。</li>
</ol>
<h2 id="过渡绘制的一些基本概念:">过渡绘制的一些基本概念:</h2><p>Android提供了三个工具来帮助辨别和解决重绘问题：Hierachy Viewer，Tracer for OpenGL和Show GPU overdraw。前两个可以在ADT工具或者独立的monitor工具中找到，最后一个是在开发者选项的一部分.</p>
<ol>
<li>GPU过渡绘制测试:对于过度绘制的测试主要通过人工进行测试，也是发现应用过渡绘制的首选途径 .通过打开开发者选项中的 显示GPU过度绘制(魅族手机:设置—辅助功能—开发人员工具—硬件加速渲染—调试GPU过渡绘制— 显示过渡绘制区域. (魅族手机需要打开开发者模式：需要在电话界面输入: <em>#</em>#6961#<em>#</em> )) 来进行测试（PS：只有android4.2及以上的版本才具备此功能)</li>
<li>颜色标识: GPU过渡绘制从好到差:蓝-绿-淡红-红<ul>
<li>蓝色1x过度绘制</li>
<li>绿色2x过度绘制</li>
<li>淡红色3x过度绘制</li>
<li>红色超过4x过度绘制</li>
</ul>
</li>
<li>验收标准:<ul>
<li>控制过度绘制为2x</li>
<li>不允许存在4x过度绘制</li>
<li>不允许存在面积超过屏幕1/4区域的3x过度绘制（淡红色区域）</li>
</ul>
</li>
</ol>
<h2 id="优化工具介绍">优化工具介绍</h2><ol>
<li>Lint工具:<ul>
<li>Eclipse中,点击即可,下面的窗口中会出现提示,根据提示和具体解决办法消除.</li>
<li>Android Studio自带Lint工具,不合理或者需要优化和注意的地方,会用黄色标记出来.</li>
<li>Lint工具不仅对布局有很好的优化建议,对代码中不合理的活着存在潜在风险的模块也会提出优化建议,所以一个好的建议是:多使用Lint工具检查自己的应用,尽量消除所有的建议.</li>
<li>Lint工具可以用命令行来运行,具体使用可以参考:<a href="tools.android.com">tools.android.com</a><br><img src="/images/overdraw-1/lint.png" alt="Lint"></li>
</ul>
</li>
<li><p>Lint工具的提升例子(摘自官方文档):</p>
<ul>
<li>Use compound drawables(使用compound drawables) - A LinearLayout which contains an ImageView and a TextView can be more efficiently handled as a compound drawable.</li>
<li>Merge root frame(使用Merge根框架) - If a FrameLayout is the root of a layout and does not provide background or padding etc, it can be replaced with a merge tag which is slightly more efficient.</li>
<li>Useless leaf(去除无用的分支) - A layout that has no children or no background can often be removed (since it is invisible) for a flatter and more efficient layout hierarchy.</li>
<li>Useless parent (去除无用的父控件)- A layout with children that has no siblings, is not a ScrollView or a root layout, and does not have a background, can be removed and have its children moved directly into the parent for a flatter and more efficient layout hierarchy.</li>
<li>Deep layouts (注意Layout的深度) - Layouts with too much nesting are bad for performance. Consider using flatter layouts such as RelativeLayout or GridLayout to improve performance. The default maximum depth is</li>
</ul>
</li>
<li><p>Hierarchy Viewer:此工具是一个ADT工具（或者monitor,最新版本的SDK建议不使用独立的HV工具,而是直接在monitor中进行操作.）的一部分，可以被用作对视图层级进行快速解读。在处理布局问题时特别有用，对于性能问题也很适用。Hierarchy Viewer默认只能在非加密设备使用，例如工程机，工程平板或者模拟器。为了能够在任何手机上使用Hierarchy Viewer，你得在你的应用中添加ViewServer，这是一个开源库,使用方法可以参考这里。连接上设备，打开Hierarchy Viewer(定位到tools/目录下，直接执行hierarchyviewer的命令，选定需要查看的Process，再点击Load View Hierarchy会显示出当前界面的布局Tree。在每个模块的Traffic light上有三个灯，分别代表了Measure, Layout and Draw三个步骤的性能。</p>
</li>
</ol>
<h2 id="布局优化建议">布局优化建议</h2><p>在Android UI布局过程中，通过遵守一些惯用、有效的布局原则，我们可以制作出高效且复用性高的UI，概括来说包括如下几点：</p>
<ul>
<li><p>尽量多使用RelativeLayout和LinearLayout, 不要使用绝对布局AbsoluteLayout，</p>
<ul>
<li>在布局层次一样的情况下， 建议使用LinearLayout代替RelativeLayout, 因为LinearLayout性能要稍高一点.</li>
<li>在完成相对较复杂的布局时,建议使用RelativeLayout,RelativeLayout可以简单实现LinearLayout嵌套才能实现的布局.</li>
</ul>
</li>
<li><p>将可复用的组件抽取出来并通过include标签使用；</p>
</li>
<li>使用ViewStub标签来加载一些不常用的布局；</li>
<li>动态地inflation view性能要比SetVisiblity性能要好.当然用VIewStub是最好的选择.</li>
<li>使用merge标签减少布局的嵌套层次</li>
<li><p>去掉多余的背景颜色(查看背景颜色是否多余,可以将HierarchyView中的图导出为psd文件,然后用Photoshop查看.具体可以参考这个<a href="https://www.youtube.com/watch?v=URyoiAt8098" target="_blank" rel="external">视频</a>)</p>
<ul>
<li>对于有多层背景颜色的Layout来说,留最上面一层的颜色即可,其他底层的颜色都可以去掉</li>
<li>对于使用Selector当背景的Layout(比如ListView的Item,会使用Selector来标记点击,选择等不同的状态),可以将normal状态的color设置为\”@android:color/transparent”,来解决对应的问题</li>
</ul>
</li>
<li><p>内嵌使用包含layout_weight属性的LinearLayout会在绘制时花费昂贵的系统资源，因为每一个子组件都需要被测量两次。在使用ListView与GridView的时候，这个问题显的尤其重要，因为子组件会重复被创建.所以要尽量避免使用Layout_weight</p>
</li>
<li>使得Layout宽而浅，而不是窄而深（在Hierarchy Viewer的Tree视图里面体现）</li>
</ul>
<h2 id="源码相关">源码相关</h2><p>另外有能力看源码的同学，下面是绘制OverDraw的源码位置：/frameworks/base/libs/hwui/OpenGLRenderer.cpp,有兴趣的可以去研究研究。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> OpenGLRenderer<span class="tag">::renderOverdraw</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCaches<span class="built_in">.</span>debugOverdraw <span class="subst">&amp;</span>amp;<span class="subst">&amp;</span>amp; getTargetFbo() <span class="subst">==</span> <span class="number">0</span>) &#123;</span><br><span class="line">        const Rect<span class="subst">*</span> clip <span class="subst">=</span> <span class="subst">&amp;</span>amp;mTilingClip;</span><br><span class="line"></span><br><span class="line">        mCaches<span class="built_in">.</span>enableScissor();</span><br><span class="line">        mCaches<span class="built_in">.</span>setScissor(clip<span class="subst">-&amp;</span><span class="literal">gt</span>;left, mFirstSnapshot<span class="subst">-&amp;</span><span class="literal">gt</span>;height <span class="subst">-</span> clip<span class="subst">-&amp;</span><span class="literal">gt</span>;bottom,</span><br><span class="line">                clip<span class="subst">-&amp;</span><span class="literal">gt</span>;right <span class="subst">-</span> clip<span class="subst">-&amp;</span><span class="literal">gt</span>;left, clip<span class="subst">-&amp;</span><span class="literal">gt</span>;bottom <span class="subst">-</span> clip<span class="subst">-&amp;</span><span class="literal">gt</span>;top);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1x overdraw</span></span><br><span class="line">        mCaches<span class="built_in">.</span>stencil<span class="built_in">.</span>enableDebugTest(<span class="number">2</span>);</span><br><span class="line">        drawColor(mCaches<span class="built_in">.</span>getOverdrawColor(<span class="number">1</span>), SkXfermode<span class="tag">::kSrcOver_Mode</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2x overdraw</span></span><br><span class="line">        mCaches<span class="built_in">.</span>stencil<span class="built_in">.</span>enableDebugTest(<span class="number">3</span>);</span><br><span class="line">        drawColor(mCaches<span class="built_in">.</span>getOverdrawColor(<span class="number">2</span>), SkXfermode<span class="tag">::kSrcOver_Mode</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3x overdraw</span></span><br><span class="line">        mCaches<span class="built_in">.</span>stencil<span class="built_in">.</span>enableDebugTest(<span class="number">4</span>);</span><br><span class="line">        drawColor(mCaches<span class="built_in">.</span>getOverdrawColor(<span class="number">3</span>), SkXfermode<span class="tag">::kSrcOver_Mode</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4x overdraw and higher</span></span><br><span class="line">        mCaches<span class="built_in">.</span>stencil<span class="built_in">.</span>enableDebugTest(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">        drawColor(mCaches<span class="built_in">.</span>getOverdrawColor(<span class="number">4</span>), SkXfermode<span class="tag">::kSrcOver_Mode</span>);</span><br><span class="line"></span><br><span class="line">        mCaches<span class="built_in">.</span>stencil<span class="built_in">.</span>disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="literal">void</span> OpenGLRenderer<span class="tag">::countOverdraw</span>() &#123;</span><br><span class="line">    size_t count <span class="subst">=</span> mWidth <span class="subst">*</span> mHeight;</span><br><span class="line">    uint32_t<span class="subst">*</span> buffer <span class="subst">=</span> <span class="literal">new</span> uint32_t<span class="preprocessor">[</span>count<span class="preprocessor">]</span><span class="markup">;</span><br><span class="line">    glReadPixels(0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, &amp;amp;buffer</span><span class="preprocessor">[</span><span class="number">0</span><span class="preprocessor">]</span><span class="markup">);</span><br><span class="line"></span><br><span class="line">    size_t total = 0;</span><br><span class="line">    for (size_t i = 0; i &amp;lt; count; i++) &#123;</span><br><span class="line">        total += buffer</span><span class="preprocessor">[</span>i<span class="preprocessor">]</span><span class="markup"> &amp;amp; 0xff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOverdraw = total / float(count);</span><br><span class="line"></span><br><span class="line">    delete</span><span class="preprocessor">[</span><span class="preprocessor">]</span><span class="markup"> buffer;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>还有QA可能用得到的一个指标：OverDraw数值，这个的源码位置在Framework/base/core/java/android/view/HardwareRender.java中(5.0中去掉了这个数值的显示)</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void debugOverdraw(View.AttachInfo attachInfo, Rect dirty,</span><br><span class="line">                HardwareCanvas canvas, DisplayList displayList) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">mDebugOverdraw =</span>= OVERDRAW_TYPE_COUNT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">mDebugOverdrawLayer =</span>= <span class="constant">null</span>) &#123;</span><br><span class="line">                    <span class="variable">mDebugOverdrawLayer =</span> createHardwareLayer(mWidth, mHeight, <span class="constant">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mDebugOverdrawLayer.getWidth() != mWidth ||</span><br><span class="line">                        mDebugOverdrawLayer.getHeight() != mHeight) &#123;</span><br><span class="line">                    mDebugOverdrawLayer.resize(mWidth, mHeight);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mDebugOverdrawLayer.isValid()) &#123;</span><br><span class="line">                    <span class="variable">mDebugOverdraw =</span> -<span class="number">1</span>;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                HardwareCanvas <span class="variable">layerCanvas =</span> mDebugOverdrawLayer.start(canvas, dirty);</span><br><span class="line">                countOverdraw(layerCanvas);</span><br><span class="line">                final int <span class="variable">restoreCount =</span> layerCanvas.save();</span><br><span class="line">                layerCanvas.drawDisplayList(displayList, <span class="constant">null</span>, DisplayList.FLAG_CLIP_CHILDREN);</span><br><span class="line">                layerCanvas.restoreToCount(restoreCount);</span><br><span class="line">                mDebugOverdrawLayer.end(canvas);</span><br><span class="line"></span><br><span class="line">                float <span class="variable">overdraw =</span> getOverdraw(layerCanvas);</span><br><span class="line">                DisplayMetrics <span class="variable">metrics =</span> attachInfo.mRootView.getResources().getDisplayMetrics();</span><br><span class="line"></span><br><span class="line">                drawOverdrawCounter(canvas, overdraw, metrics.density);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void drawOverdrawCounter(HardwareCanvas canvas, float overdraw, float density) &#123;</span><br><span class="line">            final String <span class="variable">text =</span> String.format(\<span class="string">"%.2fx\"</span>, overdraw);</span><br><span class="line">            final Paint <span class="variable">paint =</span> setupPaint(density);</span><br><span class="line">            // HSBtoColor will clamp the values <span class="keyword">in</span> the <span class="number">0</span>..<span class="number">1</span> range</span><br><span class="line">            paint.setColor(Color.HSBtoColor(<span class="number">0.28</span>f - <span class="number">0.28</span>f * overdraw / <span class="number">3.5</span>f, <span class="number">0.8</span>f, <span class="number">1.0</span>f));</span><br><span class="line"></span><br><span class="line">            canvas.drawText(text, density * <span class="number">4.0</span>f, mHeight - paint.getFontMetrics().bottom, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文章">参考文章</h2><ol>
<li><a href="http://www.curious-creature.org/2012/12/01/android-performance-case-study/" target="_blank" rel="external">优化过程</a></li>
<li><a href="http://blog.csdn.net/yihongyuelan/article/details/12169647" target="_blank" rel="external">反编译并添加gpu显示</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/reusing-layouts.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/reusing-layouts.html </a></li>
<li><a href="http://developer.android.com/training/improving-layouts/loading-ondemand.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/loading-ondemand.html</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/smooth-scrolling.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/smooth-scrolling.html </a></li>
<li><a href="http://developer.android.com/tools/help/hierarchy-viewer.html" target="_blank" rel="external">http://developer.android.com/tools/help/hierarchy-viewer.html</a></li>
<li><a href="http://tools.android.com/tips/lint" target="_blank" rel="external">http://tools.android.com/tips/lint</a></li>
</ol>
<hr>
<blockquote>
<p>作者：<a href="http://weibo.com/1315612820/profile?topnav=1&amp;wvr=6" target="_blank" rel="external">Gracker</a></p>
<p>出处：<a href="http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/" target="_blank" rel="external">androidperformance.com</a></p>
<p>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
<p>打赏一下： <a href="http://weibo.com/p/1001603801588257955883?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod" target="_blank" rel="external">微博打赏</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>博客有一段时间没有更新了，到了新公司后，一直比较忙，博客也更新地不那么频繁了，倒是利用这个VPS搭建的VPN每天都在用，速度也蛮不错的。最近一直在看Android上和性能相关的部分，也就是所谓的Android性能优化，才发现Android性能这一块，自己懂得还是太少了，所以从上层开始看，也算是一点一点入门吧。这个系列将讲解学习过程中总结的和性能相关的内容。</p>
<p>首先将讲解一下GPU过渡绘制，也是开发者最直接接触的部分吧，这个内容将分为两个部分来将讲，第一部分初步讲解一下gpu过渡绘制的原理，和一些优化建议，第二部分将用实际例子来讲解优化GPU过渡绘制的一般步骤。</p>
<h2 id="过渡绘制概念">过渡绘制概念</h2><p>GPU过渡绘制的概念：GPU过度绘制指的是在屏幕一个像素上绘制多次(超过一次),比如一个TextView后有背景，那么显示文本的像素至少绘了两次，一次是背景，一次是文本。GPU过度绘制或多或少对性能有些影响,设备的内存带宽是有限的，当过度绘制导致应用需要更多的带宽(超过了可用带宽)的时候性能就会降低。带宽的限制每个设备都可能是不一样的。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Android小技巧]:如何让EditText不自动获取焦点]]></title>
    <link href="http://androidperformance.com/2014/06/03/android-edittext-do-not-auto-get-focus/"/>
    <id>http://androidperformance.com/2014/06/03/android-edittext-do-not-auto-get-focus/</id>
    <published>2014-06-02T16:31:49.000Z</published>
    <updated>2015-03-27T05:26:19.000Z</updated>
    <content type="html"><![CDATA[<p>Android中,使用EditText作为输入框很方便,但是有时候EditText会自动获取焦点,其行为:点击进入这个页面后,EditText自动获取焦点,导致软键盘直接跳出.有时候这么做很方便,但是大部分时候我们还是希望在点击EditText的时候,软键盘才弹出来.</p>
<p>这里有个很简单也很实用的技巧,即在EditText的父Layout中,加入下面的两个属性即可:</p>
<p><pre class="lang:java decode:true ">android:focusable=”true”<br>android:focusableInTouchMode=”true”</pre><br>这样做的原理是让用户进入到这个页面之后,EditText的父控件 获取焦点,这样的话EditText就获取不到焦点,软键盘也不会自动弹起.只有在点击EditText的时候,软键盘才会弹起.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android中,使用EditText作为输入框很方便,但是有时候EditText会自动获取焦点,其行为:点击进入这个页面后,EditText自动获取焦点,导致软键盘直接跳出.有时候这么做很方便,但是大部分时候我们还是希望在点击EditText的时候,软键盘才弹出来.</p]]>
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Frame animation模拟脉搏跳动小动画]]></title>
    <link href="http://androidperformance.com/2014/06/01/android-frame-animation/"/>
    <id>http://androidperformance.com/2014/06/01/android-frame-animation/</id>
    <published>2014-06-01T10:07:18.000Z</published>
    <updated>2015-03-27T05:26:33.000Z</updated>
    <content type="html"><![CDATA[<p>逐帧动画是一种常见的动画形式（Frame By Frame），其原理是在“连续的关键帧”中分解动画动作，也就是在时间轴的每帧上逐帧绘制不同的内容，使其连续播放而成动画。 因为逐帧动画的帧序列内容不一样，不但给制作增加了负担而且最终输出的文件量也很大，但它的优势也很明显：逐帧动画具有非常大的灵活性，几乎可以表现任何想表现的内容，而它类似与电影的播放模式，很适合于表演细腻的动画。例如：人物或动物急剧转身、 头发及衣服的飘动、走路、说话以及精致的3D效果等等。</p>
<p>Android中的逐帧动画是Frame animation。<span style="\"color:" #000000;\"="">Frame animation可以被定义在XML文件中，也可以完全编码实现。3.0以前，android支持两种动画模式，tween animation,frame animation，在android3.0中又引入了一个新的动画系统：property animation，这三种动画模式在SDK中被称为property animation,view animation,drawable animation。 </span></p>
<a id="more"></a>
<p>本篇使用的方法是在xml中定义效果，以下是想达到的动画的效果。</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>1.首先准备所需图片（逐帧）。</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>2.在res/anim下或res/rawable下新建xml来编写动画效果。内容类似下图：</p>
<pre class="\"lang:java" decode:true\"="">&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"
    android:oneshot=\"false\"&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00040\" android:duration=\"100\" /&gt;//duration是每帧图片的时长，单位ms
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00041\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00042\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00043\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00044\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00045\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00046\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00047\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00048\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00049\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00050\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00051\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00052\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00053\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00054\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00055\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00056\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00057\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00058\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00059\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00060\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00061\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00062\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00063\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00064\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00065\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00066\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00067\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00068\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00069\" android:duration=\"100\" /&gt;
&lt;/animation-list&gt;</pre>

<p>xml保存为scanning_anim.xml.其中,</p>
<pre class="\"lang:java" decode:true\"="">animation-list//最外层是animition-list控件，可以容纳item，每个item是一帧图片。</pre>

<pre class="\"lang:java" decode:true\"="">android:oneshot=\"false\"<span style="\"color:" #000000;\"="">//如果为true，表示动画只播放一次停止在最后一帧上，如果设置为false表示动画循环播放。</span></pre>

<p>3.以上xml中定义的动画要以一个imageView作为载体来显示。以下例子用一个类稍稍封装：</p>
<pre class="\"lang:java" decode:true\"="">public class ScanningAnimationView extends ImageView {
    AnimationDrawable scanningDrawable;
    public ScanningAnimationView(Context context) {
        super(context);
    }
    public ScanningAnimationView(Context context, AttributeSet attrs) {
        super(context, attrs);
        setBackgroundResource(R.anim.scanning_anim);
        scanningDrawable=(AnimationDrawable)this.getBackground();
    }

    public void start() {
        scanningDrawable.start();
    }
    public void stop() {
        scanningDrawable.stop();
    }
}</pre>

<p>4.用户直接使用这个封装好的ImageView调用start和stop即可。</p>
<p>调用动画：</p>
<pre class="\"lang:java" decode:true\"="">public class MainActivity extends ActionBarActivity {
    ScanningAnimationView image;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        image = (ScanningAnimationView)findViewById(R.id.imageView);
        Button startButton = (Button) findViewById(R.id.start);
        Button endButton = (Button)findViewById(R.id.end);
        startButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                image.start();
            }
        });

        endButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                image.stop();
            }
        });
    }
</pre>

<p>imageView的布局：</p>
<pre class="\"lang:java" decode:true\"="">&lt;com.example.nurse.app.util.ScanningAnimationView
    android:layout_width=\"wrap_content\"
    android:layout_height=\"wrap_content\"
    android:id=\"@+id/imageView\"
    android:layout_centerHorizontal=\"true\"
    android:layout_alignParentTop=\"true\"
    android:layout_alignParentStart=\"true\"/&gt;</pre>

<p>本篇完。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>逐帧动画是一种常见的动画形式（Frame By Frame），其原理是在“连续的关键帧”中分解动画动作，也就是在时间轴的每帧上逐帧绘制不同的内容，使其连续播放而成动画。 因为逐帧动画的帧序列内容不一样，不但给制作增加了负担而且最终输出的文件量也很大，但它的优势也很明显：逐帧动画具有非常大的灵活性，几乎可以表现任何想表现的内容，而它类似与电影的播放模式，很适合于表演细腻的动画。例如：人物或动物急剧转身、 头发及衣服的飘动、走路、说话以及精致的3D效果等等。</p>
<p>Android中的逐帧动画是Frame animation。<span style=\"color: #000000;\">Frame animation可以被定义在XML文件中，也可以完全编码实现。3.0以前，android支持两种动画模式，tween animation,frame animation，在android3.0中又引入了一个新的动画系统：property animation，这三种动画模式在SDK中被称为property animation,view animation,drawable animation。 </span></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(2)]]></title>
    <link href="http://androidperformance.com/2014/05/31/android-tips-round-up-2/"/>
    <id>http://androidperformance.com/2014/05/31/android-tips-round-up-2/</id>
    <published>2014-05-31T10:20:47.000Z</published>
    <updated>2015-03-27T05:35:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第二篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/text/format/DateUtils.html#formatDateTime%28android.content.Context,%20long,%20int%29" target="_blank" rel="external">DateUtils.formatDateTime()</a> 用来进行区域格式化工作,输出格式化和本地化的时间或者日期.</p>
<a id="more"></a>
<p><a href="http://developer.android.com/reference/android/app/AlarmManager.html#setInexactRepeating(int, long, long, android.app.PendingIntent" target="_blank" rel="external">AlarmManager.setInexactRepeating</a>) 通过闹铃分组的方式省电,即使你只调用了一个闹钟,这也是一个好的选择,（可以确保在使用完毕时自动调用 AlarmManager.cancel ()。原文说的比较抽象,这里详细说一下:setInexactRepeating指的是设置非准确闹钟,使用方法:alarmManager.setInexactRepeating(AlarmManager.RTC, startTime,intervalL, pendingIntent),非准确闹钟只能保证大致的时间间隔，但是不一定准确，可能出现设置间隔为30分钟，但是实际上一次间隔20分钟，另一次间隔40分钟。它的最大的好处是可以合并闹钟事件，比如间隔设置每30分钟一次，不唤醒休眠，在休眠8小时后已经积累了16个闹钟事件，而在手机被唤醒的时候，非准时闹钟可以把16个事件合并为一个, 所以这么看来,非准时闹钟一般来说比较节约能源.</p>
<p><a href="http://developer.android.com/reference/android/text/format/Formatter.html#formatFileSize(android.content.Context, long" target="_blank" rel="external">Formatter.formatFileSize()</a>) 一个区域化的文件大小格式化工具。通俗来说就是把大小转换为MB,G,KB之类的字符串.</p>
<p><a href="http://developer.android.com/reference/android/app/ActionBar.html#hide(" target="_blank" rel="external">ActionBar.hide()</a>)/<a href="http://developer.android.com/reference/android/app/ActionBar.html#show(" target="_blank" rel="external">.show()</a>) 顾名思义,隐藏和显示ActionBar,可以优雅地在全屏和带Actionbar之间转换.</p>
<p><a href="http://developer.android.com/reference/android/text/util/Linkify.html#addLinks(android.text.Spannable, int" target="_blank" rel="external">Linkify.addLinks()</a>)  在Text上添加链接.很实用.</p>
<p><a href="http://developer.android.com/reference/android/text/StaticLayout.html" target="_blank" rel="external">StaticLayout</a> 在自定义 View 中渲染文字的时候很实用。</p>
<p><a href="http://developer.android.com/reference/android/app/Activity.html#onBackPressed(" target="_blank" rel="external">Activity.onBackPressed()</a>) 很方便的管理back键的方法,有时候需要自己控制返回键的事件的时候,可以重写一下.比如加入 “点两下back键退出” 功能.</p>
<p><a href="http://developer.android.com/reference/android/view/GestureDetector.html" target="_blank" rel="external">GestureDetector</a> 用来监听和相应对应的手势事件,比如点击,长按,慢滑动,快滑动,用起来很简单,比你自己实现要方便许多.</p>
<p><a href="http://developer.android.com/reference/android/graphics/DrawFilter.html" target="_blank" rel="external">DrawFilter</a> 可以让你在不调用onDrew方法的情况下,操作canvas,比了个如,你可以在创建自定义 View 的时候设置一个 DrawFilter，给父 View 里面的所有 View 设置反别名。</p>
<p><a href="http://developer.android.com/reference/android/app/ActivityManager.html#getMemoryClass(" target="_blank" rel="external">ActivityManager.getMemoryClass()</a>) 告诉你你的机器还有多少内存,在计算缓存大小的时候会比较有用.</p>
<p><a href="http://developer.android.com/reference/android/view/ViewStub.html" target="_blank" rel="external">ViewStub</a> 它是一个初始化不做任何事情的 View，但是之后可以载入一个布局文件。在慢加载 View 中很适合做占位符。唯一的缺点就是不支持标签，所以如果你不太小心的话，可能会在视图结构中加入不需要的嵌套。</p>
<p><a href="http://developer.android.com/reference/android/os/SystemClock.html#sleep(long" target="_blank" rel="external">SystemClock.sleep()</a>) 这个方法在保证一定时间的 sleep 时很方便，通常我用来进行 debug 和模拟网络延时。</p>
<p><a href="http://developer.android.com/reference/android/util/DisplayMetrics.html#density" target="_blank" rel="external">DisplayMetrics.density</a> 这个方法你可以获取设备像素密度,大部分时候最好让系统来自动进行缩放资源之类的操作,但是有时候控制的效果会更好一些.(尤其是在自定义View的时候).</p>
<p><a href="http://developer.android.com/reference/android/util/Pair.html#create(A, B" target="_blank" rel="external">Pair.create()</a>) 方便构建类和构造器的方法。</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/04/14/android-tips-round-up-part-2/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-2/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-2.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第二篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/text/format/DateUtils.html#formatDateTime%28android.content.Context,%20long,%20int%29">DateUtils.formatDateTime()</a> 用来进行区域格式化工作,输出格式化和本地化的时间或者日期.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(1)]]></title>
    <link href="http://androidperformance.com/2014/05/28/android-tips-round-up-1/"/>
    <id>http://androidperformance.com/2014/05/28/android-tips-round-up-1/</id>
    <published>2014-05-28T15:47:43.000Z</published>
    <updated>2015-03-27T05:34:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第一篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/app/Activity.html#startActivities(android.content.Intent[]" target="_blank" rel="external">Activity.startActivities()</a>) 常用于在应用程序中间启动其他的Activity.</p>
<a id="more"></a>
<p><a href="http://developer.android.com/reference/android/text/TextUtils.html#isEmpty(java.lang.CharSequence" target="_blank" rel="external">TextUtils.isEmpty()</a>) 简单的工具类,用于检测是否为空</p>
<p><a href="http://developer.android.com/reference/android/text/Html.html#fromHtml(java.lang.String" target="_blank" rel="external">Html.fromHtml()</a>) 用于生成一个Html,参数可以是一个字符串.个人认为它不是很快,所以我不怎么经常去用.（我说不经常用它是为了重点突出这句话：请多手动构建 Spannable 来替换 Html.fromHtml），但是它对渲染从 web 上获取的文字还是很不错的。</p>
<p><a href="http://developer.android.com/reference/android/widget/TextView.html#setError%28java.lang.CharSequence%29" target="_blank" rel="external">TextView.setError()</a> 在验证用户输入的时候很棒</p>
<p><a href="http://developer.android.com/reference/android/os/Build.VERSION_CODES.html" target="_blank" rel="external">Build.VERSION_CODES</a> 这个标明了当前的版本号,在处理兼容性问题的时候经常会用到.点进去可以看到各个版本的不同特性</p>
<p><a href="http://developer.android.com/reference/android/util/Log.html#getStackTraceString(java.lang.Throwable" target="_blank" rel="external">Log.getStackTraceString()</a>) 方便的日志类工具,方法Log.v()、Log.d()、Log.i()、Log.w()和Log.e()都是将信息打印到LogCat中，有时候需要将出错的信息插入到数据库或一个自定义的日志文件中，那么这种情况就需要将出错的信息以字符串的形式返回来，也就是使用static String getStackTraceString(Throwable tr)方法的时候.</p>
<p><a href="http://developer.android.com/reference/android/view/LayoutInflater.html#from%28android.content.Context%29" target="_blank" rel="external">LayoutInflater.from()</a> 顾名思义,用于Inflate一个layout,参数是layout的id.这个经常写Adapter的人会用的比较多.</p>
<p><a href="http://developer.android.com/reference/android/view/ViewConfiguration.html#getScaledTouchSlop%28%29" target="_blank" rel="external">ViewConfiguration.getScaledTouchSlop()</a> 使用 ViewConfiguration 中提供的值以保证所有触摸的交互都是统一的。这个方法获取的值表示:用户的手滑动这个距离后,才判定为正在进行滑动.当然这个值也可以自己来决定.但是为了一致性,还是使用标准的值较好.</p>
<p><a href="http://developer.android.com/reference/android/telephony/PhoneNumberUtils.html#convertKeypadLettersToDigits%28java.lang.String%29" target="_blank" rel="external">PhoneNumberUtils.convertKeypadLettersToDigits</a> 顾名思义.将字母转换为数字,类似于T9输入法,</p>
<p><a href="http://developer.android.com/reference/android/content/Context.html#getCacheDir%28%29" target="_blank" rel="external">Context.getCacheDir()</a> 获取缓存数据文件夹的路径,很简单但是知道的人不多,这个路径通常在SD卡上(这里的SD卡指的是广义上的SD卡,包括外部存储和内部存储)Adnroid/data/您的应用程序包名/cache/  下面.测试的时候,可以去这里面看是否缓存成功.缓存在这里的好处是:不用自己再去手动创建文件夹,不用担心用户把自己创建的文件夹删掉,在应用程序卸载的时候,这里会被清空,使用第三方的清理工具的时候,这里也会被清空.</p>
<p><a href="http://developer.android.com/reference/android/animation/ArgbEvaluator.html" target="_blank" rel="external">ArgbEvaluator</a> 用于处理颜色的渐变。就像 Chris Banes 说的一样，这个类会进行很多自动装箱的操作，所以最好还是去掉它的逻辑自己去实现它。这个没用过,不明其所以然,回头再补充.</p>
<p><a href="http://developer.android.com/reference/android/view/ContextThemeWrapper.html" target="_blank" rel="external">ContextThemeWrapper</a> 方便在运行的时候修改主题.</p>
<p><a href="http://developer.android.com/reference/android/widget/Space.html" target="_blank" rel="external">Space</a> space是Android 4.0中新增的一个控件，它实际上可以用来分隔不同的控件，其中形成一个空白的区域.这是一个轻量级的视图组件，它可以跳过Draw，对于需要占位符的任何场景来说都是很棒的。</p>
<p><a href="http://developer.android.com/reference/android/animation/ValueAnimator.html#reverse%28%29" target="_blank" rel="external">ValueAnimator.reverse()</a> 这个方法可以很顺利地取消正在运行的动画.我超喜欢.</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-1/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-1/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-1.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-1.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第一篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/app/Activity.html#startActivities(android.content.Intent[]">Activity.startActivities()</a>) 常用于在应用程序中间启动其他的Activity.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用VIM]]></title>
    <link href="http://androidperformance.com/2014/05/25/usevim/"/>
    <id>http://androidperformance.com/2014/05/25/usevim/</id>
    <published>2014-05-25T12:27:20.000Z</published>
    <updated>2015-03-27T05:25:21.000Z</updated>
    <content type="html"><![CDATA[<div style="color: #000000;font-family: 微软雅黑"><br>    <span><br>        为什么有那么多编辑器我要使用vim？因为当我想保存文件时总是习惯性的：wq，即使我正在使用eclipse什么的~<br>        其实使用熟练使用vim可以让你完全摆脱鼠标，摆脱小键盘，摆脱方向键，你的手不用离开那块键盘区域就能完成你能想到的任何事情。<br>        不过vim并不算是个很友好的编辑器，刚开始使用你会觉得它十分特别非常极其的操蛋。你会想怎么会有人用这种东西，还不如notepad，不如gedit，更不如我比较喜欢用的sublime Text。但是如果你强迫自己使用一到两周后慢慢你会发现这东西真是让人爱不释手。<br>        刚开始使用这货的时候，也是各种蛋疼~去看各种VIM命令大全，VIM命令手册等等的吧，收效甚微，看了也记不住。后来慢慢觉得命令不是看会的，而是用会的。不要去记那些命令是什么，而是当你需要什么样的命令时再去找这样的命令，甚至你可以创造一个这样的命令。<br>    </span><br><a id="more"></a><br><br>#<br>        VIM的三种模式<br><br>    <span><br>        不过基本的还是要稍微介绍一下的。比如vim的模式。一打开vim什么都不动就是普通（Normal）模式，这个时候是不能输入的，刚开始用你会觉得妈的打开个编辑器还不让我写。不要着急~按一下i就可以插入了，这时候就进入了编辑（Insert ）模式。退出编辑模式可以使用[ESC]，按下[ESC]后回到Normal模式，这时候输“：”就会进入命令模式了，比如：q是退出。现在使用这个命令应该是退不出来了，因为已经编辑了，所以可以使用：q！，加上感叹号之后可以强制命令执行，当然你要是想保存的可以使用：wq，w是写入，q是退出，写入之后就可以退出了吧。执行以下卧槽还不行，木有文件名，vim也不知道写到哪里啊，跟上文件名，使用：wq filename，这个时候就能退出了，这时候当前目录下就会出现名字为filename的文件了，cat一下就是你刚才写的内容，当然你要是毛都没写那在：q的时候就退出了~<br>    </span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.01.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.01.gif" alt="vim.20140525.01">
        </a><br>    </div><br>    <span><br>        小节：三种模式，普通模式，编辑模式，命令模式，普通模式可以使用一下快捷键，命令模式可以使用命令，比如刚才的w和q，编辑模式就不啰嗦了。<br>    </span><br><br>#<br>        光标移动命令<br><br>    <span><br>        了解了vim的模式可以用了吧？不行~你是不知道怎么移动光标呢。。。那用方向键不行吗？可以是可以的~但是这样手要移动的距离就远了，效率不高了。vim有很多移动光标用的快捷键，也有很多类似的命令，这里可能介绍不全，太多了，我只说我常用的。<br>        h，j，k，l 这四个键就是移动光标用的快捷键，当然要记得快捷键是在普通模式下用的。用之前可以习惯性按一下[ESC]，h在最左边，所以h是左移，l在最右边，所以l是右移，j有个钩，看上去就是个下移的货，K就只能上移了，快来试一下吧。除了这几个快捷键还有很多<br>    </span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.02.jpg" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.02.jpg" alt="vim.20140525.02">
        </a><br>    </div><br>    <span><br>        随便试几下，感受一下，刚开始肯定不习惯，但是一定要管住自己的手，不要去使用方向键，慢慢去习惯。当然移动光标的方法有很多。<br>        常用快捷键：<br>    </span><br>    <table><br>        <tr> <td>gg</td> <td>移动到文件开头</td> </tr><br>        <tr> <td>G</td> <td>移动到文件末尾</td> </tr><br>        <tr> <td>Ctrl + e</td> <td>向下滚动一行</td> </tr><br>        <tr> <td>Ctrl + y</td> <td>向上滚动一行</td> </tr><br>        <tr> <td>Ctrl + d</td> <td>向下滚动半个屏幕</td> </tr><br>        <tr> <td>Ctrl + u</td> <td>向上滚动半个屏幕</td> </tr><br>        <tr> <td>Ctrl + f</td> <td>向下滚动一个屏幕</td> </tr><br>        <tr> <td>Ctrl + b</td> <td>向上滚动一个屏幕</td> </tr><br>        <tr> <td>-(减号)</td> <td>移动到上面一行的开始</td> </tr><br>        <tr> <td>+ / ENTURN(回车)</td> <td>移动到下面一行的开始</td> </tr><br>        <tr> <td>^ / 0</td> <td>移动到行开头</td> </tr><br>        <tr> <td>$</td> <td>移动到行末尾</td> </tr><br>        <tr> <td>w</td> <td>向右移动一个单词</td> </tr><br>        <tr> <td>W</td> <td>向右移动一个以空格为分隔符的单词</td> </tr><br>        <tr> <td>b</td> <td>向左移动一个单词</td> </tr><br>        <tr> <td>B</td> <td>向左移动一个以空格为分隔符的单词</td> </tr><br>        <tr> <td>e</td> <td>向右移动到一个单词的结尾</td> </tr><br>        <tr> <td>E</td> <td>向右移动到一个以空格为分隔符的单词的结尾</td> </tr><br>        <tr> <td>t(c)</td> <td>向右移动到指定字符(c)之前的一个字符</td> </tr><br>        <tr> <td>T(c)</td> <td>向左移动到指定字符(c)之后的一个字符</td> </tr><br>        <tr> <td>f(c)</td> <td>向右移动到指定字符(c)</td> </tr><br>        <tr> <td>F(c)</td> <td>向左移动到指定字符(c)</td> </tr><br>        <tr> <td>numG</td> <td>移动到第num行(与：num类似)</td> </tr><br>        <tr> <td>H / M / L</td> <td>移动到屏幕 顶部 / 中部 / 底部</td> </tr><br>        <tr> <td>&#096;&#096;(ESC下面那个按键按两次)</td> <td>光标回到之前的位置</td> </tr><br>    </table><br>    <span><br>        这些快捷键不需要一次都记住，看个大概就好，差不多知道有哪些功能就行，等到需要用了回来找一下，然后去用，这样印象深刻才能记得住。上面的快捷键中可能w,b,e三个快捷键的大小写的功能有点绕，用个图片来说明一下，w和W之间的却别，b，e两个与w类似，建议自己尝试一下。<br>    </span><br>    <span>使用w（小写）</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.02.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.02.gif" alt="vim.20140525.02">
        </a><br>    </div><br>    <span>使用W（大写）</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.03.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.03.gif" alt="vim.20140525.03">
        </a><br>    </div><br>    <span>常用命令：</span><br><br><em>   :num（行号）     比如:15就是跳到15行的第一个字符
</em>   :$              移动到文件末尾<br>    <span><br>        说到这再啰嗦一句，要分清楚命令和快捷键，命令要先进入命令模式，也就是先按“ : ”然后输入命令。快捷键是在普通模式下，也就是按完ESC之后可以直接按键。<br>        脱离了方向键的束缚这下可以让你的双手安安心心的放在主键盘区域了。现在学会了模式切换稍微回顾一下：<br>    </span><br><br><em>   [ ESC ]进入普通模式，可以使用快捷键。
</em>   [ : ]冒号进入命令模式，可以使用命令。<br><em>   [ i ]进入编辑模式，可以编写文本。<br>    <span><br>        学会模式切换，光标移动，还有基本命令就可以编写文本或者程序了，只是效率还不够高，用起来不太方便。没关系，慢慢来，弄VIM这事一定不能急，我第一次用的时候差点把键盘砸了。<br>    </span><br><br># 添加和修改文本<br><br>    <span><br>        要想给文件添加文本就要进入编辑模式（其实也不一定），进入编辑模式的快捷键可不只是i。<br>    </span>

</em>   i / I     在光标前插入  /  在该行第一个非空白字符前插入<br><em>   a / A     在光标后插入  /  在该行行尾插入
</em>   o / O     在当前行的下面新建一行  /  在当前行的上面新建一行<br><em>   r / R     替换光标指定的字符（一次替换一个）  /   替换从当前光标所在的字符开始，直到按ESC键结束<br>    <span><br>        这四个字母的效果都比较简单，可以自己试一下，这里演示一下 r 和 R 。<br>    </span><br>    <span>使用r（小写）</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.04.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.04.gif" alt="vim.20140525.04">
        </a><br>    </div><br>    <span>使用R（大写）</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.05.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.05.gif" alt="vim.20140525.05">
        </a><br>    </div><br>    <span><br>        这四个字母除了 r 和 R 都能使VIM进入编辑模式。编写代码或者文本还需要不断地修改或者删除文本，VIM有各种各样的删除快捷键和命令。<br>    </span>

</em>   x / X      删除光标所在字符 /  删除光标前面一个字符<br>    <span><br>        这个两个快捷键都可以通过连续按键达到持续删除的效果，要注意看光标所在字符。<br>    </span><br>    <span>使用x（小写）</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.06.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.06.gif" alt="vim.20140525.06">
        </a><br>    </div><br>    <span>使用X（大写）</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.07.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.07.gif" alt="vim.20140525.07">
        </a><br>    </div><br>    <span><br>        可以看出来 x（小写）会删掉光标所在字符， X （大写）则不会。当然要是觉得连续按不方便可以直接在前面加重复因子，说得这么高大上，其实就是在前面加数字比如：6x 就是相当于按6次x，效果就是删掉6个字符了。前面的数字可以很大不局限于一位数，比如99x也可以的，不过我觉得十以上的你也不会一个字符一个字符的数到你想删除的地方吧。小心眼花~<br>        再看两个字母 c / C 和 d / D<br>        这两个字母的用法差不多，效果也差不多，稍微有点区别的就是使用 c / C 相关的快捷键后会直接从命令模式进入编辑模式，而 d / D 相关的则依然停留在普通模式。<br>    </span><br><br><em>   cc / dd                 删除一整行
</em>   C, c$ / D, d$           从光标当前位置删除到行尾<br>    <span><br>        cc / dd 也是可以使用重复因子的，比如：5cc / 5dd<br>        在删除多行时除了使用上面的快捷键之外还可以使用命令。<br>    </span><br><br><em>   :num1,num2d             删除行号num1和num2之间的所有行，包含num1和num2。（命令要在命令模式下使用，先按“ : ”）<br>    <span><br>        注意 c$ / d$ 是 d / c 与另一个快捷键 $ 的结合，$ 的作用是把光标移到行尾，所以联想一下别的移动快捷键组合一下：<br>    </span>

</em>   c0, c^ / d0, d^<br><em>   cw / dw</em>   cW / dW<br><em>   ce / de
</em>   ……<br>    <span><br>        这种快捷键还有很多，你可以自己来尝试组合，并观察效果。<br>    </span><br>    <span>(c)代表一个字符</span><br><br><em>   ct(c) / dt(c)        从光标当前位置删除到当前行的下一个字符(c)，不包括(c)。
</em>   cf(c) / df(c)        从光标当前位置删除到当前行的下一个字符(c)，包括(c)。<br>    <span><br>        这里交叉演示一下ct(c) 和 df(c) ，除了要看清 t 和 f 的区别，还要注意之前说的 c 和 d 的区别。当然也可以使用 T 和 F ，方向相反而已。<br>    </span><br>    <span>使用ct&#060;</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.08.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.08.gif" alt="vim.20140525.08">
        </a><br>    </div><br>    <span>使用df&#060;</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.09.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.09.gif" alt="vim.20140525.09">
        </a><br>    </div><br>    <span>注意字符“ &lt; ”的删除情况和左下角显示的“插入”，这表示VIM进入了编辑模式。</span><br><br><em>   s / S         删除当前字符并进入编辑模式（相当于快捷键 x + i 的组合） /  删除当前行并进入编辑模式（相当于快捷键组合dd + O）<br>    <span><br>        这两个命令也是可是使用重复因子的，具体效果自己尝试。<br>        改变字母的大小写也是比较常见的需求，所以VIM当然会有对应的快捷键<br>    </span>

</em>   ~   光标所在字符变成大写或小写，与字母原状态相反。并且光标右移。<br><em>   gu / gU<br>    <span><br>        这个“ ~ ”同样可以使用重复因子，但是我还是不喜欢去数字符，所以连续按就好了。<br>        gu 和 gU可以像c 和 d 一样在后面加移动快捷键，把当前位置到指定位置的字母全部改变，比较直观的是gu就是变成小写，gU是变成大写。比如gu$ / gU$<br>    </span><br><br># 复制与粘贴<br><br>    <span> 复制快捷键y和d有点相似：</span>

</em>   yy, Y          复制当前行<br><em>   y0, y^</em>   y$<br><em>   ……<br>    <span>跟 d 差不多，同样可以在前面加重复因子，同样可以接移动快捷键，具体效果自己yy吧。而且复制多行的命令也类似：</span>

</em>   :num1,num2y          复制行号num1和num2之间的所有行，包含num1和num2。（命令要在命令模式下使用，先按“ : ”，其实我这条也是从前面 yy 过来的）<br>    <span>粘贴快捷键 </span><br><br>*   p / P       粘贴至光标后，若复制整行则粘贴在当前行的下面。 /   粘贴至光标前，若复制整行则粘贴在当前行的上面。<br>    <span>其实不只是 yy  后可以使用 p / P，dd之后也是可以的，你就当成是剪切吧。</span><br>    <span>快捷键组合 dd + j + j + p</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.10.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.10.gif" alt="vim.20140525.10">
        </a><br>    </div>

<h1 id="搜索与替换（命令）">搜索与替换（命令）</h1><pre><code><span class="tag">&lt;<span class="title">span</span>&gt;</span>搜索命令<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
</code></pre><ul>
<li>:/rexp                      向前搜索rexp</li>
<li>:?rexp                      向后搜索rexp</li>
<li>:n                          重复最近一次搜索*   :N                          重复最近一次搜索，但方向相反</li>
<li>:/                          向前重复最近一次搜索</li>
<li>:？                         向后重复最近一次搜索</li>
<li><p>:%                          查找对应的括号如：(  ) , [  ] , {  }<br><span></span></p>
<pre><code>替换命令
替换命令的通用格式是   :[address]s<span class="regexp">/old/</span><span class="keyword">new</span>[<span class="regexp">/gc]</span>
</code></pre><p></p>
</li>
<li><p>address                行编号或者由都好分割的两个行编号，” . “代表当前行，” $ “代表最后一行，” % “代表全文，默认为当前行。</p>
</li>
<li>old / new              被替换的字符串 / 替换后的字符串</li>
<li>c                      替换前是否需要确认</li>
<li>g                      全局替换，每行不止替换一处。<br><span>比如使用   :%s/class/Class/gc</span><div><br>    <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.11.gif" target="_blank" rel="external"><br>        <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.11.gif" alt="vim.20140525.11">
    </a><br></div><br><span>也可以用来做注释用。 :%s/^/#/g</span><br><div><br>    <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.12.gif" target="_blank" rel="external"><br>        <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.12.gif" alt="vim.20140525.12">
    </a><br></div>

</li>
</ul>
<h1 id="区块模式">区块模式</h1><pre><code><span class="tag">&lt;<span class="title">span</span>&gt;</span>
    首先按esc进入命令行模式下，按下Ctrl + v，进入列（也叫区块）模式；在行首使用上下键选择需要注释的多行。
    然后可以进行删除或者插入等操作，比如也来个多行注释吧。
    选择多行后按 I （大写），然后写注释符号，按下ESC，稍等一下注释就出来了。
<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span>&gt;</span>
    [
        ![vim.20140525.13](http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.13.gif)
    ](http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.13.gif)
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</code></pre><h1 id="其他快捷键和命令">其他快捷键和命令</h1><pre><code>&lt;span&gt;
    <span class="constant">VIM还</span>有很多快捷键和命令，这里不可能说全，如图：[<span class="constant">VIM.</span>png](<span class="symbol">http:</span>/<span class="regexp">/coolshell.cn/</span><span class="regexp">/wp-content/uploads</span><span class="regexp">/2009/</span><span class="number">03</span>/vim.png)
    下面在列举几个常用的吧。
&lt;<span class="regexp">/span&gt;</span>
</code></pre><ul>
<li>J（大写）             将当前行与下一行连接起来</li>
<li>.                    重复上一次命令</li>
<li>u                    撤销（可连续使用）</li>
<li>Ctrl + r             取消上一次撤销（可连续使用）</li>
<li>Ctrl + P / Ctrl + n  插入模式下使用的快捷键，补全一个词，p是向上搜索，n是向下搜索。</li>
<li><p>Ctrl + xl            插入模式下使用的快捷键，补全一行，Ctrl + P / Ctrl + n 选择上一个或者下一个匹配。<br><span>使用快捷键组合 J + . (连续三次) + u(连续四次) + <a href="连续四次">Ctrl + r</a></span><br><div></div></p>
<pre><code><span class="collection">[
    !<span class="collection">[vim.20140525.14]</span><span class="list">(<span class="keyword">http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.14.gif</span>)</span>
]</span><span class="list">(<span class="keyword">http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.14.gif</span>)</span>
</code></pre><p></p></li></ul></div><br><span>使用Ctrl + P / Ctrl + n 和 使用Ctrl + xl </span><br><div><p></p>
<pre><code><span class="collection">[
    !<span class="collection">[vim.20140525.15]</span><span class="list">(<span class="keyword">http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.15.gif</span>)</span>
]</span><span class="list">(<span class="keyword">http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.15.gif</span>)</span>
</code></pre><p></p></div><br><span>命令</span><p></p>

<li><p>:w ， :w filename， :q! ， :wq          这四个命令前面都说过了，不再赘述。*   :&#120;                将工作缓存区内容写入当前文件并退出（与快捷键 ZZ 相同），功能与 :wq 相同。</p>
</li>
<li>:sp / :vsp   横向分屏，竖向分屏。</li>
<li>:e                打开另一个文件</li>
<li>:ls                查看已经打开的文件。</li>
<li>:!bash         执行shell命令<br><span><pre><code>关于分屏和打开多文件建议查看博客：[<span class="link_label">http://coolshell.cn/articles/11312.html</span>](<span class="link_url">http://coolshell.cn/articles/11312.html</span>)
终极命令 :help
</code></pre></span></li>

<h1 id="配置文件">配置文件</h1><pre><code>&lt;span&gt;
    可以通过对VIM配置文件进行修改来达到打开自动配置的效果。比如显示行号。一般修改当前用户的配置文件就可以了，路径<span class="string">" ~/.vimrc "</span>，如果文件不存在可以新建一个。
&lt;/span&gt;
&lt;span&gt;
    <span class="built_in">set</span> ts=<span class="number">4</span>
    <span class="built_in">set</span> expandtab
    <span class="built_in">set</span> ai
    <span class="built_in">set</span> nu
    <span class="built_in">let</span> mapleader=<span class="string">","</span>
    inoremap ( ()
    inoremap [ []
    inoremap { {}
    inoremap <span class="string">' '</span><span class="string">'
    inoremap " ""
&lt;/span&gt;
&lt;span&gt;
    这是一份非常简单的配置文件。里面配置了tab是4个空格，自动缩进，显示行号等等~还有映射。通过映射我们可以设计自己的命令。通过配置文件也可以配置VIM的插件，VIM的插件系统可是十分强大，足够让你打造一个完美的开发环境。快去尝试吧。
&lt;/span&gt;</span>
</code></pre><p></p>
<div style="color: #000000;font-family: 微软雅黑"><br>    <table><br>        <tr><br>            <td>Article Name:</td><br>            <td>使用VIM</td><br>        </tr><br>        <tr><br>            <td>Author:</td><br>            <td>刘天昊</td><br>        </tr><br>        <tr><br>            <td>Email:</td><br>            <td>liutianhao.pro@gmail.com</td><br>        </tr><br>    </table><br></div>]]></content>
    <summary type="html">
    <![CDATA[<div style="color: #000000;font-family: 微软雅黑"><br>    <span><br>        为什么有那么多编辑器我要使用vim？因为当我想保存文件时总是习惯性的：wq，即使我正在使用eclipse什么的~<br>        其实使用熟练使用vim可以让你完全摆脱鼠标，摆脱小键盘，摆脱方向键，你的手不用离开那块键盘区域就能完成你能想到的任何事情。<br>        不过vim并不算是个很友好的编辑器，刚开始使用你会觉得它十分特别非常极其的操蛋。你会想怎么会有人用这种东西，还不如notepad，不如gedit，更不如我比较喜欢用的sublime Text。但是如果你强迫自己使用一到两周后慢慢你会发现这东西真是让人爱不释手。<br>        刚开始使用这货的时候，也是各种蛋疼~去看各种VIM命令大全，VIM命令手册等等的吧，收效甚微，看了也记不住。后来慢慢觉得命令不是看会的，而是用会的。不要去记那些命令是什么，而是当你需要什么样的命令时再去找这样的命令，甚至你可以创造一个这样的命令。<br>    </span><br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://androidperformance.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Wordpress]修改主题后导致博客白屏的一种原因分析及解决办法]]></title>
    <link href="http://androidperformance.com/2014/05/18/wordpress-change-theme-with-blank/"/>
    <id>http://androidperformance.com/2014/05/18/wordpress-change-theme-with-blank/</id>
    <published>2014-05-18T01:05:51.000Z</published>
    <updated>2015-03-27T05:26:01.000Z</updated>
    <content type="html"><![CDATA[<p>对于使用<a href="http://wpchina.org/" target="_blank" rel="external">WordPress</a>建立个人博客的同学们来说，遭遇前后台白屏问题是一件非常令人郁闷的事情。wordpress白屏错误之所以令人郁闷，最重要的是你无法获知任何的错误信息，也没有弹出的对话提示，让人修复起来无从下手。想象一下你正在修改博客上的一个设置，或安装或升级一个插件，或升级最新版本的WordPress，或只是打开你的博客开始新的一天，但是你看到的，只是一个空白屏幕,估计想死的心都有了,于是各种google+百度,甚至bing都用上了,还是没有解决,结果若干配置文件被弄得越来越乱……</p>
<h2 id="0-问题背景">0.问题背景</h2><p>在站长工具<a href="http://www.google.com.hk/webmasters/tools/richsnippets?q=http%3A%2F%2Fgrackertalk.com%2F" target="_blank" rel="external">Google Structured Data Testing Tool</a>中跑网站测试的时候,发现会有很多bug导致搜索结果的富内容不完善,有个人信息(与Google+相连),也有文章中的Bug,我使用的主题是Dinky,作者是<span style="color: #121212;"><a href="http://misam.ir/" target="_blank" rel="external">Misam Saki</a>,就会出现:错误： Missing required field “updated”.</span></p>
<p>找到错误后,就去进行相应地修改,这个错误的意思就是说,文章中缺少updated这个字段,是因为有的主题(也可能是所有wordpress主题,不确定)会把updated这个字段去掉,用post_on这样类似的字段来代替.OK,原因找到了,就可以去修改了.然后就呵呵呵了.</p>
<p>找到functions.php,找到显示post_on相关的字段,加上update字段(网上摘抄),点击更新…..然后…..就没有然后了.不管怎么刷,网站的所有页面都是白屏,啥都看不到.</p>
<a id="more"></a>
<h2 id="1-问题解决">1.问题解决</h2><p>昨天遇到这个问题两次,第一次可谓大动干戈,差点就重装VPS了(把wordpress重装了一下,所有的插件,主题都重装的),最后发现还是不行,白屏,最后侥幸进了后台(重装之前后台也进不了),把改坏了的主题替换成其他的主题,熟悉的界面又一次出现了(泪流满面,果然是no zuo no die).</p>
<p>第二次又碰到了这个原因(不是说no zuo no die么?唐僧不是有一句话,我不下地狱,谁下地狱?),好吧自我安慰一下.这次就很镇定了,分析了一下问题后,尝试了Google出的一些方法,大部分是说编码问题,可是我的编码是utf8,没有问题.后来想了想,问题还是出在functions.php上,但是网页修改主题的界面是空白,就算返回可以看到修改前的文件,点击更新就会白屏.</p>
<p><span style="color: #ff0000;">于是远程登录vps后台,找到wordpress的根目录,进入到 /wo-content/theme/下,找到对应的主题,进去看这个主题的functions.php,发现被我改坏的哪一行依旧在,意思就是说前台的修改并没有成功.ORZ……删掉那一行之后又看到了熟悉的界面,</span>这次前后不到5分钟,虽然是个小问题,但是记录下来,如果能帮大家一个忙,也是不错的.</p>
<p>&nbsp;</p>
<h2 id="2-延伸阅读">2.延伸阅读</h2><p>wordpress白屏问题估计每个建站的人都会碰到,一般遇到这种问题之后,先不要慌,想想自己进行了哪些操作,去后台把这些操作还原一下,比如删掉刚刚下载的某个插件,或者刚刚应用的那个主题….之类的,重装是下下策.谨记,.</p>
<p>同时也说明备份是个好习惯,不至于一下损失太大.哈哈</p>
<p>&nbsp;</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于使用<a href="http://wpchina.org/">WordPress</a>建立个人博客的同学们来说，遭遇前后台白屏问题是一件非常令人郁闷的事情。wordpress白屏错误之所以令人郁闷，最重要的是你无法获知任何的错误信息，也没有弹出的对话提示，让人修复起来无从下手。想象一下你正在修改博客上的一个设置，或安装或升级一个插件，或升级最新版本的WordPress，或只是打开你的博客开始新的一天，但是你看到的，只是一个空白屏幕,估计想死的心都有了,于是各种google+百度,甚至bing都用上了,还是没有解决,结果若干配置文件被弄得越来越乱……</p>
<h2 id="0-问题背景">0.问题背景</h2><p>在站长工具<a href="http://www.google.com.hk/webmasters/tools/richsnippets?q=http%3A%2F%2Fgrackertalk.com%2F">Google Structured Data Testing Tool</a>中跑网站测试的时候,发现会有很多bug导致搜索结果的富内容不完善,有个人信息(与Google+相连),也有文章中的Bug,我使用的主题是Dinky,作者是<span style="color: #121212;"><a href="http://misam.ir/">Misam Saki</a>,就会出现:错误： Missing required field “updated”.</span></p>
<p>找到错误后,就去进行相应地修改,这个错误的意思就是说,文章中缺少updated这个字段,是因为有的主题(也可能是所有wordpress主题,不确定)会把updated这个字段去掉,用post_on这样类似的字段来代替.OK,原因找到了,就可以去修改了.然后就呵呵呵了.</p>
<p>找到functions.php,找到显示post_on相关的字段,加上update字段(网上摘抄),点击更新…..然后…..就没有然后了.不管怎么刷,网站的所有页面都是白屏,啥都看不到.</p>]]>
    
    </summary>
    
      <category term="Wordpress" scheme="http://androidperformance.com/categories/Wordpress/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Android4.4]第三方APP无法操作外置SD卡原因分析以及延伸阅读]]></title>
    <link href="http://androidperformance.com/2014/05/17/apps-can-no-android4-4-app-longer-write-files-to-your-sd-card/"/>
    <id>http://androidperformance.com/2014/05/17/apps-can-no-android4-4-app-longer-write-files-to-your-sd-card/</id>
    <published>2014-05-17T03:20:30.000Z</published>
    <updated>2015-03-27T05:20:04.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-问题背景:">1.问题背景:</h3><p>最近做Android4.4的平台移植,遇到一个问题:在Android4.4中,第三方App是没有权限操作外置SD卡的(除非是与自己包名相同的目录),开始以为是自己申请的权限不足,最后发现是Google在Android中限制了这一权限.这是原文:</p>
<blockquote>
<p><span style="\"color:" #404040;\"="">The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions.</span></p>
</blockquote>
<p>意思就是说,只有主存储有读写的权限,第二存储(通常是外置SD卡或者USBOTG,这个可以在设置菜单中自己设置)只有读的权限.原因也有给出:</p>
<blockquote>
<p><span style="\"color:" #404040;\"="">Restricting writes in this way ensures the system can clean up files when applications are uninstalled.</span></p>
</blockquote>
<p>另一个原因我觉得是安全的问题,这一方面的陈述会在下面详细介绍.</p>
<a id="more"></a>
<h3 id="2-解决办法:">2.解决办法:</h3><p>解决办法分两种,一种针对用户,一种针对开发者.</p>
<p><strong><em>针对用户:</em></strong></p>
<p>已经root的用户可以通过修改:<span style="\"color:" #444444;\"="">/system/etc/permissions/platform.xml</span> 文件(使用RE文件管理器即可),找到如下代码块:</p>
<pre class="\"lang:java" decode:true\"="" title="\"写sd卡的权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>修改为:</p>
<pre class="\"lang:java" decode:true\"="" title="\"修改后的写SD卡权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;group gid=\"media_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>然后重启.就可以读写SD卡了.</p>
<p>这个做法其实就是给<span style="\"color:" #666666;\"="">android.permission.WRITE_EXTERNAL_STORAGE</span> 这个权限组加上对media的读写权限.</p>
<p><strong><em>针对开发者:</em></strong></p>
<p><span style="\"color:" #323333;\"="">XDA论坛上的方法，先把文件改为图片类型，再用media content provider来删除.</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"转换成媒体文件,再进行操作\"">private static final Uri FILES_URI = MediaStore.Files.getContentUri(\"external\");
    public static boolean deleteFile(Context context, String path) {
        ContentResolver cr = context.getContentResolver();
        if (cr == null) return false;
        final String selection = FileColumns.DATA + \"=?\";
        final String[] selectionArgs = new String[] { path };
        ContentValues values = new ContentValues();
        values.put(FileColumns.MEDIA_TYPE, FileColumns.MEDIA_TYPE_IMAGE);
        return cr.update(FILES_URI, values, selection, selectionArgs) &gt; 0
                &amp;&amp; cr.delete(FILES_URI, selection, selectionArgs) &gt; 0;
    }</pre>

<p>这样做是因为MediaProvider拥有读写SD卡的 权限,通过它去操作文件也可以达到目标.不过有人反映如果把默认存储设置为内置SD卡，该方法貌似就失效了。不知道有没有更好的办法？</p>
<p><strong><em>针对rom开发者:</em></strong></p>
<p>rom开发者有更好的选择,<span style="\"color:" #444444;\"="">platform.xml的文件位置在源代码:frameworks/base/data/etc/中,和方法1中的步骤一样:</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"写sd卡的权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>修改为:</p>
<pre class="\"lang:java" decode:true\"="" title="\"修改后的写SD卡权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;group gid=\"media_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>然后重新编译一个rom即可.</p>
<p>&nbsp;</p>
<h3 id="3-延伸阅读">3.延伸阅读</h3><p>Google这么做的原因,我也查阅了一些文章,下面是一些我觉得比较好的回答,大家感兴趣可以自己看一下:</p>
<p>第一篇是Google+上的一个人的分析,大概解释了一下google这样做的原因以及造成的影响(英文很简单):</p>
<blockquote>
<p><span style="\"color:" #404040;\"="">KitKat will make your SD Card completely useless: per the Android API specification, apps can no longer write files to your SD card.  And Samsung is following it.This only applies to dual-storage devices, i.e., devices with a user-writable internal flash storage <strong>AND</strong> a removable SD card.</span></p>
<p><span style="\"color:" #404040;\"="">From </span><span style="\"color:" #427fed;\"=""><a href="http://source.android.com/devices/tech/storage/index.html" target="_blank" rel="external">http://source.android.com/devices/tech/storage/index.html</a></span><span style="\"color:" #404040;\"="">:\”The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions.\”</span></p>
<p><span style="\"color:" #404040;\"="">If your device has user-accessible internal flash storage, your SD Card is a \”secondary external storage device\”.</span></p>
<p><span style="\"color:" #404040;\"="">What this means is that with KitKat, applications will no longer be able create, modify, or remove files and folders on your external SD card.  As a for-instance, you can no longer use a file manager to copy files from your computer to the SD card over a network.  This ability, which has existed since the beginning of Android, has been taken away.</span></p>
<p><span style="\"color:" #404040;\"="">The only stated reason for this removal of functionality is that, \”Restricting writes in this way ensures the system can clean up files when applications are uninstalled.\”  I do not pretend to understand this logic.  Apps are still allowed to write in arbitrary directories on the primary storage (with the appropriate permission), but are denied the same access to external storage.</span></p>
<p><span style="\"color:" #404040;\"="">Samsung has implemented this feature with their KitKat OTA updates.  Note3 users are now complaining that FX File Explorer can no longer write to their external SD cards.  There are solutions to this problem for users with root access.  Users without root access appear to be screwed.</span></p>
<p><span style="\"color:" #404040;\"="">I\’m not quite certain how Google intends for you to place files on your SD card.  Perhaps you have to use proprietary Google apps that contain permissions unavailable to the rest of the developer world.  Perhaps you\’re supposed to put everything on the cloud and pay carrier data fees to get it there.  Perhaps you\’re supposed to use some kind of WIRE to attach your WIRELESS device to your computer and have the computer do that work for you.</span></p>
<p><span style="\"color:" #404040;\"="">In my opinion this is a horrible misstep by Google and the Android Open Source Project.  Functionality has been removed without reason, to the severe detriment of users and developers alike.</span></p>
<p><span style="\"color:" #404040;\"="">I apologize for not bringing this to everyone\’s attention when KitKat 4.4 was released, but it was not mentioned in the Android 4.4 changes document:</span><span style="\"color:" #427fed;\"=""><a href="http://developer.android.com/about/versions/android-4.4.html" target="_blank" rel="external">http://developer.android.com/about/versions/android-4.4.html</a></span><span style="\"color:" #404040;\"="">.  It\’s only mentioned in the article on </span><span style="\"color:" #427fed;\"="">source.android.com</span><span style="\"color:" #404040;\"="">.  I was only made aware of its existence from user reports as a result of Samsung implementing this change in its KitKat OTA updates. </span></p>
</blockquote>
<p>第二篇是知乎上的讨论,大家自行脑补:</p>
<blockquote>
<p><span style="\"color:" #232323;\"="">这有可能真的只是一个限制，影响很小，因为这个限制并不彻底，primary external storage 仍然可写，而支持双 SD 的设备并不很多。我们大家更期待的是让 primary external storage 也同样受到这个限制，虽然这个修改将涉及到更多应用的不兼容。</span></p>
<p><span style="\"color:" #232323;\"="">所以这个问题并没有彻底解决，到对 primary external storage 也限制的那个时候，才真正的解决了这个问题。</span></p>
<p><span style="\"color:" #232323;\"="">就目前而言，第二 SD 卡仍然是可以读写的，只是要读写到指定的目录（具体应该在 /Android/data/）。这样的规定意味着应用程序只能对 SD 卡的指定目录进行读写，不能读写任意目录。相当于 Google 出手对 SD 卡目录结构进行了规范。之前 android 不限制目录，所以各种应用就随意的在 SD 卡上建一个目录。然后 SD 卡上的目录到处都是，用户对这种现象早就深恶痛绝了！如果 Google 对这件事情下狠手，只能说是<strong>大快人心</strong>。</span></p>
<p><span style="\"color:" #232323;\"="">另外说一下，SD 卡上的指定目录是这样获取的：</span><br><span style="\"color:" #232323;\"="">1，程序相关的 内置存储目录，这个目录位于内置 flash，应用程序可以随意读写：</span></p>
<p><pre class="\"lang:java" decode:true\"="">getFilesDir();</pre><br><span style="\"color:" #232323;\"="">2，程序相关的 SD 卡外部存储目录，这个目录位于 SD 卡，应用程序可以随意读写：</span></p>
<p><pre class="\"lang:java" decode:true="" crayon-selected\"="">getExternalFilesDir(null);</pre><br><span style="\"color:" #232323;\"="">3，SD 卡公共目录，这些目录仍然可以访问，不受权限限制：</span></p>
<p><pre class="\"lang:java" decode:true\"="">Environment.getExternalStoragePublicDirectory(x)</pre><br><span style="\"color:" #232323;\"="">其中 x 可以是 Environment.DIRECTORY_ALARMS 等预定义的常量。可以查找 Environment 的帮助。</span></p>
<p><span style="\"color:" #232323;\"="">如果大家要存储数据，可以用 1 或者 2 的方法，获取正确的目录，然后进行任意读写，这样不会把 SD 卡的目录写乱。</span></p>
</blockquote>
<p>第三篇也是知乎上一个讨论:</p>
<blockquote>
<p><span style="\"color:" #232323;\"="">Google 给出的理由有一定的道理——相信很多有洁癖的人都很讨厌第三方应用在 SD 卡或者内置存储下随意建立文件夹吧，有节操的应用应该只在以自己的包名区分的目录下存放需要的文件。</span></p>
<p><span style="\"color:" #232323;\"="">至于为什么只限制 SD 卡，不包括内置存储，我觉得是因为 SD 卡是可以插在别的地方的，目录结构是有可能暴露出来的，也有可能被修改。规范应用在 SD 卡的读写，可以使得这个 SD 卡上的目录和文件可以在其他设备上被电脑「理解」——「这个目录是在某一个 Android 设备上用到的，我不必理会它」，如果第三方应用随意在 SD 卡根目录创建命名不规范并且无规律的目录，这个 SD 卡在其他地方就会使电脑或者人迷惑——「这个目录是干什么的？是谁创建的？我可不可以删掉它？」。手机的内部存储空间不能拆卸，所以其目录结构不会轻易暴露给用户，也不会放在别的设备上，所以可以暂时不管。</span></p>
</blockquote>
<p>&nbsp;</p>
<p>参考:</p>
<p>1.<a href="\">https://plus.google.com/+TodLiebeck/posts/gjnmuaDM8sn</a></p>
<p>2.<a href="\">http://www.zhihu.com/question/22778889</a></p>
<p>3.<a href="\">http://source.android.com/devices/tech/storage/index.html</a></p>
<p>&nbsp;</p>
<p>相关阅读 :</p>
<ol>
<li><a href="\">Android4.4中扫描文件广播权限变更分析</a></li>
</ol>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-问题背景:">1.问题背景:</h3><p>最近做Android4.4的平台移植,遇到一个问题:在Android4.4中,第三方App是没有权限操作外置SD卡的(除非是与自己包名相同的目录),开始以为是自己申请的权限不足,最后发现是Google在Android中限制了这一权限.这是原文:</p>
<blockquote>
<p><span style=\"color: #404040;\">The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions.</span></p>
</blockquote>
<p>意思就是说,只有主存储有读写的权限,第二存储(通常是外置SD卡或者USBOTG,这个可以在设置菜单中自己设置)只有读的权限.原因也有给出:</p>
<blockquote>
<p><span style=\"color: #404040;\">Restricting writes in this way ensures the system can clean up files when applications are uninstalled.</span></p>
</blockquote>
<p>另一个原因我觉得是安全的问题,这一方面的陈述会在下面详细介绍.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Android4.4]Permission Denial: not allowed to send broadcast android.intent.action.MEDIA_MOUNTED]]></title>
    <link href="http://androidperformance.com/2014/05/14/android4-4permission-denial-not-allowed-to-send-broadcast-android-intent-action-media-mounted/"/>
    <id>http://androidperformance.com/2014/05/14/android4-4permission-denial-not-allowed-to-send-broadcast-android-intent-action-media-mounted/</id>
    <published>2014-05-14T15:37:28.000Z</published>
    <updated>2015-03-27T05:19:36.000Z</updated>
    <content type="html"><![CDATA[<h4 id="摘要:_Android4-4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案-">摘要: Android4.4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案.</h4><p>&nbsp;</p>
<h3 id="0-_问题背景">0. 问题背景</h3><p>在Android4.4之前，许多应用程序使用如下代码去通知更新文件数据库</p>
<pre class="\"lang:java" decode:true\"="" title="\"通知系统更新文件系统\"">sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>这样做的坏处：每次发送这个广播，都会<span style="\"color:" #222222;\"="">让MediaScanner重新扫描一次系统文件，很影响设备的电池寿命。当然传入的路径可以</span> 是单个文件或者内容很少的文件夹，会减轻扫描系统文件的压力，但是还是会因为扫描频繁而浪费电。所以在Android4.4<span style="\"color:" #222222;\"="">开始，只允许系统应用发送这样的intent。</span> 所以在Android4.4系统的机器上会出现如下错误：</p>
<pre class="\"lang:java" decode:true\"="" title="\"错误\""> Permission Denial: not allowed to send broadcast android.intent.action.MEDIA_MOUNTED</pre>

<h3 id="1-_解决办法：">1. 解决办法：</h3><p>1 . 将Intent换为 <a href="\"><code>ACTION_MEDIA_SCANNER_SCAN_FILE</code></a><span style="\"color:" #000000;\"="">.</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"ACTION_MEDIA_SCANNER_SCAN_FILE\"">sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>但是这个Intent只扫描文件，不扫描文件夹。如果你的应用只操作单个文件而不是文件夹，就可以使用这个。 2. 不发广播，换为MediaScannerConnection进行通知更新</p>
<pre class="\"lang:java" decode:true\"="" title="\"MediaScannerConnection\""> MediaScannerConnection.scanFile(this,
          new String[] { file.toString() }, null,
          new MediaScannerConnection.OnScanCompletedListener() {
      public void onScanCompleted(String path, Uri uri) {
          Log.i(\"ExternalStorage\", \"Scanned \" + path + \":\");
          Log.i(\"ExternalStorage\", \"-&gt; uri=\" + uri);
      }
 });</pre>

<p>这样做就属于不发送广播,在4.4上可以正常工作.</p>
<a id="more"></a>
<h4 id="拓展">拓展</h4><p>代码跟踪,让我们看看scanFile做了什么事: 1.查看scanFile的源码:</p>
<pre class="\"lang:java" decode:true\"="" title="\"scanFile\"">    public static void scanFile(Context context, String[] paths, String[] mimeTypes,
            OnScanCompletedListener callback) {
        ClientProxy client = new ClientProxy(paths, mimeTypes, callback);
        MediaScannerConnection connection = new MediaScannerConnection(context, client);
        client.mConnection = connection;
        connection.connect();
    }</pre>

<p>2.ClintProxy源码:</p>
<pre class="\"lang:java" decode:true\"="" title="\"ClientProxy\"">    static class ClientProxy implements MediaScannerConnectionClient {
        final String[] mPaths;
        final String[] mMimeTypes;
        final OnScanCompletedListener mClient;
        MediaScannerConnection mConnection;
        int mNextPath;

        ClientProxy(String[] paths, String[] mimeTypes, OnScanCompletedListener client) {
            mPaths = paths;
            mMimeTypes = mimeTypes;
            mClient = client;
        }

        public void onMediaScannerConnected() {
            scanNextPath();
        }

        public void onScanCompleted(String path, Uri uri) {
            if (mClient != null) {
                mClient.onScanCompleted(path, uri);
            }
            scanNextPath();
        }

        void scanNextPath() {
            if (mNextPath &gt;= mPaths.length) {
                mConnection.disconnect();
                return;
            }
            String mimeType = mMimeTypes != null ? mMimeTypes[mNextPath] : null;
            mConnection.scanFile(mPaths[mNextPath], mimeType);
            mNextPath++;
        }
    }</pre>

<p>3.MediaScannerConnection的connect方法:</p>
<pre class="\"lang:java" decode:true\"="" title="\"connect\"">    /**
     * Initiates a connection to the media scanner service.
     * {@link MediaScannerConnectionClient#onMediaScannerConnected()}
     * will be called when the connection is established.
     */
    public void connect() {
        synchronized (this) {
            if (!mConnected) {
                Intent intent = new Intent(IMediaScannerService.class.getName());
                intent.setComponent(
                        new ComponentName(\"com.android.providers.media\",
                                \"com.android.providers.media.MediaScannerService\"));
                mContext.bindService(intent, this, Context.BIND_AUTO_CREATE);
                mConnected = true;
            }
        }
    }</pre>

<p>这里可以看到,最后是start了一个service:MediaScannerService MediaScannerService 的源码可以在<a href="\">这里看到</a>:我们重点看一下scan方法:</p>
<pre class="\"lang:java" decode:true\"="" title="\"scan\"">private void scan(String[] directories, String volumeName) {
        // don\'t sleep while scanning
        mWakeLock.acquire();

        ContentValues values = new ContentValues();
        values.put(MediaStore.MEDIA_SCANNER_VOLUME, volumeName);
        Uri scanUri = getContentResolver().insert(MediaStore.getMediaScannerUri(), values);

        Uri uri = Uri.parse(\"file://\" + directories[0]);
        sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_STARTED, uri));

        try {
            if (volumeName.equals(MediaProvider.EXTERNAL_VOLUME)) {
                 openDatabase(volumeName);    
            }

            MediaScanner scanner = createMediaScanner();
            scanner.scanDirectories(directories, volumeName);
        } catch (Exception e) {
            Log.e(TAG, \"exception in MediaScanner.scan()\", e); 
        }

        getContentResolver().delete(scanUri, null, null);

        sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, uri));
        mWakeLock.release();
    }</pre>

<p>可以看到最终调用了<span style="\"color:" #48484c;\"="">MediaScanner来进行扫描,扫描结束后,发送ACTION_MEDIA_SCANNER_FINISHED广播.应用程序可以接受此广播来更新界面之类</span></p>
<p>&nbsp;</p>
<p>参考资料：</p>
<ol>
<li><p><a href="\">http://stackoverflow.com/questions/18624235/android-refreshing-the-gallery-after-saving-new-images</a></p>
</li>
<li><p><a href="\">http://stackoverflow.com/questions/21469431/permission-denial-not-allowed-to-send-broadcast-in-android</a></p>
</li>
<li><p><a href="\">http://www.androideng.com/?p=1108</a></p>
</li>
</ol>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="摘要:_Android4-4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案-">摘要: Android4.4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案.</h4><p>&nbsp;</p>
<h3 id="0-_问题背景">0. 问题背景</h3><p>在Android4.4之前，许多应用程序使用如下代码去通知更新文件数据库</p>
<pre class=\"lang:java decode:true\" title=\"通知系统更新文件系统\">sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>这样做的坏处：每次发送这个广播，都会<span style=\"color: #222222;\">让MediaScanner重新扫描一次系统文件，很影响设备的电池寿命。当然传入的路径可以</span> 是单个文件或者内容很少的文件夹，会减轻扫描系统文件的压力，但是还是会因为扫描频繁而浪费电。所以在Android4.4<span style=\"color: #222222;\">开始，只允许系统应用发送这样的intent。</span> 所以在Android4.4系统的机器上会出现如下错误：</p>
<pre class=\"lang:java decode:true\" title=\"错误\"> Permission Denial: not allowed to send broadcast android.intent.action.MEDIA_MOUNTED</pre>

<h3 id="1-_解决办法：">1. 解决办法：</h3><p>1 . 将Intent换为 <a href="\"><code>ACTION_MEDIA_SCANNER_SCAN_FILE</code></a><span style=\"color: #000000;\">.</span></p>
<pre class=\"lang:java decode:true\" title=\"ACTION_MEDIA_SCANNER_SCAN_FILE\">sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>但是这个Intent只扫描文件，不扫描文件夹。如果你的应用只操作单个文件而不是文件夹，就可以使用这个。 2. 不发广播，换为MediaScannerConnection进行通知更新</p>
<pre class=\"lang:java decode:true\" title=\"MediaScannerConnection\"> MediaScannerConnection.scanFile(this,
          new String[] { file.toString() }, null,
          new MediaScannerConnection.OnScanCompletedListener() {
      public void onScanCompleted(String path, Uri uri) {
          Log.i(\"ExternalStorage\", \"Scanned \" + path + \":\");
          Log.i(\"ExternalStorage\", \"-&gt; uri=\" + uri);
      }
 });</pre>

<p>这样做就属于不发送广播,在4.4上可以正常工作.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android开发:Log2File工具类]]></title>
    <link href="http://androidperformance.com/2014/05/02/android_log_to_file/"/>
    <id>http://androidperformance.com/2014/05/02/android_log_to_file/</id>
    <published>2014-05-02T05:25:35.000Z</published>
    <updated>2015-03-27T05:19:46.000Z</updated>
    <content type="html"><![CDATA[<div style="color: #000000;">Log2File工具类是用于Android程序将Log记录到文件中(如sd卡)的工具,应用场景：</div><br><div style="color: #000000;"><br><br>1.  无法连接电脑进行调试（usb线被usbotg占用）<br>2.  Log不容易被抓取<br>3.  Bug出现很随机，不是必出现<br>4.  其他自己脑补<br><br>##  0.说明<br><br>这篇文章最早是在我的CSDN博客上面发布了:<a href="http://blog.csdn.net/grackergao/article/details/18322749" title="Log2File类的使用" target="_blank" rel="external">http://blog.csdn.net/grackergao/article/details/18322749</a> .现在讲他转移到了这里,代码的Github地址 :<a href="https://github.com/Gracker/Android-Utils/blob/master/Log2File.java" title="Log2File的github地址" target="_blank" rel="external">https://github.com/Gracker/Android-Utils/blob/master/Log2File.java</a><br><br><a id="more"></a><br><br>## 1.Log2File工具类源码<br><br><pre class="lang:java decode:true " title="Log2File工具类源码">import java.io.BufferedWriter;<br>import java.io.File;<br>import java.io.FileWriter;<br>import java.io.IOException;<br>import java.util.Date;<br><br>import android.content.Context;<br>import android.os.Environment;<br><br>public class Log2File<br>{<br>    private static boolean  logInit;<br>    private static BufferedWriter writer;<br><br>    private Log2File()<br>    {<br><br>    }<br><br>    /<strong><br>     <em> 初始化Log,创建log文件
     </em> @param ctx<br>     <em> @param fileName
     </em> @return<br>     */<br>    public static boolean init(Context ctx, String fileName)<br>    {<br>        if(!logInit)<br>        {<br>            String state = Environment.getExternalStorageState();<br>            if (Environment.MEDIA_MOUNTED.equals(state))<br>            {<br>                File sdDir = Environment.getExternalStorageDirectory();<br>                File logDir = new File(sdDir.getAbsolutePath() + “/log2file/“ +<br>                        ctx.getPackageName() + “/“);<br><br>                try {<br>                    if(!logDir.exists())<br>                    {<br>                        logDir.mkdirs();<br>                    }<br><br>                    File logFile = new File(logDir, fileName);<br>                    logFile.createNewFile();<br><br>                    writer = new BufferedWriter(new FileWriter(logFile, true));<br>                    logInit = true;<br>                } catch (IOException e) {<br>                    // TODO Auto-generated catch block<br>                    e.printStackTrace();<br>                }<br><br>            }<br><br>        }<br><br>        return logInit;<br>    }<br><br>    /</strong><br>     <em> 写一条log
     </em> @param msg<br>     <em>/<br>    public static void w(String msg)<br>    {<br>        if(logInit)<br>        {<br>            try {<br>                Date date = new Date();<br>                writer.write(“[“ + date.toLocaleString() + “] “ + msg);<br>                writer.newLine();<br>                writer.flush();<br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>            }<br>        }<br>    }<br><br>    /**
     </em> 关闭log<br>     */<br>    public static void close()<br>    {<br>        if(logInit)<br>        {<br>            try {<br>                writer.close();<br>                writer = null;<br><br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>                e.printStackTrace();<br>            }<br><br>            logInit = false;<br>        }<br>    }<br>}<br></pre><br><br>##  2.Log2File类的使用<br><br><div>这个工具类的使用比较简单</div><br><div>1.首先调用init进行初始化</div><br><div><br><pre class="lang:java decode:true " title="Log2File类的初始化">Log2File.init(context, fileName);</pre><br>2.调用w()进行输出<br><pre class="lang:java decode:true " title="调用w(String msg)函数进行输出">Log2File.w(String msg);</pre><br>3.使用完毕后，记得要关闭Log<br><pre class="lang:java decode:true  crayon-selected" title="关闭Log">Log2File.close();</pre><br></div><br></div>]]></content>
    <summary type="html">
    <![CDATA[<div style="color: #000000;">Log2File工具类是用于Android程序将Log记录到文件中(如sd卡)的工具,应用场景：</div><br><div style="color: #000000;"><br><br>1.  无法连接电脑进行调试（usb线被usbotg占用）<br>2.  Log不容易被抓取<br>3.  Bug出现很随机，不是必出现<br>4.  其他自己脑补<br><br>##  0.说明<br><br>这篇文章最早是在我的CSDN博客上面发布了:<a href="http://blog.csdn.net/grackergao/article/details/18322749" title="Log2File类的使用">http://blog.csdn.net/grackergao/article/details/18322749</a> .现在讲他转移到了这里,代码的Github地址 :<a href="https://github.com/Gracker/Android-Utils/blob/master/Log2File.java" title="Log2File的github地址">https://github.com/Gracker/Android-Utils/blob/master/Log2File.java</a><br><br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Github" scheme="http://androidperformance.com/categories/Android/Github/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用VPS搭建VPN+VPN路由设置+MacOS的VPN登录设置]]></title>
    <link href="http://androidperformance.com/2014/05/02/use-vps-and-vpn/"/>
    <id>http://androidperformance.com/2014/05/02/use-vps-and-vpn/</id>
    <published>2014-05-02T01:54:20.000Z</published>
    <updated>2015-03-27T05:25:06.000Z</updated>
    <content type="html"><![CDATA[<h4 id="虚拟专用网（英语：Virtual_Private_Network，简称VPN），是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。虚拟私人网络的讯息透过公用的网络架构（例如：互联网）来传送内联网的网络讯息。它利用已加密的通道协议（Tunneling_Protocol）来达到保密、传送端认证、信息准确性等私人信息安全效果。这种技术可以用不安全的网络（例如：互联网）来传送可靠、安全的信息。需要注意的是，加密信息与否是可以控制的。没有加密的虚拟专用网信息依然有被窃取的危险。"><strong>虚拟专用网</strong>（<span style="\"color:" #0645ad;\"="">英语</span>：<a href="\"><strong>Virtual Private Network</strong></a>，简称<strong>VPN</strong>），是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。虚拟私人网络的讯息透过公用的网络架构（例如：<span style="\"color:" #0645ad;\"="">互联网</span>）来传送内联网的网络讯息。它利用已加密的<span style="\"color:" #0645ad;\"="">通道协议</span>（Tunneling Protocol）来达到保密、传送端认证、信息准确性等私人信息安全效果。这种技术可以用不安全的网络（例如：互联网）来传送可靠、安全的信息。需要注意的是，加密信息与否是可以控制的。没有加密的虚拟专用网信息依然有被窃取的危险。</h4><h1 id=""> </h1><h2 id="1-搭建VPN">1.搭建VPN</h2><p>使用这个VPS已经有一个月了，wordpress也折腾得差不多了，之前一直说要搭建一个VPN，由于种种原因没有去做，今天刚好有时间，就照着教程来了一遍，总算是搞定了，在Doit上划掉这个Task的时候，幸福感满满的。</p>
<p>搭建过程还是蛮无聊的，教程都写得很清楚，我之所以要搬运一下，是因为搭建+配置+登录，这一套组合拳下来，才能在<a href="\">facebook</a>、<a href="\">youtube</a>上刷网，但是各个教程都只是讲了一部分。我把基本操作搬运过来，然后再加上自己遇到的问题和解决方法，可以让看博客的人对着这篇一路下来就可以直接上网了。</p>
<h3 id="1-1_前提条件">1.1 前提条件</h3><p>首先，你要有一个VPS，国外的VPS。如果不懂可以查看<a href="\" title="\">如何搭建VPS</a>  我使用的是Linode在日本美帝的的服务器（如果你也想买Linode的VPS，购买的时候输入我的邀请code：a96df99ce34b5e0f76695558608c87fb2db5cc03 或者直接：<a href="\" title="\">https://www.linode.com/r=a96df99ce34b5e0f76695558608c87fb2db5cc03</a>）</p>
<p>其次，要懂一点Linux，一点点就可以了。</p>
<a id="more"></a>
<h3 id="1-2_搭建VPN">1.2 搭建VPN</h3><p>本人的Vps的操作系统用的是Ubuntu12.04 LTS ,所以下面的操作基于Ubuntu,悉知:</p>
<p><span style="\"color:" #323333;\"=""><strong>1、用root账户登陆服务器</strong></span><br><span style="\"color:" #323333;\"=""><strong>2、安装PPTPD</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"安装pptpd\"">apt-get install pptpd</pre>

<p><span style="\"color:" #323333;\"=""><strong>3、编辑pptpd.conf文件</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"编辑配置文件\"">vi /etc/pptpd.conf</pre>

<p><span style="\"color:" #323333;\"="">取消注释下面内容</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"需要去掉注释的部分\"">option /etc/ppp/pptpd-options
localip 192.168.0.1
remoteip 192.168.0.234-238,192.168.0.245</pre>

<p><span style="\"color:" #323333;\"="">这几句的意思是：当外部计算机通过pptp联接到vpn后所能拿到的ip地址范围和服务器的ip地址设置。</span><br><span style="\"color:" #323333;\"=""><strong>4、添加用于登陆的账户</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"编辑用户信息\"">vi /etc/ppp/chap-secrets</pre>

<p><span style="\"color:" #323333;\"="">格式如下：</span><br><span style="\"color:" #323333;\"="">用户名 pptpd \”密码\” *   比如:</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"账号密码例子\"">Gracker pptpd \"Ab1234567890\" *</pre>

<p>&nbsp;</p>
<p>密码需要用英文双引号星号(*)代表允许接入的ip可以是任意ip。这样，vpn就搭建好了，不过大多数人包括我在内，用国外服务器搭VPN都是为了偶尔能跳出局域网，所以我们还需要配置转发。</p>
<p><span style="\"color:" #323333;\"=""><strong>5、设置DNS解析，编辑pptpd-options文件</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"编辑转发\"">vi /etc/ppp/pptpd-options</pre>

<p><span style="\"color:" #323333;\"="">找到ms-dns，取消掉注释，并修改DNS地址，这里我推荐大家用Google DNS 8.8.8.8 和 8.8.4.4</span><br><span style="\"color:" #323333;\"=""><strong>6、开启转发</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"开启转发\"">vi /etc/sysctl.conf</pre>

<p><span style="\"color:" #323333;\"="">取消注释以下内容</span></p>
<pre class="\"lang:java" decode:true\"="">net.ipv4.ip_forward=1</pre>

<p><span style="\"color:" #323333;\"="">这句话意思是：打开内核IP转发,执行下面的命令让配置生效(感谢@扎啤 提醒)</span></p>
<pre class="\"lang:java" decode:true\"="">sysctl –p</pre>

<p><span style="\"color:" #323333;\"=""><strong>7、安装iptables并设置</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"安装iptables并设置\"">apt-get install iptables
iptables -t nat -I POSTROUTING -j MASQUERADE</pre>

<p><span style="\"color:" #323333;\"="">后面这句话作用是：立刻让LINUX支持NAT(platinum)</span></p>
<pre class="\"lang:java" decode:true\"="">iptables -I FORWARD -p tcp --syn -i ppp+ -j TCPMSS --set-mss 1356</pre>

<p><span style="\"color:" #323333;\"="">假如有部分网站访问不正确，则加入这句，将MTU值调小，这句将MTU值设置为1356。</span><br><span style="\"color:" #323333;\"="">　但是，只是这样，iptables 的规则会在下次重启时被清除，所以我们还需要把它保存下来，方法是使用 iptables-save 命令：   iptables-save &gt; /etc/iptables-rules然后修改 /etc/network/interfaces 文件，找到 eth0 那一节，在对 eth0 的设置最末尾加上下面这句：    pre-up iptables-restore &lt; /etc/iptables-rules这样当网卡 eth0 被加载的时候就会自动载入我们预先用 iptables-save 保存下的配置。</span><br><span style="\"color:" #323333;\"=""><strong>8、重新启动服务</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"重启pptp\"">/etc/init.d/pptpd restart</pre>

<p><span style="\"color:" #323333;\"=""><strong>9、到这一步,VPN就算搭建好了,登录账号密码之后就可以等脸书,推特等之前呵呵呵的网站了.不过这还不算完,登录过程中也有少许坑,下面将一一介绍.</strong></span></p>
<p>&nbsp;</p>
<h2 id="2-配置路由表">2.配置路由表</h2><p><span style="\"color:" #323333;\"="">VPN 是好用，挂上之后国外的网站是能访问了，但原来国内正常访问嘻唰唰的网站立刻变得慢吞吞了，怎么破？这是个问题。如果连了 VPN 没做任何设置的话，会导致所有网络都是通过 VPN 访问，缺点有二：1、VPN 的流量问题，严重的话还可能导致被 VPN 提供商封杀。2、嘻唰唰变慢吞吞的问题。我们上面搭建的VPN如果直接连接的话,就会导致国内的网站访问速度变慢,解决办法就是配置路由表.下面是<a href="\" title="\">维基百科中关于路由表的介绍</a>:</span></p>
<blockquote>
<p>在<a href="\" title="\">计算机网络</a>中，<strong>路由表</strong>（routing table）或称<strong>路由择域信息库</strong>（RIB, Routing Information Base），是一个存储在<a href="\" title="\">路由器</a>或者联网计算机中的电子表格（文件）或<a href="\" title="\">类数据库</a>。路由表存储着指向特定网络地址的路径（在有些情况下，还记录有路径的<a href="\" title="\">路由度量值</a>）。路由表中含有网络周边的<a href="\" title="\">拓扑</a>信息。路由表建立的主要目标是为了实现<a href="\" title="\">路由协议</a>和静态路由选择。</p>
<p>在现代路由器构造中，路由表不直接参与<a href="\" title="\">数据包</a>的传输，而是用于生成一个小型指向表，这个指向表仅仅包含由路由算法选择的数据包传输优先路径，这个表格通常为了优化硬件存储和查找而被压缩或提前编译。本文将忽略这个执行的详细情况而选择整个路径选择／传输信息子系统作为路由表来说明。</p>
</blockquote>
<p>具体步骤(Mac,Windows和Linux自行补脑):</p>
<p><span style="\"color:" #323333;\"="">1. 打开系统偏好设置—&gt;网络，增加 VPN 设置，VPN 类型选择PPTP，根据提示设置用户名密码等信息即可。</span></p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p><span style="\"color:" #323333;\"="">2. 下载 chnroutes.py，相关网址：<a href="https://code.google.com/p/chnroutes/downloads/list" target="_blank" rel="external">https://code.google.com/p/chnroutes/downloads/list</a></span></p>
<p><span style="\"color:" #323333;\"="">3. 打开终端进入下载文件的目录，执行：python chnroutes.py -p mac，该目录下会生成两个文件「ip-up」和「ip-down」。</span></p>
<p><span style="\"color:" #323333;\"="">4. 把这两个文件复制到 /etc/ppp 下，然后进入该目录执行：sudo chmod a+x ip-up ip-down</span></p>
<p><span style="\"color:" #323333;\"="">测试一下，在终端执行：netstat -nr，检查路由表的输出信息。连接 VPN，然后再次执行：netstat -nr，你会发现路由表已经发生了变化。这时再去访问国内的网站，你发现他们又变得嘻唰唰了，同时还能访问 Twitter 和 Facebook！</span></p>
<p>&nbsp;</p>
<h2 id="3-MacOs的VPN登录设置">3.MacOs的VPN登录设置</h2><h3 id="1-调整vpn网络顺序">1.调整vpn网络顺序</h3><p>Mac上登录vpn很简单,<span style="\"color:" #323333;\"="">打开系统偏好设置—&gt;网络，增加 VPN 设置，VPN 类型选择PPTP，根据提示设置用户名密码等信息即可.但是这样还不能登录Facebook之类的网站的话,就还得把VPN这个网络放到默认网络前面,才能正常登录(<span style="\"color:" #ff0000;\"="">注意VPN的位置</span>):</span></p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>具体步骤:</p>
<p>1.</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>2.</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>&nbsp;</p>
<p>大功告成.</p>
<h3 id="2-给小伙伴共享劳动成果">2.给小伙伴共享劳动成果</h3><p>vpn搭建好了之后,默认我们只设置了一个用户,在/etc/ppp/chap-secrets中,如果有其他小伙伴也想使用的话,按照前面添加用户的方法,在下一行添加即可.由于Linode的vps套餐送的流量很多,一个人通常是用不完的.Linode最近服务升级,官网变得小清新了之外,套餐也变得很给力:</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>Update at : 2014-7-24</p>
<p>Linode有了新的套餐:如下</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>参考:</p>
<p>1.<a href="\" title="\">http://www.storyday.com/html/y2011/2843_vpn_route_tables.html</a></p>
<p>2.<a href="\" title="\">http://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E7%A7%81%E4%BA%BA%E7%B6%B2%E8%B7%AF</a></p>
<p>3.<a href="\" title="\">http://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E8%A1%A8</a></p>
<p>4.<a href="\" title="\">http://www.cnblogs.com/Heisenbug/p/3442522.html</a></p>
<p>5.<a href="\" title="\">http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;amp;mid=200062863&amp;amp;idx=1&amp;amp;sn=ecd28282f9d500db4fdb8df39f3726b2&amp;amp;scene=1#rd</a></p>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="虚拟专用网（英语：Virtual_Private_Network，简称VPN），是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。虚拟私人网络的讯息透过公用的网络架构（例如：互联网）来传送内联网的网络讯息。它利用已加密的通道协议（Tunneling_Protocol）来达到保密、传送端认证、信息准确性等私人信息安全效果。这种技术可以用不安全的网络（例如：互联网）来传送可靠、安全的信息。需要注意的是，加密信息与否是可以控制的。没有加密的虚拟专用网信息依然有被窃取的危险。"><strong>虚拟专用网</strong>（<span style=\"color: #0645ad;\">英语</span>：<a href="\"><strong>Virtual Private Network</strong></a>，简称<strong>VPN</strong>），是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。虚拟私人网络的讯息透过公用的网络架构（例如：<span style=\"color: #0645ad;\">互联网</span>）来传送内联网的网络讯息。它利用已加密的<span style=\"color: #0645ad;\">通道协议</span>（Tunneling Protocol）来达到保密、传送端认证、信息准确性等私人信息安全效果。这种技术可以用不安全的网络（例如：互联网）来传送可靠、安全的信息。需要注意的是，加密信息与否是可以控制的。没有加密的虚拟专用网信息依然有被窃取的危险。</h4><h1 id=""> </h1><h2 id="1-搭建VPN">1.搭建VPN</h2><p>使用这个VPS已经有一个月了，wordpress也折腾得差不多了，之前一直说要搭建一个VPN，由于种种原因没有去做，今天刚好有时间，就照着教程来了一遍，总算是搞定了，在Doit上划掉这个Task的时候，幸福感满满的。</p>
<p>搭建过程还是蛮无聊的，教程都写得很清楚，我之所以要搬运一下，是因为搭建+配置+登录，这一套组合拳下来，才能在<a href="\">facebook</a>、<a href="\">youtube</a>上刷网，但是各个教程都只是讲了一部分。我把基本操作搬运过来，然后再加上自己遇到的问题和解决方法，可以让看博客的人对着这篇一路下来就可以直接上网了。</p>
<h3 id="1-1_前提条件">1.1 前提条件</h3><p>首先，你要有一个VPS，国外的VPS。如果不懂可以查看<a href="\" title="\">如何搭建VPS</a>  我使用的是Linode在日本美帝的的服务器（如果你也想买Linode的VPS，购买的时候输入我的邀请code：a96df99ce34b5e0f76695558608c87fb2db5cc03 或者直接：<a href="\" title="\">https://www.linode.com/r=a96df99ce34b5e0f76695558608c87fb2db5cc03</a>）</p>
<p>其次，要懂一点Linux，一点点就可以了。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://androidperformance.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <link href="http://androidperformance.com/2014/04/12/analysishashmap/"/>
    <id>http://androidperformance.com/2014/04/12/analysishashmap/</id>
    <published>2014-04-11T18:26:27.000Z</published>
    <updated>2015-03-31T01:32:05.000Z</updated>
    <content type="html"><![CDATA[<div style="text-align: left">          链表和数组可以按照人们意愿排列元素的次序，但是，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，直到找到为止。如果集合中元素很多，将会消耗很多时间。有一种数据结构可以快速查找所需要查找的对象，这个就是哈希表（hash table）。</div><br><div>          HashMap是基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</div><br><div>          1.HashMap的数据结构：</div><br><div><a href="http://www.grackertalk.com/wp-content/uploads/2014/04/hm01.png" target="_blank" rel="external"><img src="http://www.grackertalk.com/wp-content/uploads/2014/04/hm01.png" alt="hm01"></a></div><br><div>           HashMap使用数组和链表来共同组成的。可以看出底层是一个数组，而数组的每个元素都是一个链表头。</div><br><div></div><br><div><br><br><a id="more"></a><br><br><pre class="theme:eclipse lang:java decode:true">    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {<br>        final K key;<br>        V value;<br>        Entry&lt;K,V&gt; next;<br>        int hash;<br>        …<br>     }</pre><br><div align="left">Entry是HashMap中的一个内部静态类，包级私有，实现了Map中的接口Entey&lt;K,V&gt;。可以看出来它内部含有一个指向下一个元素的指针。</div><br><div align="left"><span style="font-family: Consolas"> </span></div><br><div>          2.构造函数</div><br><div>          HashMap的构造函数有四个：</div><br><div>HashMap()</div><br><div>          构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。</div><br><div>HashMap(int initialCapacity)</div><br><div>          构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</div><br><div>HashMap(int initialCapacity, float loadFactor)</div><br><div>          构造一个带指定初始容量和加载因子的空 HashMap。</div><br><div>HashMap(Map&lt;? extends K,? extends V&gt; m)</div><br><div>          构造一个映射关系与指定 Map 相同的新 HashMap。</div><br><div>实际上就两种，一个是指定初始容量和加载因子，一个是用一个给定的映射关系生成一个新的HashMap。先来说第一个。</div><br><div><br><pre class="theme:eclipse lang:java decode:true">    /<strong><br>     <em> Constructs an empty &lt;tt&gt;HashMap &lt;/tt&gt; with the specified initial
     </em> capacity and load factor.<br>     <em>
     </em> @param  initialCapacity the initial capacity<br>     <em> @param  loadFactor      the load factor
     </em> @throws IllegalArgumentException if the initial capacity is negative<br>     <em>         or the load factor is nonpositive
     </em>/<br>    public HashMap( int initialCapacity, float loadFactor) {<br>        if (initialCapacity &lt; 0)<br>            throw new IllegalArgumentException( “Illegal initial capacity: “ +<br>                                               initialCapacity);<br>        if (initialCapacity &gt; MAXIMUM_CAPACITY)<br>            initialCapacity = MAXIMUM_CAPACITY;<br>        if (loadFactor &lt;= 0 || Float. isNaN(loadFactor))<br>            throw new IllegalArgumentException( “Illegal load factor: “ +<br>                                               loadFactor);<br><br>        // Find a power of 2 &gt;= initialCapacity<br>        int capacity = 1;<br>        while (capacity &lt; initialCapacity)<br>            capacity &lt;&lt;= 1;<br><br>        this.loadFactor = loadFactor;<br>        threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);<br>        table = new Entry[capacity];<br>        useAltHashing = sun.misc.VM. isBooted() &amp;&amp;<br>                (capacity &gt;= Holder. ALTERNATIVE_HASHING_THRESHOLD);<br>        init();<br>    }</strong></pre><br>&nbsp;<br><div><br><div align="left">参数很简单，初始容量，和加载因子。初始容量定义了初识数组的大小，加载因子和初始容量的乘积确定了一个阈值。阈值最大是(1&lt;&lt;30) + 1。初始容量一定是2的N次方，而且刚刚比要设置的值大。默认初始容量是16，默认加载因子是0.75。当表中的元素数量大于等于阈值时，数组的容量会翻倍，并重新插入元素到新的数组中，所以HashMap不保证顺序恒久不变。</div><br><div align="left">当输入的加载因子小于零或者不是浮点数时会抛出异常（IllegalArgumentException）。</div><br><div align="left"></div><br><div align="left"><br><div>3.put操作</div><br><div><br><pre class="theme:eclipse lang:java decode:true ">    /<br>     <em> Associates the specified value with the specified key in this map.
     </em> If the map previously contained a mapping for the key, the old<br>     <em> value is replaced.
     </em><br>     <em> @param key key with which the specified value is to be associated
     </em> @param value value to be associated with the specified key<br>     <em> @return the previous value associated with &lt;tt&gt;key &lt;/tt&gt;, or
     </em>         &lt;tt&gt;null &lt;/tt&gt; if there was no mapping for &lt;tt&gt; key&lt;/tt&gt; .<br>     <em>         (A &lt;tt&gt;null &lt;/tt&gt; return can also indicate that the map
     </em>         previously associated &lt;tt&gt;null &lt;/tt&gt; with &lt;tt&gt; key&lt;/tt&gt; .)<br>     <em>/<br>    public V put(K key, V value) {<br>        if (key == null)<br>            return putForNullKey(value);<br>        int hash = hash(key);<br>        int i = indexFor(hash, table .length );<br>        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e. next) {<br>            Object k;<br>            if (e. hash == hash &amp;&amp; ((k = e. key) == key || key.equals(k))) {<br>                V oldValue = e. value;<br>                e. value = value;<br>                e.recordAccess( this);<br>                return oldValue;<br>            }<br>        }<br><br>        modCount++;<br>        addEntry(hash, key, value, i);<br>        return null;<br>    }</em></pre><br>&nbsp;<br><div>由于HashMap只是key值为null，所以首先要判断key值是不是为null，是则进行特殊处理。</div><br></div><br></div><br></div><br></div><br>&nbsp;<br><pre class="theme:eclipse lang:java decode:true ">    /**
      Offloaded version of put for null keys<br>     <em>/<br>    private V putForNullKey(V value) {<br>        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e. next) {<br>            if (e. key == null) {<br>                V oldValue = e. value;<br>                e. value = value;<br>                e.recordAccess( this);<br>                return oldValue;<br>            }<br>        }<br>        modCount++;<br>        addEntry(0, null, value, 0);<br>        return null;<br>    }</em></pre><br>&nbsp;<br><div><br><div align="left">可以看出key值为null则会插入到数组的第一个位置。如果第一个位置存在，则替代，不存在则添加一个新的。稍后会看到addEntry函数。</div><br><div align="left">PS：考虑一个问题，key值为null会插入到table[0]，那为什么还要遍历整个链表呢？</div><br><div align="left">回到put函数中。在判断key不为null后，会求key的hash值，并通过indexFor函数找出这个key应该存在table中的位置。</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Returns index for hash code h.<br>     <em>/<br>    static int indexFor (int h, int length) {<br>        return h &amp; (length-1);<br>    }</em></pre><br>&nbsp;<br><div><br><div align="left">indexFor函数很简短，但是却实现的很巧妙。一般来说我们把一个数映射到一个固定的长度会用取余（%）运算，也就是h % length，但里巧妙地运用了table.length的特性。还记得前面说了数组的容量都是很特殊的数，是2的N次方。用二进制表示也就是一个1后面N个0，（length-1）就是N个1了。这里直接用与运算，运算速度快，效率高。但是这是是利用了length的特殊性，如果length不是2的N次方的话可能会增加冲突。</div><br><div align="left">前面的问题在这里就有答案了。因为indexFor函数返回值的范围是0到（length-1），所以可能会有key值不是null的Entry存到table[0]中，所以前面还是需要遍历链表的。</div><br><div align="left">得到key值对应在table中的位置，就可以对链表进行遍历，如果存在该key则，替换value，并把旧的value返回，modCount++代表操作数加1。这个属性用于Fail-Fast机制，后面讲到。如果遍历链表后发现key不存在，则要插入一个新的Entry到链表中。这时就会调用addEntry函数。</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Adds a new entry with the specified key, value and hash code to<br>     <em> the specified bucket.  It is the responsibility of this
     </em> method to resize the table if appropriate.<br>     <em>
     </em> Subclass overrides this to alter the behavior of put method.<br>     <em>/<br>    void addEntry (int hash, K key, V value, int bucketIndex) {<br>        if ((size &gt;= threshold) &amp;&amp; ( null != table[bucketIndex])) {<br>            resize(2 </em> table. length);<br>            hash = ( null != key) ? hash(key) : 0;<br>            bucketIndex = indexFor(hash, table.length);<br>        }<br><br>        createEntry(hash, key, value, bucketIndex);<br>    }</pre><br>&nbsp;<br><div>这个函数有四个参数，第一个是key的hash值，第二个第三个分别是key和value，最后一个是这个key在table中的位置，也就是indexFor(hash(key), table.length-1)。首先会判断size（当前表中的元素个数）是不是大于或等于阈值。并且判断数组这个位置是不是空。如果条件满足则要resize(2 <em> table. length)，等下我们来看这个操作。超过阈值要resize是为了减少冲突，提高访问效率。判断当前位置不是空时才resize是为了尽可能减少resize次数，因为这个位置是空，放一个元素在这也没有冲突，所以不影响效率，就先不进行resize了。</em></div><br><div><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Rehashes the contents of this map into a new array with a<br>     <em> larger capacity.  This method is called automatically when the
     </em> number of keys in this map reaches its threshold.<br>     <em>
     </em> If current capacity is MAXIMUM_CAPACITY, this method does not<br>     <em> resize the map, but sets threshold to Integer.MAX_VALUE.
     </em> This has the effect of preventing future calls.<br>     <em>
     </em> @param newCapacity the new capacity, MUST be a power of two;<br>     <em>        must be greater than current capacity unless current
     </em>        capacity is MAXIMUM_CAPACITY (in which case value<br>     <em>        is irrelevant).
     </em>/<br>    void resize(int newCapacity) {<br>        Entry[] oldTable = table;<br>        int oldCapacity = oldTable. length;<br>        if (oldCapacity == MAXIMUM_CAPACITY) {<br>            threshold = Integer. MAX_VALUE;<br>            return;<br>        }<br><br>        Entry[] newTable = new Entry[newCapacity];<br>        boolean oldAltHashing = useAltHashing;<br>        useAltHashing |= sun.misc.VM. isBooted() &amp;&amp;<br>                (newCapacity &gt;= Holder. ALTERNATIVE_HASHING_THRESHOLD);<br>        boolean rehash = oldAltHashing ^ useAltHashing;<br>        transfer(newTable, rehash);<br>        table = newTable;<br>        threshold = (int)Math.min(newCapacity <em> loadFactor , MAXIMUM_CAPACITY + 1);<br>    }</em></pre><br>&nbsp;<br><div><br><div align="left">resize操作先要判断当前table的长度是不是已经等于最大容量（1&lt;&lt;30）了，如果是则把阈值调到整数的最大值（(1&lt;&lt;31) - 1），就没有再拓展table的必要了。如果没有到达最大容量，就要生成一个新的空数组，长度是原来的两倍。这时候可能要问了，如果oldTable. length不等于MAXIMUM_CAPACITY，但是（2  oldTable. length）也就是newCapacity大于MAXIMUM_CAPACITY怎么办？这个是不可能的，因为数组长度是2的N次方，而MAXIMUM_CAPACITY = 1&lt;&lt;30。</div><br><div align="left">生成新的数组后要执行transfer函数。</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true">    /<strong><br>     <em> Transfers all entries from current table to newTable.
     </em>/<br>    void transfer(Entry[] newTable, boolean rehash) {<br>        int newCapacity = newTable. length;<br>        for (Entry&lt;K,V&gt; e : table) {<br>            while( null != e) {<br>                Entry&lt;K,V&gt; next = e. next;<br>                if ( rehash) {<br>                    e. hash = null == e. key ? 0 : hash(e. key);<br>                }<br>                int i = indexFor(e.hash, newCapacity);<br>                e. next = newTable[i];<br>                newTable[i] = e;<br>                e = next;<br>            }<br>        }<br>    }</strong></pre><br>&nbsp;<br><div><br><div align="left">这个函数要做的就是把原来table中的值挨个拿出来插到新数组中，由于数组长度发生了改变，所以元素的位置肯定发生变化，所以HashMap不能保证该顺序恒久不变。回到resize函数，这时新的数组已经生成了，只需要替换原来数组就好了。并且要更新一下阈值。可以看出来resize是个比较消耗资源的函数，所以能减少resize的次数就尽量减少。</div><br><div align="left">回到函数addEntry 中，判断完是不是需要resize后就需要创建一个新的Entry了。</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true ">    /<br>     <em> Like addEntry except that this version is used when creating entries
     </em> as part of Map construction or “pseudo -construction” (cloning,<br>     <em> deserialization).  This version needn’t worry about resizing the table.
     </em><br>     <em> Subclass overrides this to alter the behavior of HashMap(Map),
     </em> clone, and readObject.<br>     <em>/<br>    void createEntry( int hash, K key, V value, int bucketIndex) {<br>        Entry&lt;K,V&gt; e = table[bucketIndex];<br>        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);<br>        size++;<br>    }</em></pre><br>&nbsp;<br><div>调用createEntry函数，参数跟addEntry一样，第一个是key的hash值，第二个第三个分别是key和value，最后一个是这个key在table中的位置。这里的操作与Entry的构造函数有关系。</div><br><div><br><pre class="theme:eclipse lang:java decode:true ">        /**
          Creates new entry.<br>         <em>/<br>        Entry (int h, K k, V v, Entry&lt;K,V&gt; n) {<br>            value = v;<br>            next = n;<br>            key = k;<br>            hash = h;<br>        }</em></pre><br>&nbsp;<br><div>构造函数中传入一个Entry对象，并把它当做这个新生成的Entry的next。所以createEntry函数中的操作相当于把table[bucketIndex]上的链表拿下来，放在新的Entry后面，然后再把新的Entry放到table[bucketIndex]上。</div><br><div><a href="http://www.grackertalk.com/wp-content/uploads/2014/04/hm02.png" target="_blank" rel="external"><img src="http://www.grackertalk.com/wp-content/uploads/2014/04/hm02.png" alt="hm02"></a></div><br><div></div><br><div><br><div><br><div align="left">到这里整个put函数算是结束了。如果新插入的K，V则会返回null。</div><br><div align="left"></div><br><div align="left">4.get操作</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Returns the value to which the specified key is mapped,<br>     <em> or {@code null} if this map contains no mapping for the key.
     </em><br>     <em> &lt;p&gt;More formally, if this map contains a mapping from a key
     </em> {@code k} to a value {@code v} such that {@code (key==null ? k==null :<br>     <em> key.equals(k))}, then this method returns {@code v}; otherwise
     </em> it returns {@code null}.  (There can be at most one such mapping.)<br>     <em>
     </em> &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily &lt;/i&gt;<br>     <em> indicate that the map contains no mapping for the key; it’s also
     </em> possible that the map explicitly maps the key to {@code null}.<br>     <em> The {@link #containsKey containsKey} operation may be used to
     </em> distinguish these two cases.<br>     <em>
     </em> @see #put(Object, Object)<br>     <em>/<br>    public V get(Object key) {<br>        if (key == null)<br>            return getForNullKey();<br>        Entry&lt;K,V&gt; entry = getEntry(key);<br><br>        return null == entry ? null : entry.getValue();<br>    }</em></pre><br>&nbsp;<br><div>也是先判断key是不是null，做特殊处理。直接上代码，不赘述。</div><br><div><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Offloaded version of get() to look up null keys.  Null keys map<br>     <em> to index 0.  This null case is split out into separate methods
     </em> for the sake of performance in the two most commonly used<br>     <em> operations (get and put), but incorporated with conditionals in
     </em> others.<br>     <em>/<br>    private V getForNullKey() {<br>        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e. next) {<br>            if (e. key == null)<br>                return e. value;<br>        }<br>        return null;<br>    }</em></pre><br>&nbsp;<br><div>key不是null则会调用getEntry函数，并返回一个Entry对象，如果不是null，就返回entry的value。</div><br><div><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Returns the entry associated with the specified key in the<br>     <em> HashMap.  Returns null if the HashMap contains no mapping
     </em> for the key.<br>     <em>/<br>    final Entry&lt;K,V&gt; getEntry(Object key) {<br>        int hash = (key == null) ? 0 : hash(key);<br>        for (Entry&lt;K,V&gt; e = table[ indexFor(hash, table.length)];<br>             e != null;<br>             e = e. next) {<br>            Object k;<br>            if (e. hash == hash &amp;&amp;<br>                ((k = e. key) == key || (key != null &amp;&amp; key.equals(k))))<br>                return e;<br>        }<br>        return null;<br>    }</em></pre><br>&nbsp;<br><div><br><div align="left">直接求key值hash值，然后求table中的位置，遍历链表。有返回entry对象，没有返回null。</div><br><div align="left"></div><br><div align="left">5. Fail-Fast机制：</div><br></div><br></div><br></div><br><pre class="theme:eclipse lang:java decode:true ">    /**
      The number of times this HashMap has been structurally modified<br>     <em> Structural modifications are those that change the number of mappings in
     </em> the HashMap or otherwise modify its internal structure (e.g.,<br>     <em> rehash).  This field is used to make iterators on Collection-views of
     </em> the HashMap fail -fast.  (See ConcurrentModificationException).<br>     */<br>    transient int modCount;</pre><br>&nbsp;<br><div><br><div align="left">    我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</div><br><div align="left">    这一策略在源码中的实现是通过modCount域，保证线程之间修改的可见性。，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</div><br><div>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</div><br><div></div><br><div><br><div><br><div>《Core JAVA》</div><br><div>《JDK 中文文档》</div>

<div style="color: #000000;font-family: 微软雅黑"><br>        <table><br>            <tr><br>                <td>Article Name:</td><br>                <td>HashMap源码分析</td><br>            </tr><br>            <tr><br>                <td>Author:</td><br>                <td>刘天昊</td><br>            </tr><br>            <tr><br>                <td>Email:</td><br>                <td>liutianhao.pro@gmail.com</td><br>            </tr><br>        </table><br></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div>]]></content>
    <summary type="html">
    <![CDATA[<div style="text-align: left">          链表和数组可以按照人们意愿排列元素的次序，但是，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，直到找到为止。如果集合中元素很多，将会消耗很多时间。有一种数据结构可以快速查找所需要查找的对象，这个就是哈希表（hash table）。</div><br><div>          HashMap是基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</div><br><div>          1.HashMap的数据结构：</div><br><div><a href="http://www.grackertalk.com/wp-content/uploads/2014/04/hm01.png"><img src="http://www.grackertalk.com/wp-content/uploads/2014/04/hm01.png" alt="hm01"></a></div><br><div>           HashMap使用数组和链表来共同组成的。可以看出底层是一个数组，而数组的每个元素都是一个链表头。</div><br><div></div><br><div><br><br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://androidperformance.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Service：开发自己的通知中心(2):辅助性服务实战]]></title>
    <link href="http://androidperformance.com/2014/04/01/android-service-build-your-own-notification-servers-app/"/>
    <id>http://androidperformance.com/2014/04/01/android-service-build-your-own-notification-servers-app/</id>
    <published>2014-03-31T16:05:47.000Z</published>
    <updated>2015-03-27T05:27:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-辅助性服务实战介绍">1.辅助性服务实战介绍</h2><p>上一篇文章介绍了什么是Accessibility以及简单的使用，这一篇文章就来讲讲如何使用Accessibility服务来创建一个简单的Android通知中心。Android中通知中心是一个系统层面的服务，负责显示应用和系统发来的通知（Notification，比如USB插入、选择输入法、未接来电、截图、天气信息、新闻推送等等）。在android4.3之前，一般的第三方应用是无法获取Notification list的（在Android4.3之后，有了一个新的接口,NotificationListenerService.getActiveNotifications(),可以获取当前的Notification）。但是利用Accessibility服务可以监听到各种事件的特性，可以开发一个第三方的通知中心，实现与系统通知栏类似的功能。</p>
<a id="more"></a>
<p>下面就来介绍如何开发自己的通知中心。</p>
<h2 id="2-开发第三方通知中心">2.开发第三方通知中心</h2><h3 id="2-1继承AccessibilitySerivce">2.1继承AccessibilitySerivce</h3><p>按照上一篇辅助性服务的介绍，一个辅助性服务可以被捆绑到一个标准的应用程序上，或者以一个单独的安卓工程被创建，我们这里建立一个服务，继承AccessibilitySerivce</p>
<pre class="\"lang:java" decode:true\"="" title="\"继承AccessibilityService\"">import android.accessibilityservice.AccessibilityService;
import android.accessibilityservice.AccessibilityServiceInfo;
import android.app.Notification;
import android.app.PendingIntent;
import android.content.Intent;
import android.os.Parcelable;
import android.util.Log;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;
import android.view.accessibility.AccessibilityRecord;
import android.widget.Toast;

public class NotificationFetcherService extends AccessibilityService {

    private static final String TAG = \"NotificationFetcherService: \";

    public void onAccessibilityEvent(AccessibilityEvent event) {
        if (!(event.getEventType() == AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED) ){
            return;
        }

        Notification localNotification = (Notification)event.getParcelableData();

        if (localNotification != null) {
            Intent intent=new Intent();
            intent.putExtra(\"NotifyData\", localNotification);
            intent.setAction(\".NotificationFetcherService\");
            sendBroadcast(intent);
        }

    }

    @Override
    protected void onServiceConnected() {

        // Define it in both xml file and here,  for compatibility with pre-ICS devices
        AccessibilityServiceInfo info = new AccessibilityServiceInfo();
        info.eventTypes = AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED |
                AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED | 
                AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED;

        info.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;
        setServiceInfo(info);
    }

    @Override
    public void onInterrupt() {
        System.out.println(\"onInterrupt\");
    }

}</pre>

<p>继承AccessibilitySerivce必须要重写几个重要的方法：</p>
<p>onServiceConnected方法负责在服务和Activity绑定的时候，进行初始化数据，这里新建了一个AccessibilityServiceInfo对象，并将TYPE_NOTIFICATION_STATE_CHANGED、TYPE_WINDOW_STATE_CHANGED、TYPE_WINDOW_CONTENT_CHANGED纳入监听范围，TYPE_NOTIFICATION_STATE_CHANGED表示这个服务可以监听Notification的变化，我们正是使用这个特性来实现第三方的通知中心功能。</p>
<p>onInterrupt是服务断开时调用的函数</p>
<p>onAccessibilityEvent是最重要的，它负责监听所注册的eventTypes（在onServiceConnected中注册的）的事件。从上面的代码中我们可以得到一个Notification对象：</p>
<pre class="\"lang:java" decode:true\"="" title="\"得到Notification对象\"">Notification localNotification = (Notification)event.getParcelableData();</pre>

<p>得到Notification对象之后，就可以进行自己的操作，我这里是通过广播的形式，将收到的Notification发送给Activity进行处理。</p>
<p>这里也会碰到一个小问题：当一个Notification对象太大时（比如截图、未接来电等，Notification.contentView就很大，通过广播传播会出现data过大无法传输的问题），这时可以把Notification.contentView对象暂时保存在Application中，然后再置为null，Activity中接收到数据后，再进行赋值。</p>
<h3 id="2-2在Manifest中注册service">2.2在Manifest中注册service</h3><pre class="\"lang:java" decode:true\"="">&lt;service
            android:name=\".NotificationFetcherService\"
            android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\" &gt;
            &lt;intent-filter&gt;
                &lt;action android:name=\"android.accessibilityservice.AccessibilityService\" /&gt;
            &lt;/intent-filter&gt;

            &lt;meta-data
                android:name=\"android.accessibilityservice\"
                android:resource=\"@xml/accessibilityserviceconfig /&gt;
&lt;/service&gt;</pre>

<p>这里就是普通的service注册，注意 &lt;mate-data&gt;标签中的xml文件：从Android 4.0版本开始，有另外一种方法：使用XML文件来配置这类服务。如果你以XML的形式来定义你的服务，某些像canRetrieveWindowContent可配置的选项就可用了。和service一样的配置，使用XML来定义。如果你要使用XML路径，要在你的mainfest文件中指定它，在你的服务声明中添加&lt;meta-data&gt;标签,并指向这个XML资源文件。比如上面的代码，我们在res/xml/中建立accessibilityaseviceconfig.xml，内容如下：</p>
<pre class="\"lang:java" decode:true\"="">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;
&lt;accessibility-service xmlns:android=\"http://schemas.android.com/apk/res/android\"
    android:accessibilityEventTypes=\"typeWindowStateChanged|typeNotificationStateChanged|typeWindowContentChanged\"
    android:accessibilityFeedbackType=\"feedbackGeneric\"
/&gt;</pre>

<p>服务这里就配置好了。</p>
<h3 id="2-3_接受并处理Notification">2.3 接受并处理Notification</h3><p>下面的Activity中就可以接受这个数据，然后怎么处理就看自己了，这里只是简单地显示出来。</p>
<pre class="\"lang:java" decode:true\"="">import android.app.Activity;
import android.app.Application;
import android.app.Notification;
import android.app.PendingIntent;
import android.app.PendingIntent.CanceledException;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.Parcelable;
import android.os.Process;
import android.text.method.ScrollingMovementMethod;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.RemoteViews;
import android.widget.TextView;

public class NotificaitonActivity extends Activity {
    private static final int NOTIFY_DATA_FLAG = 1;
    private static final String NOTIFY_DATA_ID_STR= \"NotifyData\";

    private NotifyDataReceiver  receiver;
    private TextView textView;
    private LinearLayout rootLayout;
    private Button button;

    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);
        textView = (TextView) findViewById(R.id.notify_test_textview);
        textView.setMovementMethod(ScrollingMovementMethod.getInstance());
        rootLayout = (LinearLayout) findViewById(R.id.root_layout);

        registerBroadcast();

        button = (Button) findViewById(R.id.test_button);
        button.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Button b = new Button(NotificaitonActivity.this);
                b.setText(\"Tthis\");
                rootLayout.addView(b);
            }
        });
    }

    private void registerBroadcast() {
        receiver = new NotifyDataReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(\".NotificationFetcherService\");
        this.registerReceiver(receiver, filter);
        Log.e(\"Dx:\", \"Broadcast registered.........\");
    }

    private void addToUi(RemoteViews remoteView) {
        rootLayout.addView(remoteView);
    }

    private void showNotify(String notiString) {
        textView.setText(textView.getText() + \"n\" + notiString);
    }

    private class NotifyDataReceiver extends BroadcastReceiver{

        @Override
        public void onReceive(Context context, Intent intent) {
            Log.e(\"Dx:\", \"Receiver got msg in onReceive()...\");

            Parcelable notifyParcelable = intent.getParcelableExtra(\"NotifyData\");

            if (notifyParcelable != null) {

                Notification notification = (Notification) notifyParcelable;
                showNotify(\"tickerText: \" + notification.tickerText);
                showNotify(\"toString: \" + (String)(notification.toString()));

                RemoteViews remoteV = notification.contentView;
                if (remoteV==null) {
                    showNotify(\"remoteView is: null\" );
                } else {
                    showNotify(\"remoteView is: not null\" );

                    addToUi(remoteV);
                }

                PendingIntent pendIntent = notification.contentIntent;
                if (pendIntent==null) {
                    showNotify(\"pendIntent is: null\" );
                } else {
                showNotify(\"pendIntent is: not null\" );
                }

                showNotify(\"**************************\" );
                showNotify(\"                    \" );

            }

        }
    }

}</pre>

<p><span style="\"color:" #ff0000;\"="">注：这里有很重要的一点，由于AccessibilityService的特殊性，用户必须手动到设置-辅助功能中，打开对应的服务，我们才可以通过AccessibilityService获得对应的数据，这一点非常重要。</span></p>
<p>上面的Activity只是简单地显示Notification，关于更多Notification的操作，可以参考Notification这个类，其中重要的属性有：contentView，flags。要模拟真正的通知中心，还是要费一番功夫的。这里由于公司项目的保密，暂不提供对应的实现代码（其实得到Notification就已经成功了一半了），有兴趣的同学可以私下和我交流。</p>
<h2 id="3-总结和问题">3.总结和问题</h2><p>AccessibilityService的实战就讲到这里，这一篇博文也是拖了一段时间才写完的，也算是为前一段时间的项目做个了结。</p>
<p>项目中目前还存在的问题：</p>
<ol>
<li>无法获取安装这个应用之前的系统的Notification</li>
<li>得到的Notification对象没法保存在本地，所以这个服务被杀掉之后，所有的数据都会丢失。（试过用db4o这种对象数据库来进行存储，发现行不通）</li>
<li>对Android系统的Notification对象的行为模仿不够（有些系统的事件监听不到，比如usb的插拔、usb调试的开关等）</li>
</ol>
<p>上面的问题，如果你有好的想法，我们私下交流。</p>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-辅助性服务实战介绍">1.辅助性服务实战介绍</h2><p>上一篇文章介绍了什么是Accessibility以及简单的使用，这一篇文章就来讲讲如何使用Accessibility服务来创建一个简单的Android通知中心。Android中通知中心是一个系统层面的服务，负责显示应用和系统发来的通知（Notification，比如USB插入、选择输入法、未接来电、截图、天气信息、新闻推送等等）。在android4.3之前，一般的第三方应用是无法获取Notification list的（在Android4.3之后，有了一个新的接口,NotificationListenerService.getActiveNotifications(),可以获取当前的Notification）。但是利用Accessibility服务可以监听到各种事件的特性，可以开发一个第三方的通知中心，实现与系统通知栏类似的功能。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android:Ubuntu下执行Adb命令找不到设备]]></title>
    <link href="http://androidperformance.com/2014/03/25/ubuntu-adb-can-not-find-devices/"/>
    <id>http://androidperformance.com/2014/03/25/ubuntu-adb-can-not-find-devices/</id>
    <published>2014-03-25T03:15:17.000Z</published>
    <updated>2015-03-27T05:25:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-问题概述">1.问题概述</h2><p><span style="color: #000000;">最近开发Nokia项目，遇到的问题如下：</span></p>
<p><span style="color: #000000;">插入Nokia x后，电脑没有反应，即不识别，同事的windows也不识别，最后在谷歌上搜索了良久，才找到了解决方案，但是没有记录，后来又要给别人配置的时候，发现忘记怎么配置了。想想这也是一个具有通性的问题，还是记录下来，分享给大家。</span></p>
<h2 id="2-问题解决方案">2.问题解决方案</h2><p><span style="color: #000000;">首先问题是：执行adb命令提示找不到设备，在做其他操作之前，请先确认已经做了如下操作：</span></p>
<ol>
<li><span style="color: #000000;">确定已经打开了USB调试选项（设置-开发者选项-USB调试），有的机器没有开发者选项，需要到关于里面点击版本号若干下，或者去百度谷歌。</span></li>
<li><span style="color: #000000;">确定使用sudo命令adb kill-server 和adb start-server后仍然没有用。</span><br><span style="color: #000000;">如果上述操作都确认了，还是找不到设备，那么继续往下看：</span></li>
</ol>
<a id="more"></a>
<h3 id="2-1-运行lsusb"><span style="color: #000000;">2.1.运行lsusb</span></h3><pre class="lang:java decode:true">~ » lsusb                                                                  
Bus 002 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 003 Device 004: ID 1532:0016 Razer USA, Ltd DeathAdder Mouse
Bus 003 Device 003: ID 05d5:624c Super Gate Technology Co., Ltd 
Bus 003 Device 033: ID 0421:06e8 Nokia Mobile Phones 
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hu</pre>

<h3 id="2-2-注册到udve的rules文件"><span style="color: #000000;">2.2.注册到udve的rules文件</span></h3><pre class="lang:java decode:true">vim  /etc/udev/rules.d/51-android.rules    
添加这个ID：1ebf，如下：    
SUBSYSTEM=="usb", SYSFS{"Nokia Mobile Phones"}=="0421", MODE="06e8"   
保存文件并运行：    
sudo chmod a+rx /etc/udev/rules.d/51-android.rules    
sudo /etc/init.d/udev restart    
运行结果如下：    
Rather than invoking init scripts through /etc/init.d, use the service(8)    
utility, e.g. service udev restart    
Since the script you are attempting to invoke has been converted to an    
Upstart job, you may also use the stop(8) and then start(8) utilities,    
e.g. stop udev ; start udev. The restart(8) utility is also available.    
udev stop/waiting    
udev start/running, process 14636</pre>

<h3 id="2-3-使用sudo_关闭和启动adb"><span style="color: #000000;"> 2.3.使用sudo 关闭和启动adb</span></h3><p><pre class="lang:java decode:true">cd ~/tools/android-sdk-linux_x86/platform-tools<br>sudo ./adb kill-server<br>sudo ./adb start-server</pre><br><span style="color: #000000;"><span style="color: #ff0000;"> 注：一般情况下，上面的操作就可以。特殊情况下，usb设备还是不能被识别，比如我手上这台Nokia X</span>。那么继续：</span></p>
<h3 id="2-4-打开_～/-android/adb_usb-ini，加入之前的lsusb得到的信息"><span style="color: #000000;">2.4.打开 ～/.android/adb_usb.ini，加入之前的lsusb得到的信息</span></h3><p><pre class="lang:java decode:true"># ANDROID 4RD PARTY USB VENDOR ID LIST — DO NOT EDIT.</pre></p>
<h1 id="USE_‘android_update_adb’_TO_GENERATE-">USE ‘android update adb’ TO GENERATE.</h1><h1 id="1_USB_VENDOR_ID_PER_LINE">1 USB VENDOR ID PER LINE</h1><h1 id="for_nokia_x">for nokia x</h1><p>0x0421<br><span style="color: #000000;"> 保存关闭后，就可以识别了。windows下也是如此，不多叙述了。</span></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-问题概述">1.问题概述</h2><p><span style="color: #000000;">最近开发Nokia项目，遇到的问题如下：</span></p>
<p><span style="color: #000000;">插入Nokia x后，电脑没有反应，即不识别，同事的windows也不识别，最后在谷歌上搜索了良久，才找到了解决方案，但是没有记录，后来又要给别人配置的时候，发现忘记怎么配置了。想想这也是一个具有通性的问题，还是记录下来，分享给大家。</span></p>
<h2 id="2-问题解决方案">2.问题解决方案</h2><p><span style="color: #000000;">首先问题是：执行adb命令提示找不到设备，在做其他操作之前，请先确认已经做了如下操作：</span></p>
<ol>
<li><span style="color: #000000;">确定已经打开了USB调试选项（设置-开发者选项-USB调试），有的机器没有开发者选项，需要到关于里面点击版本号若干下，或者去百度谷歌。</span></li>
<li><span style="color: #000000;">确定使用sudo命令adb kill-server 和adb start-server后仍然没有用。</span><br><span style="color: #000000;">如果上述操作都确认了，还是找不到设备，那么继续往下看：</span></li>
</ol>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Linux" scheme="http://androidperformance.com/categories/Android/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Service：开发自己的通知中心(1):辅助性服务介绍]]></title>
    <link href="http://androidperformance.com/2014/03/17/android-build-your-own-android-notification-service-app/"/>
    <id>http://androidperformance.com/2014/03/17/android-build-your-own-android-notification-service-app/</id>
    <published>2014-03-17T06:07:53.000Z</published>
    <updated>2015-03-27T05:26:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id=""> </h2><h1 id="1_辅助性服务介绍">1 辅助性服务介绍</h1><p>辅助性服务是安卓框架的一个特性，它的设计是为了让已经安装在安卓设备上的应用程序能够为用户提供一种导航式(引导式）回应。一个辅助性服务能够传达给<br>用户关于这个应用程序的利益，例如把文本转换成语音、当用户手指停留屏幕的一个重要区域时的haptic反馈。这一节涵盖了怎样去创建一个辅助性服务，如何处理应用程序的信息接收，还有如何把信息反馈给用户。<br>创建自己的辅助性服务</p>
<a id="more"></a>
<h1 id="2_创建自己的辅助性服务">2 创建自己的辅助性服务</h1><h2 id="2-1_继承AccessibilitySerivce">2.1 继承AccessibilitySerivce</h2><p>一个辅助性服务可以被捆绑到一个标准的应用程序上，或者以一个单独的安卓工程被创建。在任何情况下，创建这类服务的步骤都是一样的。在你的工程中，创建一个类继续AccessibilitySerivce。</p>
<pre class="\"lang:java" decode:true\"="" title="\"继承AccessibilityService\"">package com.example.android.apis.accessibility;

import android.accessibilityservice.AccessibilityService;

public class MyAccessibilityService extends AccessibilityService {
...
    @Override
    public void onAccessibilityEvent(AccessibilityEvent event) {
    }

    @Override
    public void onInterrupt() {
    }

...
}</pre>

<p>&nbsp;</p>
<h2 id="2-2_在mainfest中声明service">2.2 在mainfest中声明service</h2><p>像其他服务一样，你也可以在mainfest文件中声明它。记得要指定它处理android.accessibilityservice这个意图。以便当应用程序触发一个AccessibilityEvent时，这个服务能被调用。</p>
<pre class="\"lang:java" decode:true\"="" title="\"进行配置\"">&lt;application ...&gt;
...
&lt;service android:name=\".MyAccessibilityService\"&gt;
     &lt;intent-filter&gt;
         &lt;action android:name=\"android.accessibilityservice.AccessibilityService\" /&gt;
     &lt;/intent-filter&gt;
     . . .
&lt;/service&gt;
...
&lt;/application&gt;</pre>

<p>&nbsp;</p>
<h2 id="2-3_配置serivce">2.3 配置serivce</h2><p>如果你为这个服务创建一个新的工程的话，且不打算要一个应用程序，你可以把它启动活动的类（通常叫做MainActivity.java)从你的源文件中删除。同时也把相应的活动元素从你的mainfest文件中删除。<br>配置自己的辅助性服务<br>为你的辅助性服务设置配置变量，用它来告诉系统，如何和何时你想要它运行。哪一类事件你想要去响应？这个服务对所有的应用程序都是活动的吗？或者只有指定的包名的？它使用什么样的反馈？<br>你有两种方法去设置这些变量。反向兼容的方法是以代码的形式来设置它们。<br>可以使setServiceInfo(android.accessibilityservice.AccessibilityServiceInfo).如果要这样做的话，要重写onServiceConnected()方法，然后配置在那里配置你的服务。</p>
<pre class="\"lang:java" decode:true\"=""> 
@Override
public void onServiceConnected() {
    // Set the type of events that this service wants to listen to.  Others
    // won\'t be passed to this service.
    info.eventTypes = AccessibilityEvent.TYPE_VIEW_CLICKED |
            AccessibilityEvent.TYPE_VIEW_FOCUSED;

    // If you only want this service to work with specific applications, set their
    // package names here.  Otherwise, when the service is activated, it will listen
    // to events from all applications.
    info.packageNames = new String[]
            {\"com.example.android.myFirstApp\", \"com.example.android.mySecondApp\"};

    // Set the type of feedback your service will provide.
    info.feedbackType = AccessibilityServiceInfo.FEEDBACK_SPOKEN;

    // Default services are invoked only if no package-specific ones are present
    // for the type of AccessibilityEvent generated.  This service *is*
    // application-specific, so the flag isn\'t necessary.  If this was a
    // general-purpose service, it would be worth considering setting the
    // DEFAULT flag.

    // info.flags = AccessibilityServiceInfo.DEFAULT;

    info.notificationTimeout = 100;

    this.setServiceInfo(info);

}</pre>

<p>从Android 4.0版本开始，有另外一种方法：使用XML文件来配置这类服务。如果你以XML的形式来定义你的服务，某些像canRetrieveWindowContent可配置的选项就可用了。和上面一样的配置，使用XML来定义，格式如下所示：</p>
<pre class="\"lang:java" decode:true\"="">&lt;accessibility-service
     android:accessibilityEventTypes=\"typeViewClicked|typeViewFocused\"
     android:packageNames=\"com.example.android.myFirstApp, com.example.android.mySecondApp\"
     android:accessibilityFeedbackType=\"feedbackSpoken\"
     android:notificationTimeout=\"100\"
     android:settingsActivity=\"com.example.android.apis.accessibility.TestBackActivity\"
     android:canRetrieveWindowContent=\"true\"
/&gt;</pre>

<p>如果你要使用XML路径，要在你的mainfest文件中指定它，在你的服务声明中添加&lt;meta-data&gt;标签,并指向这个XML资源文件。假如你把你的XML文件存储在res/xml/serviceconfig.xml这个路径下，新的标签格式如下所示：</p>
<pre class="\"lang:java" decode:true\"="">&lt;service android:name=\".MyAccessibilityService\"&gt;
     &lt;intent-filter&gt;
         &lt;action android:name=\"android.accessibilityservice.AccessibilityService\" /&gt;
     &lt;/intent-filter&gt;
     &lt;meta-data android:name=\"android.accessibilityservice\"
     android:resource=\"@xml/serviceconfig\" /&gt;
&lt;/service&gt;</pre>

<p>&nbsp;</p>
<h2 id="2-4_响应AccessibilityEvents事件">2.4 响应AccessibilityEvents事件</h2><p>现在,您的服务被设置为运行和监听事件，写一些代码，这样当一个AccessibilityEvent真的到来，它就知道要做什么了！<br>从重写onAccessibilityEvent(AccessibilityEvent)方法开始。然后使用getEventType()来确定事件类型，然后用getContentDescription来取出任何与触发事件相关的标签文本。</p>
<pre class="\"lang:java" decode:true\"=""> 
@Override
public void onAccessibilityEvent(AccessibilityEvent event) {
    final int eventType = event.getEventType();
    String eventText = null;
    switch(eventType) {
        case AccessibilityEvent.TYPE_VIEW_CLICKED:
            eventText = \"Focused: \";
            break;
        case AccessibilityEvent.TYPE_VIEW_FOCUSED:
            eventText = \"Focused: \";
            break;
    }

    eventText = eventText + event.getContentDescription();

    // Do something nifty with this text, like speak the composed string
    // back to the user.
    speakToUser(eventText);
    ...
}</pre>

<p>为更多的上下文查询视图层次结构<br>这一步是可选的，然而它非常有用。Android 4.0(API level 14)的一个新特性：可以用AccessibilityService来查询视图层次结构，收集事件所生成的一些UI组件信息，还有这些UI的父控件和子控件。要做到这一点，确保在你的XML配置文件中做了如下设置：</p>
<pre class="\"lang:java" decode:true\"="">android:canRetrieveWindowContent=\"true\"</pre>

<p>如果设置了，通过getSource()可获得一个AccessibilityNodeInfo对象。如果发起的窗口事件仍然是活动的窗口，该调用将会返回一个对象,否则，会返回null。下面这段代码演示何时接收一个事件，步骤如下：<br>立即捕获触发事件的父视图。<br>在那个视图中，寻找一个标签和一个复选框作的子视图。<br>如果找到，创建一个字符串来向用户报告，以表明这个标签是否被选择了。<br>如果遍历视图层次结构后返回null,则会退出该方法。</p>
<pre class="\"lang:java" decode:true\"=""> 
// Alternative onAccessibilityEvent, that uses AccessibilityNodeInfo

@Override
public void onAccessibilityEvent(AccessibilityEvent event) {

    AccessibilityNodeInfo source = event.getSource();
    if (source == null) {
        return;
    }

    // Grab the parent of the view that fired the event.
    AccessibilityNodeInfo rowNode = getListItemNodeInfo(source);
    if (rowNode == null) {
        return;
    }

    // Using this parent, get references to both child nodes, the label and the checkbox.
    AccessibilityNodeInfo labelNode = rowNode.getChild(0);
    if (labelNode == null) {
        rowNode.recycle();
        return;
    }

    AccessibilityNodeInfo completeNode = rowNode.getChild(1);
    if (completeNode == null) {
        rowNode.recycle();
        return;
    }

    // Determine what the task is and whether or not it\'s complete, based on
    // the text inside the label, and the state of the check-box.
    if (rowNode.getChildCount() &lt; 2 || !rowNode.getChild(1).isCheckable()) {
        rowNode.recycle();
        return;
    }

    CharSequence taskLabel = labelNode.getText();
    final boolean isComplete = completeNode.isChecked();
    String completeStr = null;

    if (isComplete) {
        completeStr = getString(R.string.checked);
    } else {
        completeStr = getString(R.string.not_checked);
    }
    String reportStr = taskLabel + completeStr;
    speakToUser(reportStr);
}</pre>

<p>现在你有一个完整的，可以工作的辅助性服务。现在，你也可以试着配置一下，看看Android的text-to-speech engine,或使用Vibrator提供触觉反馈是如何与用户交互。</p>
<p>最后，要使用配置好的service，必须要到“设置—辅助性服务”中打开对应的service，然后才能相应对应的事件。</p>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id=""> </h2><h1 id="1_辅助性服务介绍">1 辅助性服务介绍</h1><p>辅助性服务是安卓框架的一个特性，它的设计是为了让已经安装在安卓设备上的应用程序能够为用户提供一种导航式(引导式）回应。一个辅助性服务能够传达给<br>用户关于这个应用程序的利益，例如把文本转换成语音、当用户手指停留屏幕的一个重要区域时的haptic反馈。这一节涵盖了怎样去创建一个辅助性服务，如何处理应用程序的信息接收，还有如何把信息反馈给用户。<br>创建自己的辅助性服务</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[大学 毕业 工作]]></title>
    <link href="http://androidperformance.com/2014/03/01/life-and-college-about-gracker/"/>
    <id>http://androidperformance.com/2014/03/01/life-and-college-about-gracker/</id>
    <published>2014-03-01T12:22:47.000Z</published>
    <updated>2015-03-27T05:24:41.000Z</updated>
    <content type="html"><![CDATA[<p>我是一个喜欢总结并且做计划的人。从我知道如何规划自己到现在，我做了无数的计划，这些计划雄心勃勃，大有上五天揽月下五洋捉鳖之势，仿佛自己就是救世主，亿万人民等着我去拯救。但现实总是那么的残酷，我做的计划很少有能够坚持下来并完成的，以至于大家都亲切地叫我：“三分钟热情”，每思及此，也没啥好的办法。还好每个人都有自己的缺点，也都有自己的优点，而且随着时间的变化，人也是会变的。这篇博客摘录了我大学期间，大学毕业，工作了一段时间三个时期的个人总结：变的是心态，是年龄，不变的是激情，是梦想。</p>
<p>第一篇是大三开学之前在学校的实验室写的，那个夏天去了大连东软进行实训，为期半个月左右，具体做了什么忘记了，就记得大连的雨，一下就是好几天。实训结束后为没有回家，直接搬了床和被子在实验室住下了。每天和看实验室的大爷做斗争，晚上一个人睡觉，饿了就煮泡面，现在想来，那段日子真是惬意。然后快开学的时候，写了这篇总结（最后一句真是亮瞎我的24K氪金狗眼阿）：</p>
<a id="more"></a>
<blockquote>
<p>转眼间，就已经是大三的人了，由于我们专业的教学计划与别的专业不同，我们在学校待的时间只有3年。也就是说，这是我在大学的最后一年了。</p>
<p>回顾前两年，从大一的迷茫，到大二的雄心壮志，一步步走来，对大学的理解也越来越深，对自己的了解也越来越深。大学里的学习完全要靠自己。师傅领进门修行在个人，古人说话不是没有道理的。</p>
<p>一直期待的大连实训，回来以后我觉得很失望，不是对住宿环境的不满，不是对大连见不到太阳的抱怨，而是对实训内容的失望：先是实训时间被削减，拉过去先听两年后才用得上的各种公司礼仪和处事方式，然后把大家圈在一起像做课程设计一样做一个被阉割过的项目。没有参与设计，需求分析什么的都是现成的，没有详细设计，写完代码补文档……总之就是有些失望，算了，还是要靠自己么。</p>
<p>从大连回来已经十天了，每天都在实验室宅着。这十天可以说是什么都没有做，看视频，看照片，玩游戏，就是没有看书和写代码。我突然意识到，这样的生活要是再持续下去，这个暑假我将一事无成：实训已经浪费了半个月了，难道我还要浪费时间？不行，不能再浪费时间了。我已经没有多少时间挥霍了。</p>
<p>我琢磨了一下，这个假期我还有三件事要完成：完成我们的齐鲁软件设计大赛的项目，实验室的两个android项目。二十八号开学，还有二十天，抓点紧，一定要完成！！！</p>
<p>昨天我喝水的杯子掉在地上打碎了，没有水喝了，也算是我安逸生活的一个结束，给自己一个惊醒把！（杯子应该会再去买一个，要不代码没写先渴死了就划不来了）。</p>
<p>总之，就要大三了，不能再像以前那样对自己不负责任了。</p>
<p>为了自己的将来，也为了我可爱的女朋友阿春，也为了我的父母的期待，为了所有关心我的同学们，朋友们，我不会辜负你们的。</p>
<p>最后用himi的座右铭：不要让任何事情成为你不去学习的理由！</p>
<p>加油吧！见证一个大神崛起的时刻到了！<br>第二篇总结是大四毕业后，即将入职的前一天写的，刚刚毕业，正直雄心壮志之时，当然脑子也比较混乱，便写下了这篇：<br>明天就入职了。</p>
<p>大学毕业半个月了，这半个月基本没有做什么事，于是看看书，顺便反省一下自己。</p>
<p>说到看书，我还是很喜欢看书的，历史，奇幻，人物传记，美食，旅游……都是我的最爱，技术书也买了不少，不过说来惭愧，技术书买得多，看完的不多。最近在Kindle上面看完了14本书，没有一本是技术书。这让我觉得，自己看书的方法还是不对，有点杂，什么都想去看，最后只把自己感兴趣的看了，其他的脑子一时热乎买得书反而没看几页。惭愧惭愧。前两天看Feng的小道消息，说到加班，说程序员加班归根结底还是一个效率的问题，程序员的效率其实并不高，但自己又没有发现，其中一个原因是程序员的工作很难去量化。比如一个问题，可能想不明白的时候，两三天都没用进展，结果吃午饭的时候突然就开窍了，于是三下五除二，问题迎刃而解。所以我联想到我看书的经过，还是没有去量化我的看书量，或者说是没有量化学习进度。想学某个东西，然后买了相关资料，看了几天就放下了，没有计划，没有量化，也就没有压力，没有动力。人都是容易懒散的动物，大家都想吃饱喝足去冬眠，没人想在冬天里打猎。</p>
<p>既然提到了量化，那就说说什么是量化。百度百科里这样说：日常生活中所说的“量化”：指的是目标或任务具体明确，可以清晰度量。根据不同情况，表现为数量多少，具体的统计数字，范围衡量，时间长度等等。例如，四万亿支出，960万平方公里，八个小时，完成任务……具体到学习上，比如说你要学英语，然后每天抱着单词本背单词，听英语原文，但是如果没有合适的计划，热情很快就会退却，最后不了了之。然则如果你将学英语这件事量化，比如每天背多少个单词，听多少篇原文，几个月后过四六级。量化之后每天就有了目标，今天哪些没有做完，就马上去做完它。</p>
<p>明天就要去入职了，大学一晃四年过去了。到现在还没有什么职业规划，之前想的是先干两年，然后再跳槽或者进行新的规划，至于这两年怎么过，要达到什么目标，学到什么知识，都一概没有想法和概念。我想是时候好好规划规划了，不能再像以前那样，做一个无头苍蝇。也不能看到什么好的技术就要去学。看到这篇文章的过来人，也可以教教我，怎么进行职业规划，怎么进行选择，在下感激不尽。</p>
<p>总之，梦想是要启航了，不管前方大风大浪，我无所畏惧！！<br>第三篇在2013年的年底写的，从七月份入职，到九月份跳槽，再到12月份离职，再到找到新的工作，这半年突出一个折腾。但是折腾并非没有好处，一辈子很短，再不折腾，就过去了：</p>
<div> 2013注定是不平凡的一年，也是我难以忘记的 一年。一年前的今天，我还在htc，收拾了一下自己的小屋子，发了条微博：新年新气象。12年的八月份份开始正式在htc实习，那是大四的第一学期，宣告着大学时代的终结。</div>

<div>大学三年有很多值得怀念的事情，一群好基友，一个漂亮的女朋友，一个最适宜居住的城市，一段一段难忘的记忆，当这一切都成为美好的记忆后，才发现时光飞速，转眼我已经离开威海，远赴魔都，当然，阿春和我一起。</div>

<div>和htc签的实习协议，是整个大四在htc实习，13年五月左右回去做毕业设计。HTC的生活还是蛮单调的，早上八点起床，九点左右到公司，工作到12点，吃午饭，工作到六点，晚饭，然后加班到大概八点。这几乎就是每个工作日的流程。实习期间也没多少钱，也就不怎么出去玩，最大的乐趣就是做饭和打dota。这期间还有一个小插曲，我们几个小愤青，一度想回去自己创业，最后不了了之。现在想想，那会还是太冲动了，没有想清楚，就去做，执行力也很差，技术也不过硬，诶，说多了都是泪。</div>

<div>13年过年，请了一个月假回家过年，实习生就是爽，今年过年就没有那么充裕的时间了。由于要回去学车，我和阿春过了年回公司呆一个月就回学校了。回学校的日子各种爽，没课，就是玩，毕业设计很轻松，学车的时候略苦逼，结果科目二还没有考过，留下了一个大遗憾。7月份准时毕业，拿了优秀论文。</div>

<div>回顾大学四年，没有什么遗憾，该做的都做了，玩的也很爽，技术上不是大牛，但也在平均水平之上，有一大群好哥们，虽然毕业后大家各奔东西，但这四年的友情，却比什么都重要，拜拜，大学，我要去另一所大学，学习真正的东西了。</div>

<div>七月到九月，是在htc正式工作的时间，工作时间之短，我自己都没有想到。注定不安分的我，跳槽到了一家创业公司，做视频导航，在徐家汇（我住在浦东），和孔先生一起去的。九月到十一月，在这家公司短短的两个月，真真切切学到了很多东西，接触到了很多东西，认识了一群有激情有理想有技术的人，最后的离开也很纠结，原因很多，上班比较远也是一方面。裸辞后，在家里呆了一段时间，一是保养一下身体，前一段时间身体差了很多，二是停下来想想，自己到底喜欢什么，想做什么，什么样的公司适合自己。最后思考的结果是：进一家移动互联网公司，规模不能太小，50-100人左右，有激情，有喜欢做的事。这时候乐蛙进入了视线，调研，准备，去面试，被录用，入职，上手工作，一切很顺利。12月11号正式入职，这是我的第三份工作。至今还没有告诉老妈这事，反正老妈也不知道我在上海哪个公司。以后混好了再说吧。现在回头想想，2013年的后半年，真心太折腾了。跳来跳去的，工资没有涨多少，经验也没有往深度积累多少，就是凭着自己那股折腾劲，到处乱闯，像个无头的苍蝇。有收获，也有损失。非常感谢阿春在背后的支持，不管我做什么决定，她都在背后坚定不移地支持我，鼓励我，即使那个决定是很鲁莽地，没有她的支持，我也走不到今天。</div>

<div></div>

<div>新公司叫乐蛙，是一个年轻的公司，有一群充满激情的人。</div>

<div>bye bye，2013</div>

<div>hello ，2014</div><br><div>三篇总结，每次我翻看这些存储在我笔记里面的文字的时候，都会被当时的我感动，当时的我很清楚自己做了什么，做错了什么，要做什么。有的事情现在还没有做，有的事情不知不觉中已经完成。我很高兴地发现，在我生活的每一个时期，激情和梦想都时刻伴随着我，同样伴随着我的还有阿春，不管我怎样折腾，她都在背后默默地支持我，谢谢你。</div><br><div></div><br><div>另：昨天看书，记了两条笔记：</div><br><div>关心你的技艺。care about your craft</div>

<div>思考！你的工作。 think ，about your work</div><br><div>大家自己感受一下。</div><br><div></div></blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>我是一个喜欢总结并且做计划的人。从我知道如何规划自己到现在，我做了无数的计划，这些计划雄心勃勃，大有上五天揽月下五洋捉鳖之势，仿佛自己就是救世主，亿万人民等着我去拯救。但现实总是那么的残酷，我做的计划很少有能够坚持下来并完成的，以至于大家都亲切地叫我：“三分钟热情”，每思及此，也没啥好的办法。还好每个人都有自己的缺点，也都有自己的优点，而且随着时间的变化，人也是会变的。这篇博客摘录了我大学期间，大学毕业，工作了一段时间三个时期的个人总结：变的是心态，是年龄，不变的是激情，是梦想。</p>
<p>第一篇是大三开学之前在学校的实验室写的，那个夏天去了大连东软进行实训，为期半个月左右，具体做了什么忘记了，就记得大连的雨，一下就是好几天。实训结束后为没有回家，直接搬了床和被子在实验室住下了。每天和看实验室的大爷做斗争，晚上一个人睡觉，饿了就煮泡面，现在想来，那段日子真是惬意。然后快开学的时候，写了这篇总结（最后一句真是亮瞎我的24K氪金狗眼阿）：</p>]]>
    
    </summary>
    
      <category term="生活感悟" scheme="http://androidperformance.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Wordpress建立个人独立博客]]></title>
    <link href="http://androidperformance.com/2014/02/26/build-your-own-blog-by-wordpress/"/>
    <id>http://androidperformance.com/2014/02/26/build-your-own-blog-by-wordpress/</id>
    <published>2014-02-26T02:27:21.000Z</published>
    <updated>2015-03-27T05:20:57.000Z</updated>
    <content type="html"><![CDATA[<p><a href="\"><img src="\" alt="\"></a></p>
<p>配图来自网络。</p>
<h1 id="个人吐槽阶段">个人吐槽阶段</h1><p>说到建立独立博客，很多人都很不屑地说，CSDN、博客园不是也提供博客地址么？为什么要花这么大力气，自己搭建一个博客呢？举个不太恰当的例子，很多人刚毕业没钱，在外边租房子，提供租房服务的很多，一租好几年，但每个人都想拥有自己的房子。这独立博客就相当于自己的房子，自己的房子用起来，当然就要比租的房子用起来要那么用心一点，有空就搞个装修啊，买点家具啊，修个游泳池啊（想多了），养点花花草草猫猫狗狗之类的。租的房子，能住人绝对不养狗，能叫外面绝对不下厨。不能比啊不能比，这是个态度问题。</p>
<h1 id="准备阶段">准备阶段</h1><p>废话说了这么多，还是尽快切入主题。说到个人建站，网上教程一堆一堆的，我自然也不会自己一个一个地去摸索。我主要参考的文章是Mac君的《趣谈个人建站》：<a href="\" title="\">http://macshuo.com/?p=547</a>。Mac君使用的是godaddy+ubuntu+linode。而我的不一样的点是我在国内买的域名：阿里云万网：<a href="\" title="\">http://www.net.cn/</a>。下面的内容大部分都来自Mac君的博文《趣谈个人建站》：<a href="\" title="\">http://macshuo.com/?p=547</a>。</p>
<p>重复造轮子的行为是不被大家认可的，但我这里还是要重复造轮子，原因如下：1.本人的部分步骤和原文不太一样，直接说哪里哪里不一样，会有点麻烦。 2.原文中有些没有涉及到的东西，我会在这里讲清楚，因为我跟着他的步骤走的时候，有时候会掉到坑里，爬很久才出来。 3.各位想建站的同学可以直接跟着本文的教程就可以建好，不必再切来切去。里面红色的部分是我的注释，是我遇到的问题和解决办法，希望大家别再入黑胡同。</p>
<p>搭建个人站点，大致需要做这么几件事情：</p>
<ul>
<li>一台具备公网IP的服务器</li>
<li>安装操作系统，搭建环境</li>
<li>购买域名，域名绑定IP</li>
<li>部署应用程序</li>
</ul>
<p>基本上这四套组合拳打完，你的个人网站就算建起来了，后续的事情就是添砖加瓦和蓬荜生辉了。</p>
<a id="more"></a>
<p>好把我们依次介绍：</p>
<h1 id="服务器">服务器</h1><p>大部分公司都会有自己的服务器和公网IP，要么托管要么自建机房。但对于个人用户来说，就没必要费时费力做这个事情了，购买一个VPS（Virtual Private Server）即可。什么是VPS，建议大家去维基百科上查一下，简单来说就是你会拥有一台虚拟主机，除了看不见机箱之外，你可以像操作一台实体服务器那样操作它，独立操作系统和硬盘空间、独立内存和CPU资源、独立的执行程序和系统配置等，可以自己安装操作系统和软件，独立重启等等。</p>
<p>在VPS的选择上，我用的是Linode。Linode是一家来自于米帝的专注于提供 Linux VPS 的服务提供商， 虚拟化技术采用了Xen，Linode的含义是Linux Node。注意，这里的操作系统是Linux，我推荐所有个人建站都采用Linux，不解释，如果你想采用Windows Server，后面的内容就不用看了。</p>
<p>Linode在国内外口碑都不错，价格适中，质量可靠，童叟无欺。Linode提供了各种Linux操作系统供选择，比如Ubuntu、Redhat、Debian、CentOS等等，装系统和重装系统都非常简单。</p>
<p>好，我们下面简单说一下步骤，访问<a href="\" title="\">https://manager.linode.com/session/signup</a><br>填写邮箱、用户名密码，就算注册成功了，Linode会给你发封邮件确认，打开那个确认链接，剩下的大家都会。</p>
<p>Linode通过它的ticket system（一套支持系统）提供7 x 24 x 365的支持服务，看清楚，不是7 x 24 x 365的不停机服务，我现在特别烦一些企业客户，一谈就说永不宕机，特么除了上帝谁能保证永不宕机？时间长了自个都得宕！另外Linode还提供了4小时的免费试用服务，比较厚道，如果你试试觉得不爽还可以选择不玩。</p>
<p>选择继续，就可以选机房了，Linode目前提供了东京和欧美等地的机房选择，我选了东京机房，据说是针对亚太地区用户的需求新开辟的，速度很快。然后选操作系统，设置硬盘大小、root密码等，点击「Rebuild」，你就进入了VPS的控制台，等Host Job Queue的所有任务都是绿色的Success，就可以点击「Boot」，启动系统。然后找到Remote Access这个标签，点进去就可以找到这台服务器的访问IP，打开终端，输入ssh root@x.x.x.x，就可以登录系统了，看到了吧，very simple！<span style="\"color:" #ff6600;\"="">（现在Linode已经不提供免费试用服务了，你只能先付款，然后才能使用。不过可以七天内退款）</span></p>
<p>试用之后，如果你觉得可以，点击Account标签，完善自己的信息，选择服务器配置，支付信息，然后就可以完整支付流程了。</p>
<p>我选的是Linode 1024套餐（24 GB DISK, 2000 GB），按照年付费的话230刀左右，大家这两天赞助的碎银子，差不过够一年年费了：）支付方式包括Visa，MasterCard，American Express，只有要信用卡还是很方便的。</p>
<p>另外需要注意的一点是，拿到了IP之后，一定要在不翻##墙的情况下测试一下是否可以正常访问。我就遇到这个问题了，在国内没法访问，但是挂了VPN的就可以，我估计是哪个倒霉孩子以前用过，被墙之后不用了。</p>
<p>不得已我发起了一个Ticket（支持问题），说我在中国大陆不能访问这个IP，但通过VPN可以，那哥们响应倒是挺快，但显然不懂我朝行情，让我执行mtr –r x.x.x.x，mtr可以结合ping、nslookup、tracert诊断网络传输问题。我只得把数据返给他，结果人家还要其他数据，我就不耐烦了，用蹩脚的英文给丫解释了一下什么是伟大的墙，基本意思就是少特么废话，赶紧给我换个IP。那哥们看我气势挺盛，赶紧给我换了个IP，我一试没问题了，说了声三克油，他说威尔卡姆，这事算结了。两人共交手五个回合，用时2小时，效率还可以。</p>
<p>好，服务器部分就介绍到这里。以下是我的linode推荐码，如果大家要购买Linode服务，可以用这个链接。</p>
<p><a href="\">http://www.linode.com/?r=6bd100da844d8d2c191680a4792610467ce9052</a></p>
<p><span style="\"color:" #ff6600;\"="">（上面的是Mac君的推荐码，我的推荐码是: a96df99ce34b5e0f76695558608c87fb2db5cc03。推荐链接是：<a href="https://www.linode.com/?r=a96df99ce34b5e0f76695558608c87fb2db5cc03" target="_blank" rel="external">https://www.linode.com/?r=a96df99ce34b5e0f76695558608c87fb2db5cc03</a></span>）</p>
<hr>
<h1 id="搭建环境">搭建环境</h1><blockquote>
<p>我选用的服务器是Ubuntu12.04，64位。以下内容均基于该环境描述。</p>
</blockquote>
<p>拿到了主机IP，你就算拿到了新房的钥匙，但是离入住还远着呢，因为你那个主机现在就是个毛坯房，除了进去看看，什么都不能干。好，下面我们做一下简装修。</p>
<p>1、创建用户</p>
<p>第一次登录需要root用户，什么是root？root就是整个Linux操作系统最牛逼的主，他想干嘛就干嘛，他想删谁就删谁，他是光他是电他是唯一的神话，他就是我朝就是我D，所以非常危险，你们懂的。如果用root执行一下rm -rf，那整个锡安就会被抹掉，尼奥也拯救不了，如果root愿意，他可以抹掉你曾经存在过的所有痕迹。所以，我们不能没事就用root进去耍，为了解决这个问题，我们必须要建立一个agent，平时是普通用户，关键时刻充当root的角色。</p>
<p>具体操作如下：</p>
<p>首先用root登录系统</p>
<pre><code>ssh root@x.x.x.x`&lt;/pre&gt;

创建一个新用户，用户名随你喜欢，比如叫做mactalk

&lt;pre&gt;`adduser mactalk`&lt;/pre&gt;

按照提示信息输入密码和相关信息，就可以完成操作。完成之后系统就会自动建立/home/mactalk路径。

然后是授权，输入

&lt;pre&gt;`visudo`&lt;/pre&gt;

在编辑器中找到如下内容：

&lt;pre&gt;`root    ALL=(ALL:ALL) ALL`&lt;/pre&gt;

在下面加一行

&lt;pre&gt;`mactalk    ALL=(ALL:ALL) ALL`&lt;/pre&gt;

通过ctrl+x保存退出即可。然后就可以退出root，用mactalk重新登录（ssh mactalk@x.x.x.x），登录进来默认目录在/home/mactalk下，当你想行使root权限时，请在命令之前增加sudo，按照系统提示输入密码即可执行操作。

2、选择<span class="keyword">shell</span>

用户建好了，下面我们为用户选择一种<span class="keyword">shell</span>，估计小白看到这个又毛了，啥是<span class="keyword">shell</span>？

<span class="keyword">shell</span>就是Linux的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序。比如你对<span class="keyword">shell</span>说，「你好」，<span class="keyword">shell</span>就跑到内核那说，「老大，有人问候你呢」，内核就不耐烦的说，「有事说事，我特么忙着呢」，<span class="keyword">shell</span>就把这条信息反馈给你，大致就是这样。以前讲<span class="keyword">Mac</span>技巧的时候，经常跟大家说在终端里输入一些命令，那就是<span class="keyword">Mac</span>的<span class="keyword">shell</span>，都是一脉相承的。

Linux提供了很多种<span class="keyword">Shell</span>，你要问我为什么要有这么多，我只能告诉你，你为毛同类型的衣服有那么多件？花色，质地还不一样。写程序比买衣服复杂多了，而且程序员是不惮于把事情搞复杂的，牛程序员看到不爽的<span class="keyword">shell</span>，就会自己重新写一套，慢慢形成了一些标准，常用的<span class="keyword">shell</span>有这么几种，<span class="keyword">sh</span>、bash、csh、zsh等，想知道你的系统有几种<span class="keyword">shell</span>，可以通过以下命令查看：

&lt;pre&gt;`<span class="keyword">cat</span> /etc/shells`&lt;/pre&gt;

这些<span class="keyword">shell</span>我就不解释了，维基百科和百度百科都写的很清楚，总之，坊间流传，普通程序员用bash，文艺程序员用zsh，XX程序员直接用原生的<span class="keyword">sh</span>，我建议大家文艺一点，用zsh好一些，功能也最强大。目前各个版本的Linux默认的<span class="keyword">shell</span>都是bash，如果你想用zsh，需要安装一下，如下：

&lt;pre&gt;`sudo apt-get install zsh`&lt;/pre&gt;

具体的配置我就不介绍了，感兴趣的读者，可以参考

[http:<span class="comment">//leeiio.me/bash-to-zsh-for-mac/](\)</span>

3、通用工具

介绍几个简单的工具，建站必备。
</code></pre><ul>
<li>wget，命令行下载工具，安装<code>sudo apt-get install wget</code>，使用方式后面会介绍。</li>
<li>tmux，一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再「浪费」多余的终端来连接这台远程主机。好吧，这句话有点绕，简单说就是用tmux打开的会话可以一直驻留在服务器上，下次去看时还是上次来的样子。就像你是某个酒店的VIP客户，住完之后不会人走茶凉，也不会断电，下次去时茶还热着，灯也亮着，就这样。安装方式<code>sudo apt-get install tmux</code>，对使用方式感兴趣的读者去查一下吧，中文介绍很多，记住，热键是ctrl+b。</li>
<li><p>vim，在Linux上少不了编辑文件，我推荐Vim和Emacs，一个是编辑器之神，一个是神的编辑器（或者是伪装成操作系统的编辑器），我是Vim党，目前在学习Emacs。我之前写过一个Vim系列，有兴趣的可以去看：<a href="\">http://www.cnblogs.com/chijianqiang/tag/vim/</a>从原理到配置、使用都有非常详细的介绍，那也是个大坑，还没写完，但写了MacTalk就变成顾此坑失彼坑了。</p>
<p>差不多就这几个，其他的工具随用随装吧。</p>
<p><span style="\"color:" #ff6600;\"="">（上面基本照着做就可以了，记住你的用户名，别乱起就可以了。ssh不懂的自己去脑补，至于Vim这个东西，如果以前没有接触过，那google一下基本用法也是很有必要的。酷壳博主的这篇《简明Vim练级攻略》给大家推荐一下：<a href="http://coolshell.cn/articles/5426.html）" target="_blank" rel="external">http://coolshell.cn/articles/5426.html）</a></span></p>
<hr>
<h1 id="域名和DNS">域名和DNS</h1><p>服务器和环境构建都写完了，今天介绍一下域名和DNS的那点事儿，稍微复杂一点的软件部分放在最后说。</p>
<p>域名是什么东西呢？就是一个网站的标识和入口，由「.」分隔开的字符串构成，洋名叫Domain Name，比如苹果公司网站的域名就是<a href="\" title="\">apple.com</a>，在浏览器地址栏输入这个域名，就可以访问苹果的网站了。为什么要有域名呢，有了公网IP，不就可以访问网站了么？</p>
<p>咳，这么说吧，如果有人说找个地方聚聚，你说，咱们经度116.46、纬度39.92，不见不散！地方倒是对，但是估计实名菜刀和无名臭鞋就飞过来了。IP地址就是你的服务器在互联网世界的经纬度，域名就是对应IP的门牌号码，就像人们能记住门牌号记不住经纬度一样，在网络世界里，大家都是记域名的。与现实世界不同的是，门牌号和实际地址正常情况都是一对一的，而域名和IP地址是多对一的，也就是说，只要你有一个公网IP，就可以申请多个域名，对应多个应用，非常方便。</p>
<p>现在你知道了吧，要建站，必须要有域名。能够提供域名的厂商很多，国内外都有。不过我强烈推荐大家购买国外厂商的域名，免去提交材料和备案之苦，国外动动鼠标和小手分分钟搞定的事情，国内要提交各种材料、备案、定期监管balabala……具体差异大家看看<a href="\" title="\">www.apple.com.cn</a>和<a href="\">www.apple.com</a>两个网站的底部知道了，苹果中国的底部有「京公安网安备 11010500896|京ICP备10214630」，再看看米帝的网站，毛都没有，都是自己的网站信息，我们只能说，米帝的监管制度太不健全了，真为他们捉鸡！</p>
<p>国外的域名厂商推荐<a href="\">www.godaddy.com</a>和<a href="\">www.name.com</a>，都不错。我使用的是<a href="\">Godaddy</a>。</p>
<p>Godaddy是全球最大的域名注册服务商，全球市场占有率超过30%，一般情况下不会被我朝屏蔽。如果屏蔽了Godaddy，会导致在大陆无法访问全球近三分之一的网站，所以相对安全，相对，你懂的。另外Godaddy开始支持支付宝了，对我朝臣民来说付费变得方便无比。</p>
<p>在域名选择上，最好满足这几点要求：有意义、好记、简短，另外尽可能使用com（通用顶级域名）。申请步骤也很简单，访问<a href="\">www.godaddy.com</a>，在搜索框输入你想要购买的域名，点击搜索，你会看到这个域名的具体信息，是否被使用，相关域名，价格等信息，域名后缀一般有com、net、me、us、info等，建议选com，不建议选info，据说info结尾的网站大部分是垃圾网站，会被搜索引擎屏蔽。</p>
<p>选好域名后，点Add，加入购物车，如果不需要其他服务，一路Continue即可，最后设置支付信息，支付宝在最后一列，然后「Place Your Order」，根据提示注册和支付即可。价格与域名信息相关，一般几美元到10几美元不等。</p>
<p>购买完成之后，进入Godaddy的域名管理控制台，找到你购买的域名，把域名和你的IP地址绑定起来，就可以通过域名访问你的网站了。这里就涉及到DNS了。</p>
<p>DNS的洋名一般说成Domain Name System，就是给域名提供服务的。光有域名没用，还得有相关的服务能够把域名解析成IP地址才行，DNS就干这事。DNS的扩展性非常好，不依靠单一的巨型主机索引，而是通过分布式系统提供服务，全球能够提供DNS服务的服务器多如牛毛数不胜数，但大哥级别的根服务只有13台，目前的分布是：主根服务器美国1个，设置在弗吉尼亚州的杜勒斯；辅根服务器美国9个，瑞典、荷兰、日本各1个，旗下是各个级别的域名服务器。</p>
<p>DNS的工作方式挺复杂，有兴趣的直接去Google吧，我简单描述一下，大致的场景是这样的，比如小明是个DNS服务器，有一天你想访问<a href="\" title="\">macshuo.com</a>，就问，「小明啊，我想去听听MacTalk，怎么走呢？」，作为忠诚的DNS战士，小明的服务态度是值得赞赏的，如果他知道的话，就会立刻告诉你地址，比如从这个街区左转左转左转再左转balabala……如果丫不知道也没关系，他会反馈给上级主管，说「最近有人新建了个MacTalk网站，我这还没记录地址，你晓得不？」，上级部门如果知道就会把地址发给小明，说「你丫长点记性，把这地址记下来行不？别特么老问了，最近自媒体网站可真多啊，哎……」，这样小明就会把地址告诉你，并且用心的把这个地址记到自己的小本本上，下次有人再问，就直接告诉人家答案了。如果上级部门也不知道，那就继续问，直到反馈到根服务器为止，反正只要你注册了，总能找到。差不多就这样吧。</p>
<p>Godaddy默认提供了DNS服务，点击DNS Manager，在弹出的设置面板中设置你的网站IP即可，具体的图文教程网络上很多，我就不费那事了。但是我的使用结果是，Godaddy提供的DNS在国内访问不太稳定，时不时就不能访问了，具体为啥我也不清楚。因为购买了Linode服务，我最后采用了Linode的DNS，具体的做法是：</p>
</li>
</ul>
<ol>
<li>登录<a href="\" title="\">linode.com</a>，点击DNS Manager标签，进入管理控制台</li>
<li>选择Add a domain zone</li>
<li>填写域名、邮件地址和IP</li>
<li><p>点击Add a Master Zone，就算完成了</p>
<p>最后一步就是在Godaddy的控制台里设置一下Linode的DNS服务器，很简单就不描述了。</p>
<p><span style="\"color:" #ff6600;\"="">（Mac君在Godaddy买的域名，Godaddy买的域名货真价实，童叟无欺，但我当时贪图便宜，在万网买了个域名，价格大家可以自己去两个网站对比一下，万网的性价比要高一些。在Linode中设置好域名后，需要到万网那里设置一下DNS，我是设置的Linode提供的DNS（在linode的控制台里面可以看到），将此DNS复制到万网管理台的DNS设置里面即可）</span></p>
<hr>
<h1 id="应用程序和部署">应用程序和部署</h1><p>经过前面三篇系列文章的介绍之后，我们现在房子也有了，做了简装修，还申请了地址和门牌号，最后一步就是入住，也就是部署你的应用程序。</p>
<p>针对网站提供的服务不同，需要不同的技术选型，我的需求就是做个风格简约的博客，用来存放MacTalk的文章，同时有个地方能够随意发表一些个人观点，就这么简单，所以针对这个需求进行选择即可。大家将来建站的时候也是一样，明确自己的需求，不要为未来买单，尽量搞的轻量级一些，最忌讳给的是龙套的钱，您自个却按照男猪脚进行角色扮演，不提倡。</p>
<p>搭建轻量级的博客不建议使用.Net或JavaEE的技术，这些技术都比较重，必要性不大。Php、Python、Ruby相关的框架都是可选的技术。因为我对Python相对熟悉一些，最初想找个开源的Python Blog框架，不过后来综合对比了一下，发现在个人博客领域，WordPress基本上无出其右，技术成熟、安装方便、性能稳定、插件众多，实在是居家建站、个人扯淡之必备良药，就是它了。</p>
<p>在确定了基本需求和工具之后，我们看看涉及到哪些技术：</p>
<p>1、Nginx Nginx是一款高性能的HTTP服务器软件，由俄罗斯的一位大牛Igor Sysoev开发的，源代码以类BSD许可证的形式发布。Nginx的设计非常轻量级，由内核和模块组成，内核微小简洁，模块功能强大，静态编译。Nginx做的事情简单来说就是，接收客户端（浏览器）的HTTP请求，然后通过映射机制把不同类型的请求交给不同的模块去处理，比如html、图片、css等可以交给静态资源模块处理，还可以做压缩、缓存等，php、python等类型的请求则交给FastCGI模块去处理，完成业务逻辑。</p>
<p>什么是FastCGI呢？这玩意就等于是HTTP服务器和动态脚本语言通信的接口，就像一个粘合剂一样把HTTP请求和动态脚本处理整合在一起，顾名思义，处理速度非常Fast！</p>
<p>Nginx可以说是HTTP服务器软件市场的新贵，目前国内很多大型网站都采用了Nginx作为默认的web服务器，比如阿里、腾讯、新浪等等，国外就更多了。当然，在Nginx未涉足江湖之前，这个领域的大哥叫做Apache，那时候几乎所有的HTTP Server都是清一色的Apache，一时之间风头无两。但是这哥们大哥做久了就不思进取，跟国内很多大佬一个德性，没竞争对手时就特么不知道改进，直到Nginx出来抢了丫半壁江山，现在知道努力了，当初干嘛去了？</p>
<p>那么Nginx比Apache优秀在哪呢？</p>
</li>
</ol>
<ul>
<li>Nginx的所有模块都是全静态编译的，启动Nginx后，Nginx的模块被自动加载，静态库执行效率更高。</li>
<li>Nginx支持epoll（Linux系列）和kqueue（BSD系列）I/O事件通知机制。完，又特么出现两个名词！这让人情何以堪、文何以完啊？简单说说epoll吧。epoll是Linux2.6正式引入的提高网络I/O的处理方法，它的几个优点是：单一进程打开的FD（文件描述符）数量仅受限于操作系统，1GB内存的机器上大约是10万左右，这一点大大提升了处理海量请求的能力；采用共享内存的模式避免内存拷贝；随着打开FD的数量增加，I/O效率不会线性下降。总之，大家知道epoll很牛逼就是了。</li>
<li><p>Nginx支持多进程的工作方式，Nginx启动后会有一个master进程，多个worker进程。worker进程一般对应服务器的CPU数量，你有个8核的CPU，最好把worker设置为8。master负责接收外界信号，并向worker发送信号，监控worker的运行状况，当worker挂掉的时候，启动新的worker。写到这我发现，这特么活脱脱就是一个地主老财打压长工的模式啊！<br>尤其是Nginx的不中断重启机制，当系统配置变化需要重新启动Nginx时，我们就给地主（master）发个消息，说这批长工（worker）太老了，都得换掉，你看着办。地主收到消息后就开始偷偷雇佣新的长工（worker），然后假惺惺的告诉老长工，把手头的活干完就行了，别太累了，啊。这时候如果有新的请求，就会交给新长工干，等所有的老长工把活都干完了，就直接fire，绝不留情。这样，整个服务无中断重启过程就完成了，就特么一个字，黑！<br>当然长工（worker）也不是省油的等，他们干活的过程非常复杂，会用到我们上文中提到的epoll机制，如果有人感兴趣，以后再讲吧，这么写下去这个系列就没完了。</p>
<p>Nginx功能非常强大，一本书也写不完，我简单就说这么几句。老话，有兴趣的，用Google百度一下！</p>
<p>大概了解了Nginx的工作机制，下面安装就比较简单了，Nginx可以编译安装，也可以在线安装，对于普通用户来说，使用apt-get在线安装即可，省得自己去找依赖关系。</p>
<pre>`#安装
sudo apt-get install nginx
#启动
sudo service nginx start`</pre>

<p>如果安装和启动都没有问题，我们再调整几个参数就可以了。</p>
<p>找到/etc/nginx/nginx.conf，做以下几个改动：</p>
</li>
<li><p>把worker_processes设置为服务器的CPU核数</p>
</li>
<li>在event里增加use epoll</li>
<li><p>把worker_connections的值设置大一点，如果是1G内存，不要大于100000/worker_processes。</p>
<p>其他的采用默认值即可，然后重新加载参数：</p>
<pre>`sudo nginx -s reload`</pre>

<p>好，Nginx就算妥了，后续在安装PHP和WordPress时还要做一些配置。</p>
<blockquote>
<p>我有时候觉得，当我们在计算机领域遇到问题的时候，总会出现一些技术神山上的神人，他们时不时会俯视一下凡人的IT世界，高兴了就顺手解决几个bug，发明几个新玩意，epoll和Nginx就是这些玩意，我们用好就已经心满意足袅。</p>
</blockquote>
<p>2、MySQL</p>
<p>MySQL是应用最为广泛的开源数据库，这个没什么可说的，非常成熟的技术，直接安装即可：</p>
<pre>`sudo apt-get install mysql-server`</pre>

<p>安装过程中，MySQL会提示你设置root密码（root的作用参考之前介绍的，把操作系统换成数据库即可）。如果安装时没设置密码，等MySQL起来后用mysqladmin改也行，用sql改也行，简单不啰嗦。</p>
<p><span style="\"color:" #ff6600;\"="">(注：这里Mac君没有说sql的基本操作，我这里简单说一下。安装好mySql之后，执行 ：</span></p>
<p><span style="\"color:" #ff6600;\"="">mysql -u root -p+你安装时的密码     </span></p>
<p><span style="\"color:" #ff6600;\"=""> -p和密码之间没有分隔符。进入后 ,就是MySql的基本操作，记得每一条命令以；结尾</span></p>
<p><span style="\"color:" #ff6600;\"="">1、 显示数据库：show databases;</span></p>
<p><span style="\"color:" #ff6600;\"="">2、 建数据库：create database  [if not exists] 数据库名;</span><br><span style="\"color:" #ff6600;\"="">3、 建数据表： create table [if not exists] 表名 (字段名1   类型。。。。。。。。)</span><br><span style="\"color:" #ff6600;\"="">create table student (编号 int auto_increment primary key, 姓名 varchar(10));</span><br><span style="\"color:" #ff6600;\"="">注意:设置了自动增长,就要定为主键,如果选择了BIT 类型,0不显示,非0显示为一个特殊符号!</span><br><span style="\"color:" #ff6600;\"="">4、 显示数据表:show tables;</span><br><span style="\"color:" #ff6600;\"="">5、 删除库: drop database [if exists] 库名; </span><br><span style="\"color:" #ff6600;\"="">6、 删除表: drop table   [if exists] 表名;</span><br><span style="\"color:" #ff6600;\"="">7、 显示表结构: desc 表名</span><br><span style="\"color:" #ff6600;\"="">8、 如何修改表结构:增长一个字段; alter table 表名 add 字段名  类型</span><br><span style="\"color:" #ff6600;\"="">9、 删除一个字段: alter table  表名 drop 字段名</span><br><span style="\"color:" #ff6600;\"="">10、修改一个字段的属性:  alter table 表名modify 字段 新属性</span><br><span style="\"color:" #ff6600;\"="">11、修改主键: 增加一个主键  alter table 表名 add primary key(字段名)</span><br><span style="\"color:" #ff6600;\"="">12、删除一个主键  alter table 表名  drop primary key(字段名)</span></p>
<p><span style="\"color:" #ff6600;\"="">之后还要修改一下字符集，可以参照这里：<a href="\" title="\">http://database.51cto.com/art/201010/229167.htm</a>)</span></p>
<p>3、PHP</p>
<p>WordPresss是基于PHP开发的，所以我们得为WordPress准备好环境，安装PHP。</p>
<pre>`sudo apt-get install php5
sudo apt-get install php5-fpm`</pre>

<p>php5-fpm是PHP FastCGI的实现之一，能够更好的管理PHP进程，控制内存使用，平滑重载等，现在我们都用它！</p>
<p>下面做一点简单配置，打开php.ini文件：</p>
<pre>`sudo vim /etc/php5/fpm/php.ini`</pre>

<p>找到cgi.fix_pathinfo=1这一行，把1改为0。 值为1时，php的解释器会尽可能的去解析客户端请求的文件各种类型，这会引发一些安全漏洞，设置为0时，解释器只会去解析特定的文件类型，设置为0是一种相对安全的处理策略。</p>
<p>修改www.conf：</p>
<pre>`sudo vim /etc/php5/fpm/pool.d/www.conf`</pre>

<p>把 <code>listen = 127.0.0.1:9000</code> 修改为 <code>listen = /var/run/php5-fpm.sock</code>，前者是走TCP socket，后者是Unix domain socket，如果服务都在同一台机器上，建议使用后者，效率更好一些。</p>
<p>重新启动PHP，这部分的配置就算完成了：</p>
<pre>`sudo service php5-fpm restart`</pre>

<p>4、WordPress</p>
<p>好的，我们从后场断球后左冲右突，盘过对方和我方的所有进攻和防守队员，来到球门前面，发现就差最后一关：WordPress。下面我们看看如何安装和配置WordPress。</p>
<p>首先下载WordPress的最新版本，我用了中文版，下载和解压缩：</p>
<pre>`wget http://cn.wordpress.org/wordpress-3.5.1-zh_CN.tar.gz
tar -xzvf wordpress-3.5.1-zh_CN.tar.gz 

<span style="\"font-family:" georgia,="" \'times="" new="" roman\',="" \'bitstream="" charter\',="" times,="" serif;="" font-size:="" 14px;="" line-height:="" 1.5em;="" color:="" #ff6600;\"="">（注：这里Mac君用的3.5.1，现在3.8.1为最新版本，建议用最新版本即可
</span>`
<span style="\"color:" #ff6600;\"="">`wget http://cn.wordpress.org/wordpress-3.8.1-zh_CN.tar.gz
tar -xzvf wordpress-3.8.1-zh_CN.tar.gz `</span>
`<span style="\"font-family:" georgia,="" \'times="" new="" roman\',="" \'bitstream="" charter\',="" times,="" serif;="" font-size:="" 14px;="" line-height:="" 1.5em;\"=""><span style="\"color:" #ff6600;\"="">）</span>
在MySQL中为WordPress创建用户和数据库，这部分很简单就不描述了。我们设定数据库为wordpress，用户名为mactalk，并且把数据库编码改为UTF-8。</span>`</pre>

<p>在解压好的wordpress文件夹下，执行：</p>
<pre>`cp wp-config-sample.php wp-config.php
vim ~/wordpress/wp-config.php`</pre>

<p>按照文件内容注释填写数据库名称、用户名、密码、数据库编码使用UTF-8，然后保存退出。</p>
<p>为wordpress创建www文件夹，并且把完整的wordpress目录复制到www文件夹下，并设置相关权限：</p>
<pre>`sudo mkdir -p /var/www

sudo cp -r ~/wordpress/* /var/www

cd /var/www/

sudo chown www-data:www-data * -R 

sudo usermod -a -G www-data username   <span style="\"color:" #ff6600;\"="">（注：这里的username就是你当前登录的用户名）</span>`</pre>

<p>安装php的MySQL驱动</p>
<pre>`sudo apt-get install php5-mysql`</pre>

<p>设置虚拟主机：</p>
<p>在/etc/nginx/sites-available下创建文件wordpress</p>
<pre>`sudo vim wordpress`</pre>

<p>内容如下：</p>
<pre>`server {
    listen   80;

    root /var/www;
    index index.php index.html index.htm;

    #根据 IP 或域名自定义 <span style="\"color:" #ff6600;\"=""> （注：这里只需要修改后面的3.3.3.3\. 改成你的ip或者域名都可以）
</span>    server_name 3.3.3.3;

    location / {
        try_files $uri $uri/ /index.php?q=$uri&amp;$args;
    }

    error_page 404 /404.html;

    error_page 500 502 503 504 /50x.html;
    location = /50x.html {
          root /usr/share/nginx/www;
    }

    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9$
    location ~ .php$ {
        #fastcgi_pass 127.0.0.1:9000;
        # With php5-fpm:
        fastcgi_pass unix:/var/run/php5-fpm.sock;
        fastcgi_index index.php;
        include fastcgi_params;
    }
}`</pre>

<p>这个文件的作用就是把Nginx和WordPress粘合在一起，接收客户端的请求并反馈响应结果。有几点要注意的是，root设置为/var/www/，index部分增加index.php，fastcgi_pass对应之前设置的unix socket：unix:/var/run/php5-fpm.sock。<span style="\"color:" #ff6600;\"="">（注：这段话只是说明一下上面的文件有什么改动，并不需要自己去操作，特别注意最后要删除default文件，不然在重启nginz时会报一个80端口已经被其他server占用的错误。）</span></p>
<p>为wordpress文件建立软连接：</p>
<pre>`sudo ln -s /etc/nginx/sites-available/wordpress /etc/nginx/sites-enabled/wordpress`</pre>

<p>最后重新启动nginx和php5-fpm，就算大功告成了：</p>
<p><pre>`sudo service nginx restartsudo<br>service php5-fpm restart</pre></p>
</li>
</ul>
<p>如果一切正常的话，访问你的域名或者公网IP，就可以看到wordpress的提示页面，根据信息提示初始化数据库，创建管理员，基本框架就算建好了，之后就是完善和优化，比如性能优化、主题选择、配置信息、插件选择、扩展开发等等，大家慢慢体会吧。<span style="\"line-height:" 1.5em;\"=""> </span></p>
<p>下面是本人配置好wordpress之后的画面：一段很有趣的话，开始你的博客之旅把。</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>之后会有一个系列，来讲wordpress使用过程中遇到的问题和心得。有问题欢迎留言交流。</p>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="\"><img src="\" alt="\"></a></p>
<p>配图来自网络。</p>
<h1 id="个人吐槽阶段">个人吐槽阶段</h1><p>说到建立独立博客，很多人都很不屑地说，CSDN、博客园不是也提供博客地址么？为什么要花这么大力气，自己搭建一个博客呢？举个不太恰当的例子，很多人刚毕业没钱，在外边租房子，提供租房服务的很多，一租好几年，但每个人都想拥有自己的房子。这独立博客就相当于自己的房子，自己的房子用起来，当然就要比租的房子用起来要那么用心一点，有空就搞个装修啊，买点家具啊，修个游泳池啊（想多了），养点花花草草猫猫狗狗之类的。租的房子，能住人绝对不养狗，能叫外面绝对不下厨。不能比啊不能比，这是个态度问题。</p>
<h1 id="准备阶段">准备阶段</h1><p>废话说了这么多，还是尽快切入主题。说到个人建站，网上教程一堆一堆的，我自然也不会自己一个一个地去摸索。我主要参考的文章是Mac君的《趣谈个人建站》：<a href="\" title="\">http://macshuo.com/?p=547</a>。Mac君使用的是godaddy+ubuntu+linode。而我的不一样的点是我在国内买的域名：阿里云万网：<a href="\" title="\">http://www.net.cn/</a>。下面的内容大部分都来自Mac君的博文《趣谈个人建站》：<a href="\" title="\">http://macshuo.com/?p=547</a>。</p>
<p>重复造轮子的行为是不被大家认可的，但我这里还是要重复造轮子，原因如下：1.本人的部分步骤和原文不太一样，直接说哪里哪里不一样，会有点麻烦。 2.原文中有些没有涉及到的东西，我会在这里讲清楚，因为我跟着他的步骤走的时候，有时候会掉到坑里，爬很久才出来。 3.各位想建站的同学可以直接跟着本文的教程就可以建好，不必再切来切去。里面红色的部分是我的注释，是我遇到的问题和解决办法，希望大家别再入黑胡同。</p>
<p>搭建个人站点，大致需要做这么几件事情：</p>
<ul>
<li>一台具备公网IP的服务器</li>
<li>安装操作系统，搭建环境</li>
<li>购买域名，域名绑定IP</li>
<li>部署应用程序</li>
</ul>
<p>基本上这四套组合拳打完，你的个人网站就算建起来了，后续的事情就是添砖加瓦和蓬荜生辉了。</p>]]>
    
    </summary>
    
      <category term="Wordpress" scheme="http://androidperformance.com/categories/Wordpress/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gracker的个人博客开通了！]]></title>
    <link href="http://androidperformance.com/2014/02/24/hello-gracker-blog-was-build/"/>
    <id>http://androidperformance.com/2014/02/24/hello-gracker-blog-was-build/</id>
    <published>2014-02-24T07:54:49.000Z</published>
    <updated>2015-03-26T12:45:53.000Z</updated>
    <content type="html"><![CDATA[<p>计划了很久，终于把博客开通了。</p>
<p>自从接触到<a href="http://apple.com" target="_blank" rel="external">Mac OS</a>之后，便对苹果佩服的五体投地，硬件上突出一个高大上，而且携带方便，软件上更是无人出其右。有时候你用他就觉得是一种享受。这不是我有意夸大，谁用谁知道。</p>
<p>然后顺理成章地知道了Mac君，微信上MacTalk也是每一篇都一字不差地看完，最后买了多看版，也买了实体书，一本书有这样的魔力，我也很惊奇。同样是搞技术的，为何他就能写出这样的文字，而我却只能对着程序发呆。究其原因，这里面有人生经历的原因，更重要的是他的热情和坚持，让我这种三分钟热情的人表示很汗颜。想想自己最能坚持的事，就是一局又一局的DOTA。每思及此，痛心疾首，所以下决心要做点什么。</p>
<p>Mac君的书中有一段：“即便是最简单的坚持，最后的结果也都是惊人的。这世界上一直存在一条路，让我们的能力从平庸到杰出，这条路漫长而且艰辛，只有少数人愿意走下去，所以，优秀的人永远是少数”。这段话让我感触很多，也让我下定决定要把这个博客搭建起来，养成写作的习惯。少刷点微博，少打两把DOTA，时间就那么多，再浪费下去，以后的我，会痛恨现在的我的。</p>
<p>现在计划每周更新博客两次，周一到周五发一篇，周末发一篇。尽量做到言之有物，对别人有实质性的帮助，不讲空话，技术上用实例说明问题。可能初期的文笔不是很好，但我相信，简单的坚持，借用红米的一句话：“永远相信美好的事情即将发生”。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>计划了很久，终于把博客开通了。</p>
<p>自从接触到<a href="http://apple.com" target="_blank" rel="external">Mac OS</a>之后，便对苹果佩服的五体投地，硬件上突出一个高大上，而且携带方便，软件上更是无人出]]>
    </summary>
    
      <category term="生活感悟" scheme="http://androidperformance.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>