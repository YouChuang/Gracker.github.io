<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Android Perofrmance]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://androidperformance.com/"/>
  <updated>2015-04-01T10:15:07.000Z</updated>
  <id>http://androidperformance.com/</id>
  
  <author>
    <name><![CDATA[Gracker]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Android性能优化后续]]></title>
    <link href="http://androidperformance.com/2015/03/31/android-performance-case-study-follow-up/"/>
    <id>http://androidperformance.com/2015/03/31/android-performance-case-study-follow-up/</id>
    <published>2015-03-31T01:29:00.000Z</published>
    <updated>2015-04-01T10:15:07.000Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>本文是一篇译文，原文<a href="http://www.curious-creature.com/2015/03/25/android-performance-case-study-follow-up/?utm_source=Android+Weekly&amp;utm_campaign=0692ef161b-Android_Weekly_146&amp;utm_medium=email&amp;utm_term=0_4eb677ad19-0692ef161b-337850757" target="_blank" rel="external">Android Performance Case Study Follow-up</a>的作者是大名鼎鼎的<a href="http://www.curious-creature.com/" target="_blank" rel="external">Romain Guy</a>。本文讲述了Android性能优化的一些技巧、方法和工具。</p>
<h1 id="译文正文">译文正文</h1><p>两年前，我发表了一篇名为<a href="http://www.curious-creature.com/2012/12/01/android-performance-case-study/" target="_blank" rel="external">Android Performance Case Study</a> 的文章，来帮助Android开发者了解需要使用什么工具和技术手段来确定、追踪和优化性能问题。</p>
<p>那篇文章以一个Twitter客户端 <a href="https://play.google.com/store/apps/details?id=com.jv.materialfalcon" target="_blank" rel="external">Falcon Pro</a>为典范，其开发人员为 Joaquim Vergès. Joaquim人不错，他允许我在我的文章中使用它的程序作为例子，并且快速处理了我发现的所有问题。一切都OK，直到Joaquim 从头开始开发Falcon Pro 3，前不久在他准备发布它的新应用的时候，他联系了我，因为他有一个和滚动相关的性能问题需要我来帮助他，这一次我依然没有源代码可以参考。</p>
<a id="more"></a>
<p>Joaquim使用了所有的工具来找出问题所在，他发现Overdraw不是问题的原因，他觉得是 <a href="http://developer.android.com/reference/android/support/v4/view/ViewPager.html" target="_blank" rel="external">ViewPager</a> 的用法导致了这个问题。他给我发来了下面的截图：</p>
<p><img src="/images/android-performance-case-study-follow-up/falconpro3.png" alt="Falcon Pro"></p>
<p>Joaquim使用了系统内置的GPU profiling工具来发现掉帧现象， 左边的截图是在没有ViewPager 的情况下滑动时间线，右边的截图是有ViewPager的情况下滑动（他使用的是2014年的Moto x来截的图），问题看起来很明显。</p>
<p>我最先想到的是查看ViewPager是不是由于滥用硬件加速导致，这个性能问题看起来像是在滑动的过程中每一帧都使用了硬件加速。系统的 <a href="http://www.curious-creature.com/2013/09/13/optimizing-hardware-layers/" target="_blank" rel="external">hardware layers updates debugging tool</a>没有显示什么有用的信息。我反复使用HierarchyViewer 查看布局情况，令我满意的是ViewPager的表现很正确（相反，不太可能会出问题）</p>
<p>之后我打开了另一个强大的工具却很少用到的工具：Tracer for OpenGL 。我之前的那篇<a href="http://www.curious-creature.com/2012/12/01/android-performance-case-study" target="_blank" rel="external">文章</a>解释了如何使用工具获得更多细节。你首先需要知道的是这个工具收集了所有UI界面发给GPU的绘制命令。</p>
<blockquote>
<p><strong>Android 4.3 and up</strong>: <em>Tracer</em> has unfortunately become a little more difficult to use since Android 4.3 when we introduced<a href="https://developers.google.com/events/io/sessions/325418001" target="_blank" rel="external">reordering and merging of drawing commands</a>. It’s an amazingly useful optimization but it prevents <em>Tracer</em> from grouping drawing commands by view. You can restore the old behavior by disabling display lists optimization using the following command (before you start your application)(意思是说Android4.3之后，这个工具不太好用了，因为有reordering and merging 机制的引进)</p>
<p><strong>Reading OpenGL traces</strong>: Commands shown in blue are GL operations that draw pixels on screen. All other commands are used to transfer data or set state and can easily be ignored. Every time you click on one of the blue commands, Tracer will update the Details tab and show you the content of the current render target right after the command you clicked is executed. You can thus reconstruct a frame by clicking on each blue command one after another. It’s pretty much how I analyze performance issues with Tracer. Seeing how a frame is rendered gives a lot of insight on what the application is doing.(意思是说只蓝色的行是真正进行绘制的命令，点击可以看到绘制的这一帧的图像，其他的命令都是一些数据的转换)</p>
</blockquote>
<p>滑动一段时间Falcon Pro应用后，我仔细查看Gl Trace收集到的数据，我很惊奇地发现很多SaveLayer/ComposeLayer阻塞命令。</p>
<p><img src="/images/android-performance-case-study-follow-up/glTrace.png" alt="Paste_Image.png"></p>
<p>这些命令表明应用在生成一个临时的Hardware Layer。这些临时的Layer被不同的 <a href="http://developer.android.com/reference/android/graphics/Canvas.html#saveLayer(float, float, float, float, android.graphics.Paint, int" target="_blank" rel="external">Canvas.saveLayer()</a>)所创建，这些UI控件在下面的情况下使用Canvas.saveLayer()方法去绘制 alpha &lt; 1 (see<a href="http://developer.android.com/reference/android/view/View.html#setAlpha(float" target="_blank" rel="external">View.setAlpha()</a>)的View(即半透明View)：</p>
<ul>
<li><a href="http://developer.android.com/reference/android/view/View.html#getAlpha(" target="_blank" rel="external">getAlpha()</a> returns a value &lt; 1</li>
<li><a href="http://developer.android.com/reference/android/view/View.html#onSetAlpha(int" target="_blank" rel="external">onSetAlpha()</a> returns false</li>
<li><a href="http://developer.android.com/reference/android/view/View.html#getLayerType(" target="_blank" rel="external">getLayerType()</a> returns LAYER_TYPE_NONE</li>
<li><a href="http://developer.android.com/reference/android/view/View.html#hasOverlappingRendering(" target="_blank" rel="external">hasOverlappingRendering()</a> returns true</li>
</ul>
<p>我和Chet 在很多演示中解释过为什么你应该 <a href="https://youtu.be/vQZFaec9NpA?t=29m51s" target="_blank" rel="external">use alpha with care</a>，每次UI控件使用一个临时的Layer，绘制命令会发送不同的渲染目标，对GPU来说，切换渲染目标是很昂贵的操作,这对于使用tiling/deferred架构的GPU（ImaginationTech’s SGX, Qualcomm’s Adreno, etc）等是硬伤，直接渲染架构的GPU，比如 Nvidia，则会好一点。因为我和Joaquim 使用的是搭载高通处理器的Moto X 2014版本，所以使用多个临时硬件层是最有可能的性能问题的根源。</p>
<p>那么问题来了，是什么创建了这些临时的Layer呢？<em>Tracer</em>告诉我们了答案，如果你看了刚刚上面那张<a href="http://www.curious-creature.com/blog/wp-content/uploads/2015/03/Screen-Shot-2015-03-25-at-11.00.53-AM-950x552.png" target="_blank" rel="external">图</a>,你可以看到只有SaveLayer这个组中OpenGl命令绘制了一个小圆圈（图被工具放大了），我们来看一下应用截图：</p>
<p><img src="/images/android-performance-case-study-follow-up/before.png" alt="Falcon Pro 3"></p>
<p>你看到最上面的小圆圈了么？那是ViewPager的指示器，来显示当前的位置。Joaquim 使用了一个第三方库来绘制这些指示器，有趣的是这些库如何绘制指示器的：当前的Page用一个白色的圈指示，其他的页用类似灰色的圆圈来指示。我说类似灰色因为这个圆圈其实是半透明的白色圆圈。这个库使用 setAlpha()方法来给每个圆圈设置颜色。</p>
<p>有下面几种方法来解决这个问题：</p>
<ul>
<li>Use a customizable “inactive” color instead of setting an opacity on the View（ 使用动态的“inactive”颜色(即根据状态来设置View的颜色)而不是设置透明度。）</li>
<li><p>Return false from hasOverlappingRendering() and the framework will set the proper alpha on the Paint<br>for you（使hasOverlappingRendering()返回false，这样系统会设置适当的alpha，关于这个的用法，这篇<a href="http://imid.me/blog/2014/01/17/best-practices-for-using-alpha/" target="_blank" rel="external">文章</a>中有提到：同时Android提供了hasOverlappingRendering()接口，通过重写该接口可以告知系统当前View是否存在内容重叠的情况，帮助系统优化绘制流程，原理是这样的：对于有重叠内容的View，系统简单粗暴的使用 offscreen buffer来协助处理。当告知系统该View无重叠内容时，系统会分别使用合适的alpha值绘制每一层。）</p>
 <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Returns whether this View has content which overlaps. This function, intended <span class="keyword">to</span> be</span><br><span class="line"> * overridden <span class="keyword">by</span> specific View types, <span class="keyword">is</span> an optimization when alpha <span class="keyword">is</span> <span class="keyword">set</span> <span class="function_start"><span class="keyword">on</span></span> a view. If</span><br><span class="line"> * rendering overlaps <span class="keyword">in</span> a view <span class="keyword">with</span> alpha &lt; <span class="number">1</span>, <span class="keyword">that</span> view <span class="keyword">is</span> drawn <span class="keyword">to</span> an offscreen buffer</span><br><span class="line"> * <span class="keyword">and</span> <span class="keyword">then</span> composited <span class="keyword">it</span> <span class="keyword">into</span> place, which can be expensive. If <span class="keyword">the</span> view has no overlapping</span><br><span class="line"> * rendering, <span class="keyword">the</span> view can draw each primitive <span class="keyword">with</span> <span class="keyword">the</span> appropriate alpha value directly.</span><br><span class="line"> * An example <span class="keyword">of</span> overlapping rendering <span class="keyword">is</span> a TextView <span class="keyword">with</span> a background image, such <span class="keyword">as</span> a</span><br><span class="line"> * Button. An example <span class="keyword">of</span> non-overlapping rendering <span class="keyword">is</span> a TextView <span class="keyword">with</span> no background, <span class="keyword">or</span></span><br><span class="line"> * an ImageView <span class="keyword">with</span> only <span class="keyword">the</span> foreground image. The default implementation returns <span class="constant">true</span>;</span><br><span class="line"> * subclasses should override <span class="keyword">if</span> they have cases which can be optimized.</span><br><span class="line"> *</span><br><span class="line"> * @<span class="constant">return</span> <span class="constant">true</span> <span class="keyword">if</span> <span class="keyword">the</span> content <span class="keyword">in</span> this view might overlap, <span class="constant">false</span> otherwise.</span><br><span class="line"> */</span><br><span class="line">public <span class="type">boolean</span> hasOverlappingRendering() &#123;</span><br><span class="line"><span class="command">    return</span> <span class="constant">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Return true from onSetAlpha() and set an alpha on the Paint used to draw the “gray” circles（使onSetAlpha() 返回True并对Paint设置alpha来绘制“gray”圆圈）</p>
 <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paint.setAlpha((int) alpha * <span class="number">255</span>);</span><br><span class="line">canvas.draw*(<span class="keyword">...</span>, paint);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>最简单的方法是使用第二种，但是他只能在API16以上使用，如果你要支持旧版本的Android，使用其他两个方法，我相信Joaquim 已经丢弃那个第三方库并使用自己的指示器了。</p>
<p>我希望这篇文章能让大家清楚如何从看似无辜的和无害的操作中寻找可能会出现性能问题。所以请记住:不要仅仅做出假设,要实际去验证、测量。</p>
<h1 id="附录">附录</h1><p>更多关于Alpha的使用，可以参考这篇文章：<br><a href="http://imid.me/blog/2014/01/17/best-practices-for-using-alpha/" target="_blank" rel="external">Android Tips: Best Practices for Using Alpha</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前言">前言</h1><p>本文是一篇译文，原文<a href="http://www.curious-creature.com/2015/03/25/android-performance-case-study-follow-up/?utm_source=Android+Weekly&amp;utm_campaign=0692ef161b-Android_Weekly_146&amp;utm_medium=email&amp;utm_term=0_4eb677ad19-0692ef161b-337850757">Android Performance Case Study Follow-up</a>的作者是大名鼎鼎的<a href="http://www.curious-creature.com/">Romain Guy</a>。本文讲述了Android性能优化的一些技巧、方法和工具。</p>
<h1 id="译文正文">译文正文</h1><p>两年前，我发表了一篇名为<a href="http://www.curious-creature.com/2012/12/01/android-performance-case-study/">Android Performance Case Study</a> 的文章，来帮助Android开发者了解需要使用什么工具和技术手段来确定、追踪和优化性能问题。</p>
<p>那篇文章以一个Twitter客户端 <a href="https://play.google.com/store/apps/details?id=com.jv.materialfalcon">Falcon Pro</a>为典范，其开发人员为 Joaquim Vergès. Joaquim人不错，他允许我在我的文章中使用它的程序作为例子，并且快速处理了我发现的所有问题。一切都OK，直到Joaquim 从头开始开发Falcon Pro 3，前不久在他准备发布它的新应用的时候，他联系了我，因为他有一个和滚动相关的性能问题需要我来帮助他，这一次我依然没有源代码可以参考。</p>]]>
    
    </summary>
    
      <category term="Android,Performance,性能优化" scheme="http://androidperformance.com/tags/Android-Performance-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(5)]]></title>
    <link href="http://androidperformance.com/2015/03/15/android-tips-round-up-5/"/>
    <id>http://androidperformance.com/2015/03/15/android-tips-round-up-5/</id>
    <published>2015-03-14T16:32:11.000Z</published>
    <updated>2015-03-27T05:35:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第五篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="https://developer.android.com/reference/android/support/v4/widget/ViewDragHelper.html" target="_blank" rel="external">ViewDragHelper</a> ——视图拖动是一个比较复杂的问题。这个类可以帮助解决不少问题。如果你需要一个例子，<a href="https://developer.android.com/reference/android/support/v4/widget/DrawerLayout.html" target="_blank" rel="external">DrawerLayout</a>就是利用它实现扫滑。Flavient Laurent 还写了一些关于这方面的<a href="http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper/" target="_blank" rel="external">优秀文章</a>。</p>
<a id="more"></a>
<p><a href="https://developer.android.com/reference/android/widget/PopupWindow.html" target="_blank" rel="external">PopupWindow</a>——Android到处都在使用PopupWindow ，甚至你都没有意识到（标题导航条ActionBar，自动补全AutoComplete，编辑框错误提醒Edittext Errors）。这个类是创建浮层内容的主要方法。</p>
<p><a href="https://developer.android.com/reference/android/app/ActionBar.htmlgetThemedContext%28%29" target="_blank" rel="external">Actionbar.getThemrContext()</a>——导航栏的主题化是很复杂的（不同于Activity其他部分的主题化）。你可以得到一个上下文（Context），用这个上下文创建的自定义组件可以得到正确的主题。</p>
<p><a href="https://developer.android.com/reference/android/media/ThumbnailUtils.html" target="_blank" rel="external">ThumbnailUtils</a>——帮助创建缩略图。通常我都是用现有的图片加载库（比如，Picasso 或者 Volley），不过这个ThumbnaiUtils可以创建视频缩略图。<strong>译者注：</strong>该API从V8才开始支持。</p>
<p><a href="https://developer.android.com/reference/android/content/Context.htmlgetExternalFilesDir%28java.lang.String%29" target="_blank" rel="external">Context.getExternalFilesDir()</a>———— 申请了SD卡写权限后，你可以在SD的任何地方写数据，把你的数据写在设计好的合适位置会更加有礼貌。这样数据可以及时被清理，也会有更好的用户体验。此外，Android 4.0 Kitkat中在这个文件夹下写数据是不需要权限的，每个用户有自己的独立的数据存储路径。<strong>译者注：</strong>该API从V8才开始支持。</p>
<p><a href="https://developer.android.com/reference/android/util/SparseArray.html" target="_blank" rel="external">SparseArray</a>——Map的高效优化版本。推荐了解姐妹类SparseBooleanArray、SparseIntArray和SparseLongArray。</p>
<p><a href="https://developer.android.com/reference/android/content/pm/PackageManager.htmlsetComponentEnabledSetting%28android.content.ComponentName,%20int,%20int%29" target="_blank" rel="external">PackageManager.setComponentEnabledSetting()</a>——可以用来启动或者禁用程序清单中的组件。对于关闭不需要的功能组件是非常赞的，比如关掉一个当前不用的广播接收器。</p>
<p><a href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.htmlyieldIfContendedSafely%28%29" target="_blank" rel="external">SQLiteDatabase.yieldIfContendedSafely()</a>——让你暂时停止一个数据库事务， 这样你可以就不会占用太多的系统资源。</p>
<p><a href="https://developer.android.com/reference/android/os/Environment.html#getExternalStoragePublicDirectory%28java.lang.String%29" target="_blank" rel="external">Environment.getExternalStoragePublicDirectory()</a>——还是那句话，用户期望在SD卡上得到统一的用户体验。用这个方法可以获得在用户设备上放置指定类型文件（音乐、图片等）的正确目录。</p>
<p><a href="https://developer.android.com/reference/android/view/View.htmlgenerateViewId%28%29" target="_blank" rel="external">View.generateViewId()</a>——每次我都想要推荐动态生成控件的ID。需要注意的是，不要和已经存在的控件ID或者其他已经生成的控件ID重复。</p>
<p><a href="https://developer.android.com/reference/android/app/ActivityManager.htmlclearApplicationUserData%28%29" target="_blank" rel="external">ActivityManager.clearApplicationUserData()</a>—— 一键清理你的app产生的用户数据，可能是做用户退出登录功能，有史以来最简单的方式了。</p>
<p><a href="http://developer.android.com/reference/android/content/Context.htmlcreateConfigurationContext%28android.%E2%80%94%E2%80%94ontent.res.Configuration%29" target="_blank" rel="external">Context.createConfigurationContext()</a> ——自定义你的配置环境信息。我通常会遇到这样的问题：强制让一部分显示在某个特定的环境下（倒不是我一直这样瞎整，说来话长，你很难理解）。用这个实现起来可以稍微简单一点。</p>
<p><a href="http://developer.android.com/reference/android/app/ActivityOptions.html" target="_blank" rel="external">ActivityOptions</a> ——方便的定义两个Activity切换的动画。 使用<a href="http://developer.android.com/reference/android/support/v4/app/ActivityOptionsCompat.html" target="_blank" rel="external">ActivityOptionsCompat</a> 可以很好解决旧版本的兼容问题。</p>
<p><a href="http://developer.android.com/reference/android/widget/AdapterViewFlipper.htmlfyiWillBeAdvancedByHostKThx%28%29" target="_blank" rel="external">AdapterViewFlipper.fyiWillBeAdvancedByHostKThx()</a>——仅仅因为很好玩，没有其他原因。在整个安卓开源项目中（AOSP the Android ——pen Source Project Android开放源代码项目）中还有其他很有意思的东西（比如<br><a href="http://developer.android.com/reference/android/hardware/SensorManager.htmlGRAVITY_DEATH_STAR_I" target="_blank" rel="external">GRAVITY_DEATH_STAR_I</a>）。不过，都不像这个这样，这个确实有用</p>
<p><a href="http://developer.android.com/reference/android/view/ViewParent.htmlrequestDisallowInterceptTouchEvent%28boolean%29" target="_blank" rel="external">ViewParent.requestDisallowInterceptTouchEvent()</a> ——Android系统触摸事件机制大多时候能够默认处理，不过有时候你需要使用这个方法来剥夺父级控件的控制权（顺便说一下，如果你想对Android触摸机制了解更多，<a href="https://www.youtube.com/watch?v=EZAoJU-nUyI" target="_blank" rel="external">这个演讲</a>会令你惊叹不已。）</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-5/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-5/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-5.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第五篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="https://developer.android.com/reference/android/support/v4/widget/ViewDragHelper.html">ViewDragHelper</a> ——视图拖动是一个比较复杂的问题。这个类可以帮助解决不少问题。如果你需要一个例子，<a href="https://developer.android.com/reference/android/support/v4/widget/DrawerLayout.html">DrawerLayout</a>就是利用它实现扫滑。Flavient Laurent 还写了一些关于这方面的<a href="http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper/">优秀文章</a>。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(4)]]></title>
    <link href="http://androidperformance.com/2015/03/15/android-tips-round-up-4/"/>
    <id>http://androidperformance.com/2015/03/15/android-tips-round-up-4/</id>
    <published>2015-03-14T16:31:02.000Z</published>
    <updated>2015-03-27T05:35:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第四篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/app/Activity.html#isChangingConfigurations%28%29" target="_blank" rel="external">Activity.isChangingConfigurations ()</a>——如果在 Activity 中 configuration 会经常改变的话，使用这个方法就可以不用手动做保存状态的工作了。</p>
<a id="more"></a>
<p><a href="http://developer.android.com/reference/android/content/SearchRecentSuggestionsProvider.html" target="_blank" rel="external">SearchRecentSuggestionsProvider</a>——可以创建最近提示效果的 provider，是一个简单快速的方法。</p>
<p><a href="http://developer.android.com/reference/android/view/ViewTreeObserver.html" target="_blank" rel="external">ViewTreeObserver</a>——这是一个很棒的工具。可以进入到 VIew 里面，并监控 View 结构的各种状态，通常我都用来做 View 的测量操作（自定义视图中经常用到）。</p>
<p><a href="https://www.timroes.de/2013/09/12/speed-up-gradle/" target="_blank" rel="external">org.gradle.daemon=true</a>——这句话可以帮助减少 Gradle 构建的时间，仅在命令行编译的时候用到，因为 Android Studio 已经这样使用了。</p>
<p><a href="http://developer.android.com/reference/android/database/DatabaseUtils.html" target="_blank" rel="external">DatabaseUtils</a>——一个包含各种数据库操作的使用工具。</p>
<p><a href="http://developer.android.com/reference/android/widget/LinearLayout.html#attr_android:weightSum" target="_blank" rel="external">android:weightSum (LinearLayout)</a>——如果想使用 layout weights，但是却不想填充整个 LinearLayout 的话，就可以用 weightSum 来定义总的 weight 大小。</p>
<p><a href="http://developer.android.com/reference/android/view/View.html#attr_android:duplicateParentState" target="_blank" rel="external">android:duplicateParentState (View)</a>——此方法可以使得子 View 可以复制父 View 的状态。比如如果一个 ViewGroup 是可点击的，那么可以用这个方法在它被点击的时候让它的子 View 都改变状态。</p>
<p><a href="http://developer.android.com/reference/android/view/ViewGroup.html#attr_android:clipChildren" target="_blank" rel="external">android:clipChildren (ViewGroup)</a>——如果此属性设置为不可用，那么 ViewGroup 的子 View 在绘制的时候会超出它的范围，在做动画的时候需要用到。</p>
<p><a href="http://developer.android.com/reference/android/widget/ScrollView.html#attr_android:fillViewport" target="_blank" rel="external">android:fillViewport (ScrollView)</a>——在这片文章中有详细介绍<a href="http://www.curious-creature.org/2010/08/15/scrollviews-handy-trick/" target="_blank" rel="external">文章链接</a>，可以解决在 ScrollView 中当内容不足的时候填不满屏幕的问题。</p>
<p><a href="http://developer.android.com/guide/topics/resources/drawable-resource.html#Bitmap" target="_blank" rel="external">android:tileMode (BitmapDrawable)</a>——可以指定图片使用重复填充的模式。</p>
<p><a href="http://developer.android.com/reference/android/R.attr.html#exitFadeDuration" target="_blank" rel="external">android:enterFadeDuration/android:exitFadeDuration (Drawables)</a>——此属性在 Drawable 具有多种状态的时候，可以定义它展示前的淡入淡出效果。</p>
<p><a href="http://developer.android.com/reference/android/widget/ImageView.html#attr_android:scaleType" target="_blank" rel="external">android:scaleType (ImageView)</a>——定义在 ImageView 中怎么缩放/剪裁图片，一般用的比较多的是“centerCrop”和“centerInside”。</p>
<p><a href="http://developer.android.com/training/improving-layouts/reusing-layouts.html#Merge" target="_blank" rel="external">Merge</a>——此标签可以在另一个布局文件中包含别的布局文件，而不用再新建一个 ViewGroup，对于自定义 ViewGroup 的时候也需要用到；可以通过载入一个带有标签的布局文件来自动定义它的子部件。</p>
<p><a href="http://developer.android.com/reference/android/util/AtomicFile.html" target="_blank" rel="external">AtomicFile</a>——通过使用备份文件进行文件的原子化操作。这个知识点之前我也写过，不过最好还是有出一个官方的版本比较好。</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-4/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-4/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-4.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第四篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/app/Activity.html#isChangingConfigurations%28%29">Activity.isChangingConfigurations ()</a>——如果在 Activity 中 configuration 会经常改变的话，使用这个方法就可以不用手动做保存状态的工作了。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(3)]]></title>
    <link href="http://androidperformance.com/2015/03/15/android-tips-round-up-3/"/>
    <id>http://androidperformance.com/2015/03/15/android-tips-round-up-3/</id>
    <published>2015-03-14T16:29:57.000Z</published>
    <updated>2015-03-27T05:35:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第三篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/net/UrlQuerySanitizer.html" target="_blank" rel="external">UrlQuerySanitizer</a>——使用这个工具可以方便对 URL 进行检查。</p>
<a id="more"></a>
<p><a href="http://developer.android.com/reference/android/app/Fragment.html#setArguments%28android.os.Bundle%29" target="_blank" rel="external">Fragment.setArguments</a>——因为在构建 Fragment 的时候不能加参数，所以这是个很好的东西，可以在创建 Fragment 之前设置参数（即使在 configuration 改变的时候仍然会导致销毁/重建）。</p>
<p><a href="http://developer.android.com/reference/android/app/DialogFragment.html#setShowsDialog%28boolean%29" target="_blank" rel="external">DialogFragment.setShowsDialog ()</a>—— 这是一个很巧妙的方式，DialogFragment 可以作为正常的 Fragment 显示！这里可以让 Fragment 承担双重任务。我通常在创建 Fragment 的时候把 onCreateView ()和 onCreateDialog ()都加上，就可以创建一个具有双重目的的 Fragment。</p>
<p><a href="http://developer.android.com/reference/android/app/FragmentManager.html#enableDebugLogging%28boolean%29" target="_blank" rel="external">FragmentManager.enableDebugLogging ()</a>——在需要观察 Fragment 状态的时候会有帮助。</p>
<p><a href="http://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html" target="_blank" rel="external">LocalBroadcastManager</a>——这个会比全局的 broadcast 更加安全，简单，快速。像 <a href="http://square.github.io/otto/" target="_blank" rel="external">otto</a> 这样的 Event buses 机制对你的应用场景更加有用。</p>
<p><a href="http://developer.android.com/reference/android/telephony/PhoneNumberUtils.html#formatNumber%28java.lang.String%29" target="_blank" rel="external">PhoneNumberUtils.formatNumber ()</a>——顾名思义，这是对数字进行格式化操作的时候用的。</p>
<p><a href="http://developer.android.com/reference/android/graphics/Region.html#op%28android.graphics.Region,%20android.graphics.Region,%20android.graphics.Region.Op%29" target="_blank" rel="external">Region.op()</a>——我发现在对比两个渲染之前的区域的时候很实用，如果你有两条路径，那么怎么知道它们是不是会重叠呢？使用这个方法就可以做到。</p>
<p><a href="http://developer.android.com/reference/android/app/Application.html#registerActivityLifecycleCallbacks%28android.app.Application.ActivityLifecycleCallbacks%29" target="_blank" rel="external">Application.registerActivityLifecycleCallbacks</a>——虽然缺少官方文档解释，不过我想它就是注册 Activity 的生命周期的一些回调方法（顾名思义），就是一个方便的工具。</p>
<p><a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Build-Types" target="_blank" rel="external">versionNameSuffix</a>——这个 gradle 设置可以让你在基于不同构建类型的 manifest 中修改版本名这个属性，例如，如果需要在在 debug 版本中以”-SNAPSHOT”结尾，那么就可以轻松的看出当前是 debug 版还是 release 版。</p>
<p><a href="http://developer.android.com/reference/android/database/CursorJoiner.html" target="_blank" rel="external">CursorJoiner</a>——如果你是只使用一个数据库的话，使用 SQL 中的 join 就可以了，但是如果收到的数据是来自两个独立的 ContentProvider，那么 CursorJoiner 就很实用了。</p>
<p><a href="http://www.genymotion.com/" target="_blank" rel="external">Genymotion</a>——一个非常快的 Android 模拟器，本人一直在用。</p>
<p><a href="http://developer.android.com/guide/practices/screens_support.html#qualifiers" target="_blank" rel="external">-nodpi</a>——在没有特别定义的情况下，很多修饰符(-mdpi,-hdpi,-xdpi等等)都会默认自动缩放 assets/dimensions，有时候我们需要保持显示一致，这种情况下就可以使用 -nodpi。</p>
<p><a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#setDebugUnregister%28boolean%29" target="_blank" rel="external">BroadcastRecevier.setDebugUnregister ()</a>——又一个方便的调试工具。</p>
<p><a href="http://developer.android.com/reference/android/app/Activity.html#recreate%28%29" target="_blank" rel="external">Activity.recreate ()</a>——强制让 Activity 重建。</p>
<p><a href="http://developer.android.com/reference/android/content/pm/PackageManager.html#checkSignatures%28java.lang.String,%20java.lang.String%29" target="_blank" rel="external">PackageManager.checkSignatures ()</a>——如果同时安装了两个 app 的话，可以用这个方法检查。如果不进行签名检查的话，其他人可以轻易通过使用一样的包名来模仿你的 app。</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-3/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-3/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-3.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第三篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/net/UrlQuerySanitizer.html">UrlQuerySanitizer</a>——使用这个工具可以方便对 URL 进行检查。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为Nexus5编译AndroidL固件]]></title>
    <link href="http://androidperformance.com/2015/02/04/build-rom-for-nexus5/"/>
    <id>http://androidperformance.com/2015/02/04/build-rom-for-nexus5/</id>
    <published>2015-02-04T12:51:19.000Z</published>
    <updated>2015-04-01T13:11:05.000Z</updated>
    <content type="html"><![CDATA[<p>接前一篇文章<a href="http://www.androidperformance.com/view-android-source-code-with-androidstudio.html" target="_blank" rel="external">使用Android Studio查看Android Lollipop源码</a>, 我们知道,仅仅看代码,提高是比较有限的,而且理解起来也比较肤浅,往往过目就忘. 而自己写过的代码,往往会印象比较深刻,在写的时候也会比较容易理解流程. 所以我们在看代码的同时, 如果能修改代码, 在手机上跑起来并看到修改的效果,这无疑会加快看代码的效率和积极性. 所以这篇文章,就讲解一下如何自己编译AndroidL的源码,并且在Nexus5上跑起来. 至于为何需要自己编译固件,而不是直接安装Google给出的工厂固件?原因是Google给出的工厂固件是User版本,是没法随心所欲Push东西进去的. 所以我们需要编译自己的Userdebug版本.</p>
<p>本文假设你已经下载了AndroidL的源码,并且有一台Nexus5手机(手机系统开发人员必备), 如果你还没有AndroidL的源码,或者你有源码但是没有配置编译的环境,那么 <a href="https://source.android.com/source/initializing.html" target="_blank" rel="external">Initializing a Build Environment</a> 和<a href="https://source.android.com/source/downloading.html" target="_blank" rel="external">Downloading the Source</a>这两篇文章你应该先去看一下(我又一次假设你会翻墙,如果你不会翻墙,那么下代码也是一个痛苦的事情). 这后面的教程Google官网也有教程.所以我只针对Nexus5进行讲解.</p>
<p>另外你需要知道AOSP,AOSP即Android Open Source Project 汉语意思是：谷歌开放源代码项目.我们通过Google官方下载的源代码,就是AOSP的代码, 其中是不包含Google开发的那些个应用的,各个厂商拿到的也是这个版本,在这个版本的基础上进行修改. 而Google发布的工厂固件则是包含全套Google服务的. 厂商如果想安装Google服务,就需要过Google的那一套认证,比较麻烦,而且价格不菲,鉴于Google在国内的尴尬地位,国内很多厂商都没有过这个认证.</p>
<a id="more"></a>
<h3 id="1-_初始化编译环境">1. 初始化编译环境</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">. </span>build/envsetup.sh</span><br></pre></td></tr></table></figure>
<h3 id="2-_加载机型">2. 加载机型</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lunch</span><br></pre></td></tr></table></figure>
<h3 id="3-_选择要编译的机器">3. 选择要编译的机器</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">You're building <span class="function_start"><span class="keyword">on</span></span> Linux</span><br><span class="line"></span><br><span class="line">Lunch menu... pick a combo:</span><br><span class="line">     <span class="number">1.</span> aosp_arm-eng</span><br><span class="line">     <span class="number">2.</span> aosp_arm64-eng</span><br><span class="line">     <span class="number">3.</span> aosp_mips-eng</span><br><span class="line">     <span class="number">4.</span> aosp_mips64-eng</span><br><span class="line">     <span class="number">5.</span> aosp_x86-eng</span><br><span class="line">     <span class="number">6.</span> aosp_x86_64-eng</span><br><span class="line">     <span class="number">7.</span> aosp_shamu-userdebug</span><br><span class="line">     <span class="number">8.</span> aosp_manta-userdebug</span><br><span class="line">     <span class="number">9.</span> full_fugu-userdebug</span><br><span class="line">     <span class="number">10.</span> aosp_fugu-userdebug</span><br><span class="line">     <span class="number">11.</span> aosp_grouper-userdebug</span><br><span class="line">     <span class="number">12.</span> aosp_tilapia-userdebug</span><br><span class="line">     <span class="number">13.</span> aosp_deb-userdebug</span><br><span class="line">     <span class="number">14.</span> aosp_flo-userdebug</span><br><span class="line">     <span class="number">15.</span> aosp_mako-userdebug</span><br><span class="line">     <span class="number">16.</span> aosp_hammerhead-userdebug</span><br><span class="line">     <span class="number">17.</span> aosp_flounder-userdebug</span><br><span class="line">     <span class="number">18.</span> mini_emulator_x86_64-userdebug</span><br><span class="line">     <span class="number">19.</span> mini_emulator_arm-userdebug</span><br><span class="line">     <span class="number">20.</span> mini_emulator_x86-userdebug</span><br><span class="line">     <span class="number">21.</span> mini_emulator_mips-userdebug</span><br><span class="line">     <span class="number">22.</span> mini_emulator_arm64-userdebug</span><br></pre></td></tr></table></figure>
<h4 id="3-1_机型对照表">3.1 机型对照表</h4><table>
<thead>
<tr>
<th>DEVICE</th>
<th>CODE NAME</th>
<th>BUILD CONFIGURATION</th>
</tr>
</thead>
<tbody>
<tr>
<td>Nexus 6</td>
<td>shamu</td>
<td>aosp_shamu-userdebug</td>
</tr>
<tr>
<td>Nexus Player</td>
<td>fugu</td>
<td>aosp_fugu-userdebug</td>
</tr>
<tr>
<td>Nexus 9</td>
<td>volantis (flounder)</td>
<td>aosp_flounder-userdebug</td>
</tr>
<tr>
<td>Nexus 5 (GSM/LTE)</td>
<td>hammerhead</td>
<td>aosp_hammerhead-userdebug</td>
</tr>
<tr>
<td>Nexus 7 (Wi-Fi)</td>
<td>razor (flo)</td>
<td>aosp_flo-userdebug</td>
</tr>
<tr>
<td>Nexus 7 (Mobile)</td>
<td>razorg (deb)</td>
<td>aosp_deb-userdebug</td>
</tr>
<tr>
<td>Nexus 10</td>
<td>mantaray (manta)</td>
<td>full_manta-userdebug</td>
</tr>
<tr>
<td>Nexus 4</td>
<td>occam (mako)</td>
<td>full_mako-userdebug</td>
</tr>
<tr>
<td>Nexus 7 (Wi-Fi)</td>
<td>nakasi (grouper)</td>
<td>full_grouper-userdebug</td>
</tr>
<tr>
<td>Nexus 7 (Mobile)</td>
<td>nakasig (tilapia)</td>
<td>full_tilapia-userdebug</td>
</tr>
<tr>
<td>Galaxy Nexus (GSM/HSPA+)</td>
<td>yakju (maguro)</td>
<td>full_maguro-userdebug</td>
</tr>
<tr>
<td>Galaxy Nexus (Verizon)</td>
<td>mysid (toro)</td>
<td>aosp_toro-userdebug</td>
</tr>
<tr>
<td>Galaxy Nexus (Experimental)</td>
<td>mysidspr (toroplus)</td>
<td>aosp_toroplus-userdebug</td>
</tr>
<tr>
<td>PandaBoard (Archived)</td>
<td>panda</td>
<td>aosp_panda-userdebug</td>
</tr>
<tr>
<td>Motorola Xoom (U.S. Wi-Fi)</td>
<td>wingray</td>
<td>full_wingray-userdebug</td>
</tr>
<tr>
<td>Nexus S</td>
<td>soju (crespo)</td>
<td>full_crespo-userdebug</td>
</tr>
<tr>
<td>Nexus S 4G</td>
<td>sojus (crespo4g)</td>
<td>full_crespo4g-userdebug3.2</td>
</tr>
</tbody>
</table>
<h4 id="3-2_三个版本说明版本">3.2 三个版本说明版本</h4><table>
<thead>
<tr>
<th>BUILDTYPE</th>
<th>USE</th>
</tr>
</thead>
<tbody>
<tr>
<td>user</td>
<td>limited access; suited for production</td>
</tr>
<tr>
<td>userdebug</td>
<td>like “user” but with root access and debuggability; preferred for debugging</td>
</tr>
<tr>
<td>eng</td>
<td>development configuration with additional debugging tools</td>
</tr>
</tbody>
</table>
<p>选择aosp_hammerhead-userdebug之后,会有下面的确认信息:</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">============================================</span><br><span class="line"><span class="variable">PLATFORM_VERSION_CODENAME=</span>REL</span><br><span class="line"><span class="variable">PLATFORM_VERSION=</span><span class="number">5.0</span>.<span class="number">50.50</span>.<span class="number">50.50</span></span><br><span class="line"><span class="variable">TARGET_PRODUCT=</span>aosp_hammerhead</span><br><span class="line"><span class="variable">TARGET_BUILD_VARIANT=</span>userdebug</span><br><span class="line"><span class="variable">TARGET_BUILD_TYPE=</span>release</span><br><span class="line"><span class="variable">TARGET_BUILD_APPS=</span></span><br><span class="line"><span class="variable">TARGET_ARCH=</span>arm</span><br><span class="line"><span class="variable">TARGET_ARCH_VARIANT=</span>armv7-a-neon</span><br><span class="line"><span class="variable">TARGET_CPU_VARIANT=</span>krait</span><br><span class="line"><span class="variable">TARGET_2ND_ARCH=</span></span><br><span class="line"><span class="variable">TARGET_2ND_ARCH_VARIANT=</span></span><br><span class="line"><span class="variable">TARGET_2ND_CPU_VARIANT=</span></span><br><span class="line"><span class="variable">HOST_ARCH=</span>x86_64</span><br><span class="line"><span class="variable">HOST_OS=</span>linux</span><br><span class="line"><span class="variable">HOST_OS_EXTRA=</span>Linux-<span class="number">3.13</span>.<span class="number">0</span>-<span class="number">37</span>-generic-x86_64-<span class="keyword">with</span>-Ubuntu-<span class="number">14.10</span>-utopic</span><br><span class="line"><span class="variable">HOST_BUILD_TYPE=</span>release</span><br><span class="line"><span class="variable">BUILD_ID=</span>AOSP</span><br><span class="line"><span class="variable">OUT_DIR=</span><span class="variable">out</span><br><span class="line">=</span>===========================================</span><br></pre></td></tr></table></figure>
<h3 id="4-_生成驱动目录">4. 生成驱动目录</h3><p>接下来需要在<a href="https://developers.google.com/android/nexus/drivers#hammerheadlrx22c" target="_blank" rel="external">Android官网</a>下载 Nexus5所需要的驱动:</p>
<table>
<thead>
<tr>
<th>HARDWARE COMPONENT</th>
<th>COMPANY</th>
<th>DOWNLOAD</th>
<th>MD5 CHECKSUM</th>
<th>SHA-1 CHECKSUM</th>
</tr>
</thead>
<tbody>
<tr>
<td>NFC, Bluetooth, Wi-Fi</td>
<td>Broadcom</td>
<td><a href="https://dl.google.com/dl/android/aosp/broadcom-hammerhead-lrx22c-964d941e.tgz" target="_blank" rel="external">Link</a></td>
<td>2c398994e37093df51b105d63f0eb611</td>
<td>991346159c95ae75f760014a6822b8b3e8667700</td>
</tr>
<tr>
<td>Camera, Sensors, Audio</td>
<td>LG</td>
<td><a href="https://dl.google.com/dl/android/aosp/lge-hammerhead-lrx22c-95a9d465.tgz" target="_blank" rel="external">Link</a></td>
<td>74cf8235e6bb04da28b2ff738b13eee9</td>
<td>175dd5bae81bb54030d072cb0f0b4ec81eb3f71f</td>
</tr>
<tr>
<td>Graphics, GSM, Camera, GPS, Sensors, Media, DSP, USB</td>
<td>Qualcomm</td>
<td><a href="https://dl.google.com/dl/android/aosp/lge-hammerhead-lrx22c-95a9d465.tgz" target="_blank" rel="external">Link</a></td>
<td>0a43395e175d3de3dc312d8abdcb4f20</td>
<td>007cf9d49f0409d5c703e7f2811fd153fee22353</td>
</tr>
</tbody>
</table>
<p>下载完成后,解压出来是三个.sh文件,放到Android源码目录下面,然后执行.会将相关驱动放到vender目录下面.</p>
<h3 id="5-_执行编译命令">5. 执行编译命令</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span> -j8</span><br></pre></td></tr></table></figure>
<p>如果没有出错的话,在经过漫长的时间之后,编译成功:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Installed file <span class="string">list:</span> out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>installed-files.txt</span><br><span class="line">Target system fs <span class="string">image:</span> out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>obj<span class="regexp">/PACKAGING/</span>systemimage_intermediates/system.img</span><br><span class="line"><span class="string">Running:</span>  mkuserimg.sh -s out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>system out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>obj<span class="regexp">/PACKAGING/</span>systemimage_intermediates<span class="regexp">/system.img ext4 system 1073741824 -L system out/</span>target<span class="regexp">/product/</span>hammerhead<span class="regexp">/root/</span>file_contexts</span><br><span class="line">make_ext4fs -s -T -<span class="number">1</span> -S out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>root<span class="regexp">/file_contexts -L system -l 1073741824 -a system out/</span>target<span class="regexp">/product/</span>hammerhead<span class="regexp">/obj/</span>PACKAGING<span class="regexp">/systemimage_intermediates/</span>system.img out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>system</span><br><span class="line">Creating filesystem with <span class="string">parameters:</span></span><br><span class="line"><span class="label">    Size:</span> <span class="number">1073741824</span></span><br><span class="line">    Block <span class="string">size:</span> <span class="number">4096</span></span><br><span class="line">    Blocks per <span class="string">group:</span> <span class="number">32768</span></span><br><span class="line">    Inodes per <span class="string">group:</span> <span class="number">8192</span></span><br><span class="line">    Inode <span class="string">size:</span> <span class="number">256</span></span><br><span class="line">    Journal <span class="string">blocks:</span> <span class="number">4096</span></span><br><span class="line"><span class="label">    Label:</span> system</span><br><span class="line"><span class="label">    Blocks:</span> <span class="number">262144</span></span><br><span class="line">    Block <span class="string">groups:</span> <span class="number">8</span></span><br><span class="line">    Reserved block group <span class="string">size:</span> <span class="number">63</span></span><br><span class="line">Created filesystem with <span class="number">1445</span><span class="regexp">/65536 inodes and 85879/</span><span class="number">262144</span> blocks</span><br><span class="line">Install system fs <span class="string">image:</span> out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>system.img</span><br><span class="line">out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>system.img+out<span class="regexp">/target/</span>product<span class="regexp">/hammerhead/</span>obj<span class="regexp">/PACKAGING/</span>recovery_patch_intermediates/recovery_from_boot.p maxsize=<span class="number">1096212480</span> blocksize=<span class="number">135168</span> total=<span class="number">336629666</span> reserve=<span class="number">11083776</span></span><br></pre></td></tr></table></figure>
<h3 id="6-_刷机命令">6. 刷机命令</h3><p>Nexus5关机状态下,长按音量下+电源,即可进入recovery模式, 然后在源码根目录下执行下面命令:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fastboot</span> -w flashall</span><br></pre></td></tr></table></figure>
<p>刷机成功后会自动重启</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">~/Android-SourceCode fastboot -w flashall</span><br><span class="line">target reported max download size of <span class="number">1073741824</span> bytes</span><br><span class="line">Creating filesystem with parameters:</span><br><span class="line">    Size: <span class="number">13725835264</span></span><br><span class="line">    Block size: <span class="number">4096</span></span><br><span class="line">    Blocks per group: <span class="number">32768</span></span><br><span class="line">    Inodes per group: <span class="number">8144</span></span><br><span class="line">    Inode size: <span class="number">256</span></span><br><span class="line">    Journal blocks: <span class="number">32768</span></span><br><span class="line">    Label: </span><br><span class="line">    Blocks: <span class="number">3351034</span></span><br><span class="line">    Block groups: <span class="number">103</span></span><br><span class="line">    Reserved block group size: <span class="number">823</span></span><br><span class="line">Created filesystem with <span class="number">11</span>/<span class="number">838832</span> inodes and <span class="number">93654</span>/<span class="number">3351034</span> blocks</span><br><span class="line">Creating filesystem with parameters:</span><br><span class="line">    Size: <span class="number">734003200</span></span><br><span class="line">    Block size: <span class="number">4096</span></span><br><span class="line">    Blocks per group: <span class="number">32768</span></span><br><span class="line">    Inodes per group: <span class="number">7472</span></span><br><span class="line">    Inode size: <span class="number">256</span></span><br><span class="line">    Journal blocks: <span class="number">2800</span></span><br><span class="line">    Label: </span><br><span class="line">    Blocks: <span class="number">179200</span></span><br><span class="line">    Block groups: <span class="number">6</span></span><br><span class="line">    Reserved block group size: <span class="number">47</span></span><br><span class="line">Created filesystem with <span class="number">11</span>/<span class="number">44832</span> inodes and <span class="number">5813</span>/<span class="number">179200</span> blocks</span><br><span class="line">--------------------------------------------</span><br><span class="line">Bootloader Version...: HHZ12d</span><br><span class="line">Baseband Version.....: M8974A-<span class="number">2.0</span><span class="number">.50</span><span class="number">.2</span><span class="number">.22</span></span><br><span class="line">Serial Number........: 08ade1a513dc087b</span><br><span class="line">--------------------------------------------</span><br><span class="line">checking product...</span><br><span class="line">OKAY [  <span class="number">0.</span>100s]</span><br><span class="line">sending <span class="string">'boot'</span> (<span class="number">8950</span> KB)<span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">0.</span>500s]</span><br><span class="line">writing <span class="string">'boot'</span><span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">0.</span>784s]</span><br><span class="line">sending <span class="string">'recovery'</span> (<span class="number">9672</span> KB)<span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">0.</span>556s]</span><br><span class="line">writing <span class="string">'recovery'</span><span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">0.</span>814s]</span><br><span class="line">erasing <span class="string">'system'</span><span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">1.</span>166s]</span><br><span class="line">sending <span class="string">'system'</span> (<span class="number">328187</span> KB)<span class="keyword">...</span></span><br><span class="line">OKAY [ <span class="number">10.</span>501s]</span><br><span class="line">writing <span class="string">'system'</span><span class="keyword">...</span></span><br><span class="line">OKAY [ <span class="number">23.</span>623s]</span><br><span class="line">erasing <span class="string">'userdata'</span><span class="keyword">...</span></span><br><span class="line">OKAY [ <span class="number">14.</span>657s]</span><br><span class="line">sending <span class="string">'userdata'</span> (<span class="number">137318</span> KB)<span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">4.</span>520s]</span><br><span class="line">writing <span class="string">'userdata'</span><span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">9.</span>776s]</span><br><span class="line">erasing <span class="string">'cache'</span><span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">0.</span>618s]</span><br><span class="line">sending <span class="string">'cache'</span> (<span class="number">13348</span> KB)<span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">0.</span>630s]</span><br><span class="line">writing <span class="string">'cache'</span><span class="keyword">...</span></span><br><span class="line">OKAY [  <span class="number">1.</span>070s]</span><br><span class="line">rebooting...</span><br><span class="line"></span><br><span class="line">finished. total time: <span class="number">70.</span>095s</span><br></pre></td></tr></table></figure>
<h3 id="7-秀桌面">7.秀桌面</h3><p><img src="/images/build-image-for-nexus-5/Nexus5.png" alt="image"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接前一篇文章<a href="http://www.androidperformance.com/view-android-source-code-with-androidstudio.html">使用Android Studio查看Android Lollipop源码</a>, 我们知道,仅仅看代码,提高是比较有限的,而且理解起来也比较肤浅,往往过目就忘. 而自己写过的代码,往往会印象比较深刻,在写的时候也会比较容易理解流程. 所以我们在看代码的同时, 如果能修改代码, 在手机上跑起来并看到修改的效果,这无疑会加快看代码的效率和积极性. 所以这篇文章,就讲解一下如何自己编译AndroidL的源码,并且在Nexus5上跑起来. 至于为何需要自己编译固件,而不是直接安装Google给出的工厂固件?原因是Google给出的工厂固件是User版本,是没法随心所欲Push东西进去的. 所以我们需要编译自己的Userdebug版本.</p>
<p>本文假设你已经下载了AndroidL的源码,并且有一台Nexus5手机(手机系统开发人员必备), 如果你还没有AndroidL的源码,或者你有源码但是没有配置编译的环境,那么 <a href="https://source.android.com/source/initializing.html">Initializing a Build Environment</a> 和<a href="https://source.android.com/source/downloading.html">Downloading the Source</a>这两篇文章你应该先去看一下(我又一次假设你会翻墙,如果你不会翻墙,那么下代码也是一个痛苦的事情). 这后面的教程Google官网也有教程.所以我只针对Nexus5进行讲解.</p>
<p>另外你需要知道AOSP,AOSP即Android Open Source Project 汉语意思是：谷歌开放源代码项目.我们通过Google官方下载的源代码,就是AOSP的代码, 其中是不包含Google开发的那些个应用的,各个厂商拿到的也是这个版本,在这个版本的基础上进行修改. 而Google发布的工厂固件则是包含全套Google服务的. 厂商如果想安装Google服务,就需要过Google的那一套认证,比较麻烦,而且价格不菲,鉴于Google在国内的尴尬地位,国内很多厂商都没有过这个认证.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之Systrace工具介绍(一)]]></title>
    <link href="http://androidperformance.com/2015/01/30/android-performance-tools-systrace-1/"/>
    <id>http://androidperformance.com/2015/01/30/android-performance-tools-systrace-1/</id>
    <published>2015-01-30T12:24:31.000Z</published>
    <updated>2015-04-01T13:17:14.000Z</updated>
    <content type="html"><![CDATA[<p> 本文是Android性能优化工具系列的第一篇，这个系列主要介绍Android性能优化过程中会使用到的一些工具，以及如何用这些工具来发现问题和解决问题。在性能优化方面，Android有不少性能工具供大家来使用，按照我们一贯地 “发现问题-解决问题”的思路来看，发现问题才是最主要的，一上来就想着如何去解决问题，反而会事倍功半。</p>
<p>这一篇先来简单介绍一下Systrace这个工具。</p>
<h2 id="Systrace简单介绍">Systrace简单介绍</h2><p>Systrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务，View系统等）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。</p>
<p>Systrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。在Android平台中，它主要由3部分组成：</p>
<ul>
<li>内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</li>
<li>数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。</li>
<li>数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录/tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。 从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用Android提供的Trace类来使用Systrace.<br>关于Systrace的官方介绍和使用可以看这里：<a href="http://developer.android.com/tools/help/systrace.html" title="SysTrace官方介绍" target="_blank" rel="external">Systrace</a></li>
</ul>
<a id="more"></a>
<h2 id="Systrace简单使用">Systrace简单使用</h2><p>使用Systrace前，要先了解一下Systrace在各个平台上的使用方法，鉴于大家使用Eclipse和Android Studio的居多，所以直接摘抄官网关于这个的使用方法，不过不管是什么工具，流程是一样的：</p>
<ul>
<li>手机准备好你要进行抓取的界面</li>
<li>点击开始抓取（命令行的话就是开始执行命令）</li>
<li>手机上开始操作</li>
<li>设定好的时间到了之后，会将生成Trace文件，使用Chrome将这个文件打开进行分析</li>
</ul>
<h4 id="Using_Eclipse">Using <strong>Eclipse</strong></h4><ol>
<li><p>In Eclipse, open an Android application project.</p>
<ol>
<li>Switch to the DDMS perspective, by selecting Window &gt; Perspectives &gt; DDMS.</li>
<li>In the Devices tab, select the device on which to run a trace. If no devices are listed, make sure your device is connected via USB cable and that debugging is enabled on the device.</li>
<li>Click the Systrace icon at the top of the Devices panel to configure tracing.</li>
<li>Set the tracing options and click OK to start the trace.</li>
</ol>
</li>
</ol>
<h4 id="Using_Android_Studio">Using <strong> Android Studio</strong></h4><ol>
<li><p>In Android Studio, open an Android application project.</p>
<ol>
<li>Open the Device Monitor by selecting Tools &gt; Android &gt; Monitor.</li>
<li>In the Devices tab, select the device on which to run a trace. If no devices are listed, make sure your device is connected via USB cable and that debugging is enabled on the device.</li>
<li>Click the Systrace icon at the top of the Devices panel to configure tracing.</li>
<li>Set the tracing options and click OK to start the trace.</li>
</ol>
</li>
</ol>
<h4 id="Using_Device_Monitor">Using <strong>Device Monitor</strong></h4><ol>
<li><p>Navigate to your SDK tools/ directory.</p>
<ol>
<li>Run the monitor program.</li>
<li>In the Devices tab, select the device on which to run a trace. If no devices are listed, make sure your device is connected via USB cable and that debugging is enabled on the device.</li>
<li>Click the Systrace icon at the top of the Devices panel to configure tracing.</li>
<li>Set the tracing options and click OK to start the trace.</li>
</ol>
</li>
</ol>
<h4 id="Command_Line_Usage">Command Line Usage</h4><p>命令行形式比较灵活，速度也比较快，一次性配置好之后，以后再使用的时候就会很快就出结果（<strong>强烈推荐</strong>）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd android-sdk/platform-tools/systrace</span><br><span class="line">$ python systrace<span class="class">.py</span> --time=<span class="number">10</span> -o mynewtrace<span class="class">.html</span> sched gfx view wm</span><br></pre></td></tr></table></figure>
<p>从上面的命令可以看到Systrace工具的位置，只需要在Bash中配置好对应的路径和Alias，使用起来还是很快速的。另外User版本是不可以抓Trace的，只有ENG版本或者Userdebug版本才可以。</p>
<p>抓取结束后，会生成对应的Trace文件，注意这个文件只能被Chrome打开。关于如何分析Trace文件，我们下面的章节会讲。不论使用那种工具，在抓取之前都会让选择参数，下面说一下这些参数的意思：</p>
<ul>
<li>-h, —help Show the help message.（帮助）</li>
<li>-o  Write the HTML trace report to the specified file.（即输出文件名，）</li>
<li>-t N, —time=N Trace activity for N seconds. The default value is 5 seconds. （Trace抓取的时间，一般是 ： -t 8）</li>
<li>-b N, —buf-size=N Use a trace buffer size of N kilobytes. This option lets you limit the total size of the data collected during a trace.</li>
<li>-k</li>
<li>—ktrace= Trace the activity of specific kernel functions, specified in a comma-separated list.</li>
<li><p>-l, —list-categories List the available tracing category tags. The available tags are(下面的参数不用翻译了估计大家也看得懂，贴官方的解释也会比较权威，后面分析的时候我们会看到这些参数的作业的):</p>
<ul>
<li><strong>gfx</strong> - Graphics</li>
<li><strong>input</strong> - Input</li>
<li><strong>view</strong> - View</li>
<li>webview - WebView</li>
<li><strong>wm</strong> - Window Manager</li>
<li><strong>am</strong> - Activity Manager</li>
<li>audio - Audio</li>
<li>video - Video</li>
<li>camera - Camera</li>
<li>hal - Hardware Modules</li>
<li>res - Resource Loading</li>
<li><strong>dalvik</strong> - Dalvik VM</li>
<li>rs - RenderScript</li>
<li><strong>sched</strong> - CPU Scheduling</li>
<li><strong>freq</strong> - CPU Frequency</li>
<li><strong>membus</strong> - Memory Bus Utilization</li>
<li><strong>idle</strong> - CPU Idle</li>
<li><strong>disk</strong> - Disk input and output</li>
<li><strong>load</strong> - CPU Load</li>
<li><strong>sync</strong> - Synchronization Manager</li>
<li><strong>workq</strong> - Kernel Workqueues Note: Some trace categories are not supported on all devices. Tip: If you want to see the names of tasks in the trace output, you must include the sched category in your command parameters.</li>
</ul>
</li>
<li><p>-a</p>
</li>
<li>—app= Enable tracing for applications, specified as a comma-separated list of package names. The apps must contain tracing instrumentation calls from the Trace class. For more information, see Analyzing Display and Performance.</li>
<li>—link-assets Link to the original CSS or JavaScript resources instead of embedding them in the HTML trace report.</li>
<li>—from-file= Create the interactive Systrace report from a file, instead of running a live trace.</li>
<li>—asset-dir= Specify a directory for the trace report assets. This option is useful for maintaining a single set of assets for multiple Systrace reports.</li>
<li>-e</li>
<li>—serial= Conduct the trace on a specific connected device, identified by its device serial number.<br>上面的参数虽然比较多，但使用工具的时候不需考虑这么多，在对应的项目前打钩即可，命令行的时候才会去手动加参数：</li>
</ul>
<p>我们一般会把这个命令配置成Alias，配置如下：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias <span class="keyword">st</span>-start=<span class="string">'python /home/gaojianwu/Software/android-studio/sdk/platform-tools/systrace/systrace.py'</span>  </span><br><span class="line">alias <span class="keyword">st</span>-start-gfx-trace = ‘<span class="keyword">st</span>-start -<span class="keyword">t</span> <span class="number">8</span> gfx <span class="built_in">input</span> <span class="keyword">view</span> sched freq wm <span class="keyword">am</span> hwui workq <span class="keyword">res</span> dalvik <span class="keyword">sync</span> disk load perf hal rs idle mmc’</span><br></pre></td></tr></table></figure>
<p>这样在使用的时候，可以直接敲 <strong>st-start-gfx-mx4</strong> 即可，当然为了区分和保持各个文件，还需要加上 <strong>-o xxx.Trace</strong> .上面的命令和参数不必一次就理解，只需要记住如何简单使用即可，在分析的过程中，这些东西都会慢慢熟悉的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 本文是Android性能优化工具系列的第一篇，这个系列主要介绍Android性能优化过程中会使用到的一些工具，以及如何用这些工具来发现问题和解决问题。在性能优化方面，Android有不少性能工具供大家来使用，按照我们一贯地 “发现问题-解决问题”的思路来看，发现问题才是最主要的，一上来就想着如何去解决问题，反而会事倍功半。</p>
<p>这一篇先来简单介绍一下Systrace这个工具。</p>
<h2 id="Systrace简单介绍">Systrace简单介绍</h2><p>Systrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务，View系统等）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。</p>
<p>Systrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。在Android平台中，它主要由3部分组成：</p>
<ul>
<li>内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</li>
<li>数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。</li>
<li>数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录/tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。 从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用Android提供的Trace类来使用Systrace.<br>关于Systrace的官方介绍和使用可以看这里：<a href="http://developer.android.com/tools/help/systrace.html" title="SysTrace官方介绍">Systrace</a></li>
</ul>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Android Studio查看Android Lollipop源码]]></title>
    <link href="http://androidperformance.com/2015/01/16/view-android-source-code-with-androidstudio/"/>
    <id>http://androidperformance.com/2015/01/16/view-android-source-code-with-androidstudio/</id>
    <published>2015-01-16T13:54:32.000Z</published>
    <updated>2015-04-01T13:25:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Android_Studio">Android Studio</h2><p>作为Google的亲儿子,Nexus手机系列所收到的待遇大家有目共睹.Android5.0出来之后,Nexus5第一时间就升级到了最新的系统.那么作为Google亲儿子的Android Studio同样备受Google的重视,我也是第一时间从Eclipse转投到了Android Studio的怀抱中,从最初的测试版本一路升级到现在的1.0正式版本(今天发布了1.1,果断已经升级了),关于Android Studio的好处我就不用说了,下面两点就足矣让你转投Android Studio了:</p>
<ul>
<li>Android Studio是Google官方指定的,目前官网已经去掉了ADT, 大家可以在<a href="http://developer.android.com/sdk/installing/index.html" target="_blank" rel="external">Android开发者官网</a> 中进行查看,目前只有Android Studio提供下载了.</li>
<li>Google也表示ADT不再进行维护了.<br>转投Android Studio时大势所趋,网上关于如何使用Android Studio的帖子也是满天飞,所以我就不再啰嗦夸奖Android Studio了.看一下下面的图,估计你就会很有欲望了.想查看详细的内容,可以查看<a href="http://developer.android.com/tools/studio/index.html" target="_blank" rel="external">Android Studio官方文档</a></li>
</ul>
<p><img src="/images/view-android-source-code-with-androidstudio/androidstudio.png" alt="Android Studio Preview"></p>
<a id="more"></a>
<h2 id="Android_5-0_:_Lollipop">Android 5.0 : Lollipop</h2><p>Android Lollipop是Google在今年推出的,关于Lollipop的详细介绍可以查看<a href="\&quot;http://developer.android.com/about/versions/lollipop.html\&quot;">Lollipop官方介绍</a> ,我也就不多说了.作为一个开发者,我们不应该停留在表面(即Lollipop的绚丽的界面,和新奇的设计语言<a href="\&quot;http://developer.android.com/about/versions/lollipop.html#Material\&quot;">Material design</a>),我们更要了解其中的原理.</p>
<h2 id="准备工作">准备工作</h2><p>在使用Android Studio查看源码之前,你需要做下面几件事:</p>
<ul>
<li>下载Android Lollipop源码(当然不一定非要是Lollipop源码,其他的版本也是可以的)</li>
<li>进行过一次完整编译(不编译是无法进行源码导入工作的)<br>以上操作可以参考<a href="https://source.android.com/source/initializing.html" target="_blank" rel="external">Google 官方教程</a> 以确保万无一失(呵呵).上面的几个链接需要翻墙才可以访问,不过有兴趣看这篇文章的人,大部分应该都是知道VPN的.或者没有VPN不会翻墙的,速度去卖一个VPN,能花钱解决的事情,就不要花时间.</li>
</ul>
<h2 id="开始">开始</h2><ul>
<li>进入Android 源码根目录</li>
<li>执行<br><code>mmm development/tools/idegen/</code><br>这行命令的意思是编译idegen这个项目,生成idegen.jar文件.生成成功后,会显示这个jar包的位置,并显示<br><code>make completed successfully (43 seconds)</code> ,如果编译失败了,后面会讲到这种情况(比较少见)</li>
<li>执行<br><code>sh ./development/tools/idegen/idegen.sh</code><br>这行命令的意思是生成对应的文件:android.iws, android.ipr, android.iml .如果生成失败,后面也会讲到这种情况.</li>
<li>生成对应的文件后,打开Android Studio,选择打开一个现有的Android Studio项目,选择Android源码的根目录,导入即可(起作用的是android.irp文件).在配置sdk版本之后就可以查看Android 源码了.</li>
<li>已经完成了,没有下一步了.</li>
</ul>
<h2 id="问题">问题</h2><ul>
<li><p>执行第一个命令的时候编译不过,出现这种情况的原因有好几种:</p>
<ul>
<li>Android 源码没有下载完全</li>
<li>没有进行全部编译</li>
<li>环境变量配置有问题解决方法依问题而定,网上对应的帖子很多,可以自己去找. 推荐这种问题还是去<a href="\&quot;http://www.jianshu.com/p/www.google.com\&quot;">Google</a> 和<a href="\&quot;http://www.jianshu.com/p/www.stackoverflow.com\&quot;">StackOverFlow</a> 上去问.</li>
</ul>
</li>
<li><p>执行第二个命令的时候,碰到下面的问题:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread \<span class="string">"main\" java.io.FileNotFoundException: ./out/target/product/hammerhead/obj/GYP/shared_intermediates/res.java (Is a directory)</span><br><span class="line"></span>at java.io.FileInputStream.<span class="keyword">open</span>(Native Method)</span><br><span class="line">at java.io.FileInputStream.&amp;<span class="keyword">lt</span>;init&amp;gt;(FileInputStream.jav<span class="variable">a:138</span>)</span><br><span class="line">at java.io.FileReader.&amp;<span class="keyword">lt</span>;init&amp;gt;(FileReader.jav<span class="variable">a:72</span>)</span><br><span class="line">at Configuration.parsePackageName(Configuration.jav<span class="variable">a:204</span>)</span><br><span class="line">at Configuration.rootOf(Configuration.jav<span class="variable">a:180</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:140</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.traverse(Configuration.jav<span class="variable">a:167</span>)</span><br><span class="line">at Configuration.&amp;<span class="keyword">lt</span>;init&amp;gt;(Configuration.jav<span class="variable">a:72</span>)</span><br><span class="line">at Main.main(Main.jav<span class="variable">a:37</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>解决办法是将<br><code>./out/target/product/hammerhead/obj/GYP/shared_intermediates/res.java</code><br>修改为:<br><code>./out/target/product/hammerhead/obj/GYP/shared_intermediates/res.j</code><br>即可.</p>
<h2 id="后记">后记</h2><p>使用Android Studio看Android源码很爽，下面是他们的优缺点：</p>
<h4 id="优点">优点</h4><ul>
<li>和Android 完美结合</li>
<li>代码提示很全</li>
<li>代码跳转很强</li>
<li>IDE比Eclipse好看(我说的是黑色主题)</li>
<li>插件很强大(底层是IDEA你懂得)</li>
<li>免费(SourceInsight负分,啥?你用的破解版? 当我没说)</li>
</ul>
<h4 id="缺点">缺点</h4><ul>
<li>对C＋＋代码的支持不是很好</li>
<li>有一定的上手难度</li>
</ul>
<p>本文简书地址：<a href="http://www.jianshu.com/p/c85984cf99e2" target="_blank" rel="external">http://www.jianshu.com/p/c85984cf99e2 </a>欢迎大家点喜欢</p>
<blockquote>
<p>作者：<a href="http://weibo.com/1315612820/profile?topnav=1&amp;wvr=6" target="_blank" rel="external">Gracker</a></p>
<p>出处：<a href="http://androidperformance.com/2015/01/16/view-android-source-code-with-androidstudio/" target="_blank" rel="external">androidperformance.com</a></p>
<p>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
<p>打赏一下： <a href="http://weibo.com/p/1001603801588257955883?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod" target="_blank" rel="external">微博打赏</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Android_Studio">Android Studio</h2><p>作为Google的亲儿子,Nexus手机系列所收到的待遇大家有目共睹.Android5.0出来之后,Nexus5第一时间就升级到了最新的系统.那么作为Google亲儿子的Android Studio同样备受Google的重视,我也是第一时间从Eclipse转投到了Android Studio的怀抱中,从最初的测试版本一路升级到现在的1.0正式版本(今天发布了1.1,果断已经升级了),关于Android Studio的好处我就不用说了,下面两点就足矣让你转投Android Studio了:</p>
<ul>
<li>Android Studio是Google官方指定的,目前官网已经去掉了ADT, 大家可以在<a href="http://developer.android.com/sdk/installing/index.html">Android开发者官网</a> 中进行查看,目前只有Android Studio提供下载了.</li>
<li>Google也表示ADT不再进行维护了.<br>转投Android Studio时大势所趋,网上关于如何使用Android Studio的帖子也是满天飞,所以我就不再啰嗦夸奖Android Studio了.看一下下面的图,估计你就会很有欲望了.想查看详细的内容,可以查看<a href="http://developer.android.com/tools/studio/index.html">Android Studio官方文档</a></li>
</ul>
<p><img src="/images/view-android-source-code-with-androidstudio/androidstudio.png" alt="Android Studio Preview"></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之过渡绘制( 二)]]></title>
    <link href="http://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2/"/>
    <id>http://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2/</id>
    <published>2015-01-13T11:38:53.000Z</published>
    <updated>2015-04-02T08:06:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>上一篇<a href="http://www.androidperformance.com/android-performance-optimization-overdraw-1.html" target="_blank" rel="external">文章</a>从理论的角度讲解了一下什么是过渡绘制，以及可以用来查看和确认过渡绘制的工具，还提供了一些优化过渡绘制的方法。对代码和布局比较熟悉的人，看完上一篇其实就已经可以对自己的应用进行优化了。我记得有人说过，用iphone你只需要保证苹果有节操即可，用Android你就得保证所有的Android开发者都有节操。但现实是残酷的，现在Android市场上，有很多粗制滥造的应用，其中不乏大厂之作，各位打开过渡绘制按钮，就知道我所言非虚。作为一个Android开发人员，我肯定是更希望Android能一步一步好起来，超越iphone。</p>
<p>这篇文章从实战的角度，讲解了一个过渡绘制的优化过程。当然这里用到的只是很少的一部分，毕竟每个应用差别很大，优化方式也各不一样。所以这篇文章仅供参考，想把这块做好还是要下功夫的。</p>
<p>如果没有看过前一篇，可以点这里：<a href="http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/" target="_blank" rel="external">Android性能优化之过渡绘制(一)</a></p>
<hr>
<a id="more"></a>
<h2 id="定位过渡绘制区域">定位过渡绘制区域</h2><h3 id="打开GPU过渡绘制选项:">打开GPU过渡绘制选项:</h3><p>设置—辅助功能—开发人员工具—硬件加速渲染—调试GPU过渡绘制— 显示过渡绘制区域.</p>
<h3 id="清理后台">清理后台</h3><p>Kill掉(即清后台)要测试的应用,重新打开就可以看到效果.下面以文件管理器和设置为例子,如下图</p>
<p><img src="/images/overdraw-1/filemanager-1.png" alt="文件管理器"><img src="/images/overdraw-1/settings.png" alt="设置"></p>
<p>从图上可以看出,按照过渡绘制从好到坏(蓝-绿-粉红-红)来看,文件管理器的过渡绘制是非常严重的,而设置界面的过渡绘制则在可以接受的范围内.下面就以文件管理器为主要分析对象,来看看如何对文件管理器的过渡绘制进行优化.</p>
<h3 id="从文件管理器的图,分析出过渡绘制区域:-">从文件管理器的图,分析出过渡绘制区域:.</h3><ul>
<li>首先看最上面的ActionBar和最下面的SmartBar,对比设置界面的ActionBar就可以知道,整个文件管理器存在一个不透明的背景,导致每次绘制时,都要先绘制这个看不见且不透明的背景.这个背景一般是应用的主题自带的背景,所以GPU过渡绘制显示其位蓝色,这个背景是可以进行优化的.</li>
<li>中间的内容部分,最底层是绿色,说明进行了2x的过渡绘制,去掉第一条我们提的那个全局背景,还有一层背景,也就是1x的过渡绘制,对比setting可知,这个背景色也是可以去掉的.</li>
<li>最容易看出的是这两条,我们先分析和优化这两条,然后再进行其他的优化.</li>
</ul>
<h2 id="优化过渡绘制区域">优化过渡绘制区域</h2><p>在进行位置确认后，我们大概确定了过渡绘制的区域,让我们来使用工具来进行验证和View确认.</p>
<p>打开Monitor(Eclipse和Android Studio中都有快捷打开按钮,即DDMS,右上角选择 Hierarchy View,大概使用如图</p>
<p><img src="/images/overdraw-1/HierarchyView-1.png" alt="Hierarchy View"></p>
<p>其中根节点:PhoneWindos$DecorView是整个视图的根节点,唯一的子节点是ActionBarOverlayLayout,这个Layout包含了ActionBar,应用程序,以及SmartBar.</p>
<p>下面讲述如何从Hierarchy View结合代码分析出需要进行修改的区域</p>
<h3 id="去除默认背景">去除默认背景</h3><p>上面分析过渡绘制区域的第一条,整个window存在一个背景,所以进行了一次重绘,这个背景的重绘是系统级别的,和主题有关,即这个背景是属于ActionBarOverlayLayout的.这种类型的过渡绘制解决也比较方便,在文件管理器的主Activity的onCreate方法中,加入</p>
<p><code>this.getWindow().setBackgroundDrawableResource(android.R.color.transparent);</code></p>
<p>就可以将这个看不见的主题背景去掉.下面是去掉主题背景后的效果图(一张是划开,一张是没有划开):</p>
<p><img src="/images/overdraw-1/filemanager-2.png" alt="文件管理器"><img src="/images/overdraw-1/filemanager-3.png" alt="文件管理器"></p>
<p>对比优化前的图可以发现,背景被去掉之后,少了一层过渡绘制. ActionBar上的蓝色已经消失了.中间的内容由绿色变为蓝色</p>
<h3 id="消除子控件背景">消除子控件背景</h3><p>上面分析的第二条说”<strong>中间的内容部分,最底层是绿色,说明进行了2x的过渡绘制</strong>”,现在中间部分变成了蓝色,但是这是一个全局的背景,导致右边的view拉过来之后,还是存在大量的红色和绿色. 继续分析Hierarchy View,找到中间view对应的视图:DragRelativeLayout,查看源码可知,DragRelativeLayout继承自公共控件:SlidingMenu ，SlidingMenu 由CustomViewAbove和CustomViewBehind组成,前者是上面可以左右拉动的那部分,后者是底部不能拉动的那部分(这个从HierarchyView中也可以看出来:如下图所示:</p>
<p><img src="/images/overdraw-1/HierarchyView-2.png" alt="Hierarchy View"></p>
<p>点击CustomViewBehind,查看其所占的区域,就可以发现背景是这个View进行绘制的,打开CustomViewBehind的代码可以发现其构造函数中包含下面的代码:<br><code>setBackgroundColor(getResources().getColor(R.color.mz_slidingmenu_background_light));</code><br>这个背景是不需要的,查看源码可知,这个view会在SlidingMenu.setMenu的时候,被覆盖掉,还是看不到的.所以这一层view是可以去掉的.下面是去掉一层背景之后的预览图:</p>
<p><img src="/images/overdraw-1/filemanager-4.png" alt="文件管理器"><img src="/images/overdraw-1/filemanager-5.png" alt="文件管理器"></p>
<p>可以看到这一层背景去掉之后,过渡绘制减轻了很多.</p>
<h3 id="进一步优化">进一步优化</h3><p>接着进行分析,可以看到CustomViewAbove也是存在一个过渡绘制的背景的,查看Hierarchy View的CustomViewAbove的子节点,可以看到过渡绘制是由ListView导致的.其id为:FilesList,在代码中找到它,并对他进行分析.在我将PartitionItemLayout中onDraw()函数的setBounds去掉之后,过渡绘制进一步改善了(但是ListItem的View的颜色也比之前要浅了,这一步优化需要根据具体情况进行) 下面是优化后的效果图:</p>
<p><img src="/images/overdraw-1/filemanager-6.png" alt="文件管理器"><img src="/images/overdraw-1/filemanager-7.png" alt="文件管理器"></p>
<p>可以看到图中的过渡绘制已经非常少了.!点个赞!</p>
<hr>
<h2 id="优化代码">优化代码</h2><h3 id="Lint工具">Lint工具</h3><p>Lint工具的使用比较简单,根据给出的提示做对应的修改即可.有时候需要工具具体情况来确定是否需要修改. 下图是一个简单地例子.箭头处提示这个Layout或者它的父Layout是不必须的.具体修改方法即去掉FrameLayout,将RelativeLayout提升为根VIew即可.</p>
<p><img src="/images/overdraw-1/lint-1.png" alt="Lint"></p>
<p>Lint工具还会针对代码中潜在的不合理或者Bed Code做出修改意见.比较重要的提示包括</p>
<ul>
<li>声明但是没有使用的变量</li>
<li>可能会产生的空指针</li>
<li>没必要书写的return,continue</li>
<li>复杂代码的简化写法</li>
<li>for循环的简化写法:foreach</li>
<li>无效的判空</li>
<li>空if</li>
<li>无效或者未使用的import</li>
</ul>
<h3 id="使用Tracer_For_OpenGL_ES">使用Tracer For OpenGL ES</h3><p>Tracer工具也在Android Device Monitor中.点击右上角的Tracer for OpenGL ES按钮就可以进入(如果没有这个按钮,点击旁边的Open Perspective按钮,从选项中选择Tracer for OpenGL ES即可).初次打开Tracer工具,里面是没有内容的,点击右上角的两个按钮(一个是打开现有的GLTrace文件,另一个是新建GLTrace文件)。点击Trace按钮, 手机会自动启动应用程序并启动对应的Activity,当手机上的内容完全绘制出来之后,就可以点击Stop按钮,生成GlTrace文件.文件会自动打开.</p>
<p><img src="/images/overdraw-1/Tracer-1.png" alt="Tracer"></p>
<p>分析GLTrace文件，下图是优化过后的图,对比优化前的图可以发现,优化后不会去绘制默认的背景图和CustomViewBehind的背景图.</p>
<p><img src="/images/overdraw-1/Tracer-2.png" alt="Tracer"></p>
<p>这只是一帧的绘制,如果多操作几下生成多个帧的绘制trace文件,会发现这两个背景会被多次的重绘,去掉后不仅会减轻过渡绘制,也会加快GUP的绘制速度.</p>
<hr>
<h2 id="参考资料">参考资料</h2><ol>
<li><a href="http://www.curious-creature.org/2012/12/01/android-performance-case-study/" target="_blank" rel="external">优化过程</a></li>
<li><a href="http://blog.csdn.net/yihongyuelan/article/details/12169647" target="_blank" rel="external">反编译并添加gpu显示</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/reusing-layouts.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/reusing-layouts.html </a></li>
<li><a href="http://developer.android.com/training/improving-layouts/loading-ondemand.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/loading-ondemand.html</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/smooth-scrolling.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/smooth-scrolling.html </a></li>
<li><a href="http://developer.android.com/tools/help/hierarchy-viewer.html" target="_blank" rel="external">http://developer.android.com/tools/help/hierarchy-viewer.html</a></li>
<li><a href="http://tools.android.com/tips/lint" target="_blank" rel="external">http://tools.android.com/tips/lint</a></li>
</ol>
<hr>
<blockquote>
<p>作者：<a href="http://weibo.com/1315612820/profile?topnav=1&amp;wvr=6" target="_blank" rel="external">Gracker</a></p>
<p>出处：<a href="http://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2/" target="_blank" rel="external">androidperformance.com</a></p>
<p>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
<p>打赏一下： <a href="http://weibo.com/p/1001603801588257955883?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod" target="_blank" rel="external">微博打赏</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>上一篇<a href="http://www.androidperformance.com/android-performance-optimization-overdraw-1.html">文章</a>从理论的角度讲解了一下什么是过渡绘制，以及可以用来查看和确认过渡绘制的工具，还提供了一些优化过渡绘制的方法。对代码和布局比较熟悉的人，看完上一篇其实就已经可以对自己的应用进行优化了。我记得有人说过，用iphone你只需要保证苹果有节操即可，用Android你就得保证所有的Android开发者都有节操。但现实是残酷的，现在Android市场上，有很多粗制滥造的应用，其中不乏大厂之作，各位打开过渡绘制按钮，就知道我所言非虚。作为一个Android开发人员，我肯定是更希望Android能一步一步好起来，超越iphone。</p>
<p>这篇文章从实战的角度，讲解了一个过渡绘制的优化过程。当然这里用到的只是很少的一部分，毕竟每个应用差别很大，优化方式也各不一样。所以这篇文章仅供参考，想把这块做好还是要下功夫的。</p>
<p>如果没有看过前一篇，可以点这里：<a href="http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/">Android性能优化之过渡绘制(一)</a></p>
<hr>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之过渡绘制(一)]]></title>
    <link href="http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/"/>
    <id>http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/</id>
    <published>2014-10-20T15:19:23.000Z</published>
    <updated>2015-04-02T02:29:23.000Z</updated>
    <content type="html"><![CDATA[<p>博客有一段时间没有更新了，到了新公司后，一直比较忙，博客也更新地不那么频繁了，倒是利用这个VPS搭建的VPN每天都在用，速度也蛮不错的。最近一直在看Android上和性能相关的部分，也就是所谓的Android性能优化，才发现Android性能这一块，自己懂得还是太少了，所以从上层开始看，也算是一点一点入门吧。这个系列将讲解学习过程中总结的和性能相关的内容。</p>
<p>首先将讲解一下GPU过渡绘制，也是开发者最直接接触的部分吧，这个内容将分为两个部分来将讲，第一部分初步讲解一下gpu过渡绘制的原理，和一些优化建议，第二部分将用实际例子来讲解优化GPU过渡绘制的一般步骤。</p>
<h2 id="过渡绘制概念">过渡绘制概念</h2><p>GPU过渡绘制的概念：GPU过度绘制指的是在屏幕一个像素上绘制多次(超过一次),比如一个TextView后有背景，那么显示文本的像素至少绘了两次，一次是背景，一次是文本。GPU过度绘制或多或少对性能有些影响,设备的内存带宽是有限的，当过度绘制导致应用需要更多的带宽(超过了可用带宽)的时候性能就会降低。带宽的限制每个设备都可能是不一样的。</p>
<a id="more"></a>
<h2 id="过渡绘制的原因">过渡绘制的原因</h2><ol>
<li>太多的View叠加</li>
<li>复杂的层级叠加</li>
<li>更长的inflation时间</li>
</ol>
<h2 id="过渡绘制和不合理的xml布局的影响">过渡绘制和不合理的xml布局的影响</h2><ol>
<li>布局文件是一个xml文件，inflate布局文件其实就是解析xml，根据标签信息创建相应的布局对象并做关联。xml中的标签和属性设置越多，节点树的深度越深，在解析时要执行的判断逻辑、函数的嵌套和递归就越多，所以时间消耗越多；</li>
<li>inflate操作只是布局影响的第一个环节，一个界面要显示出来，在requestLayout后还要执行一系列的measure、layout、draw的操作，每一步的执行时间都会受到布局本身的影响。而界面的最终显示是所有这些操作完成后才实现的，所以如果布局质量差，会增加每一步操作的时间成本，最终显示时间就会比较长。</li>
</ol>
<h2 id="过渡绘制的一些基本概念:">过渡绘制的一些基本概念:</h2><p>Android提供了三个工具来帮助辨别和解决重绘问题：Hierachy Viewer，Tracer for OpenGL和Show GPU overdraw。前两个可以在ADT工具或者独立的monitor工具中找到，最后一个是在开发者选项的一部分.</p>
<ol>
<li>GPU过渡绘制测试:对于过度绘制的测试主要通过人工进行测试，也是发现应用过渡绘制的首选途径 .通过打开开发者选项中的 显示GPU过度绘制(魅族手机:设置—辅助功能—开发人员工具—硬件加速渲染—调试GPU过渡绘制— 显示过渡绘制区域. (魅族手机需要打开开发者模式：需要在电话界面输入: <em>#</em>#6961#<em>#</em> )) 来进行测试（PS：只有android4.2及以上的版本才具备此功能)</li>
<li>颜色标识: GPU过渡绘制从好到差:蓝-绿-淡红-红<ul>
<li>蓝色1x过度绘制</li>
<li>绿色2x过度绘制</li>
<li>淡红色3x过度绘制</li>
<li>红色超过4x过度绘制</li>
</ul>
</li>
<li>验收标准:<ul>
<li>控制过度绘制为2x</li>
<li>不允许存在4x过度绘制</li>
<li>不允许存在面积超过屏幕1/4区域的3x过度绘制（淡红色区域）</li>
</ul>
</li>
</ol>
<h2 id="优化工具介绍">优化工具介绍</h2><ol>
<li>Lint工具:<ul>
<li>Eclipse中,点击即可,下面的窗口中会出现提示,根据提示和具体解决办法消除.</li>
<li>Android Studio自带Lint工具,不合理或者需要优化和注意的地方,会用黄色标记出来.</li>
<li>Lint工具不仅对布局有很好的优化建议,对代码中不合理的活着存在潜在风险的模块也会提出优化建议,所以一个好的建议是:多使用Lint工具检查自己的应用,尽量消除所有的建议.</li>
<li>Lint工具可以用命令行来运行,具体使用可以参考:<a href="tools.android.com">tools.android.com</a><br><img src="/images/overdraw-1/lint.png" alt="Lint"></li>
</ul>
</li>
<li><p>Lint工具的提升例子(摘自官方文档):</p>
<ul>
<li>Use compound drawables(使用compound drawables) - A LinearLayout which contains an ImageView and a TextView can be more efficiently handled as a compound drawable.</li>
<li>Merge root frame(使用Merge根框架) - If a FrameLayout is the root of a layout and does not provide background or padding etc, it can be replaced with a merge tag which is slightly more efficient.</li>
<li>Useless leaf(去除无用的分支) - A layout that has no children or no background can often be removed (since it is invisible) for a flatter and more efficient layout hierarchy.</li>
<li>Useless parent (去除无用的父控件)- A layout with children that has no siblings, is not a ScrollView or a root layout, and does not have a background, can be removed and have its children moved directly into the parent for a flatter and more efficient layout hierarchy.</li>
<li>Deep layouts (注意Layout的深度) - Layouts with too much nesting are bad for performance. Consider using flatter layouts such as RelativeLayout or GridLayout to improve performance. The default maximum depth is</li>
</ul>
</li>
<li><p>Hierarchy Viewer:此工具是一个ADT工具（或者monitor,最新版本的SDK建议不使用独立的HV工具,而是直接在monitor中进行操作.）的一部分，可以被用作对视图层级进行快速解读。在处理布局问题时特别有用，对于性能问题也很适用。Hierarchy Viewer默认只能在非加密设备使用，例如工程机，工程平板或者模拟器。为了能够在任何手机上使用Hierarchy Viewer，你得在你的应用中添加ViewServer，这是一个开源库,使用方法可以参考这里。连接上设备，打开Hierarchy Viewer(定位到tools/目录下，直接执行hierarchyviewer的命令，选定需要查看的Process，再点击Load View Hierarchy会显示出当前界面的布局Tree。在每个模块的Traffic light上有三个灯，分别代表了Measure, Layout and Draw三个步骤的性能。</p>
</li>
</ol>
<h2 id="布局优化建议">布局优化建议</h2><p>在Android UI布局过程中，通过遵守一些惯用、有效的布局原则，我们可以制作出高效且复用性高的UI，概括来说包括如下几点：</p>
<ul>
<li><p>尽量多使用RelativeLayout和LinearLayout, 不要使用绝对布局AbsoluteLayout，</p>
<ul>
<li>在布局层次一样的情况下， 建议使用LinearLayout代替RelativeLayout, 因为LinearLayout性能要稍高一点.</li>
<li>在完成相对较复杂的布局时,建议使用RelativeLayout,RelativeLayout可以简单实现LinearLayout嵌套才能实现的布局.</li>
</ul>
</li>
<li><p>将可复用的组件抽取出来并通过include标签使用；</p>
</li>
<li>使用ViewStub标签来加载一些不常用的布局；</li>
<li>动态地inflation view性能要比SetVisiblity性能要好.当然用VIewStub是最好的选择.</li>
<li>使用merge标签减少布局的嵌套层次</li>
<li><p>去掉多余的背景颜色(查看背景颜色是否多余,可以将HierarchyView中的图导出为psd文件,然后用Photoshop查看.具体可以参考这个<a href="https://www.youtube.com/watch?v=URyoiAt8098" target="_blank" rel="external">视频</a>)</p>
<ul>
<li>对于有多层背景颜色的Layout来说,留最上面一层的颜色即可,其他底层的颜色都可以去掉</li>
<li>对于使用Selector当背景的Layout(比如ListView的Item,会使用Selector来标记点击,选择等不同的状态),可以将normal状态的color设置为\”@android:color/transparent”,来解决对应的问题</li>
</ul>
</li>
<li><p>内嵌使用包含layout_weight属性的LinearLayout会在绘制时花费昂贵的系统资源，因为每一个子组件都需要被测量两次。在使用ListView与GridView的时候，这个问题显的尤其重要，因为子组件会重复被创建.所以要尽量避免使用Layout_weight</p>
</li>
<li>使得Layout宽而浅，而不是窄而深（在Hierarchy Viewer的Tree视图里面体现）</li>
</ul>
<h2 id="源码相关">源码相关</h2><p>另外有能力看源码的同学，下面是绘制OverDraw的源码位置：/frameworks/base/libs/hwui/OpenGLRenderer.cpp,有兴趣的可以去研究研究。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> OpenGLRenderer<span class="tag">::renderOverdraw</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCaches<span class="built_in">.</span>debugOverdraw <span class="subst">&amp;</span>amp;<span class="subst">&amp;</span>amp; getTargetFbo() <span class="subst">==</span> <span class="number">0</span>) &#123;</span><br><span class="line">        const Rect<span class="subst">*</span> clip <span class="subst">=</span> <span class="subst">&amp;</span>amp;mTilingClip;</span><br><span class="line"></span><br><span class="line">        mCaches<span class="built_in">.</span>enableScissor();</span><br><span class="line">        mCaches<span class="built_in">.</span>setScissor(clip<span class="subst">-&amp;</span><span class="literal">gt</span>;left, mFirstSnapshot<span class="subst">-&amp;</span><span class="literal">gt</span>;height <span class="subst">-</span> clip<span class="subst">-&amp;</span><span class="literal">gt</span>;bottom,</span><br><span class="line">                clip<span class="subst">-&amp;</span><span class="literal">gt</span>;right <span class="subst">-</span> clip<span class="subst">-&amp;</span><span class="literal">gt</span>;left, clip<span class="subst">-&amp;</span><span class="literal">gt</span>;bottom <span class="subst">-</span> clip<span class="subst">-&amp;</span><span class="literal">gt</span>;top);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1x overdraw</span></span><br><span class="line">        mCaches<span class="built_in">.</span>stencil<span class="built_in">.</span>enableDebugTest(<span class="number">2</span>);</span><br><span class="line">        drawColor(mCaches<span class="built_in">.</span>getOverdrawColor(<span class="number">1</span>), SkXfermode<span class="tag">::kSrcOver_Mode</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2x overdraw</span></span><br><span class="line">        mCaches<span class="built_in">.</span>stencil<span class="built_in">.</span>enableDebugTest(<span class="number">3</span>);</span><br><span class="line">        drawColor(mCaches<span class="built_in">.</span>getOverdrawColor(<span class="number">2</span>), SkXfermode<span class="tag">::kSrcOver_Mode</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3x overdraw</span></span><br><span class="line">        mCaches<span class="built_in">.</span>stencil<span class="built_in">.</span>enableDebugTest(<span class="number">4</span>);</span><br><span class="line">        drawColor(mCaches<span class="built_in">.</span>getOverdrawColor(<span class="number">3</span>), SkXfermode<span class="tag">::kSrcOver_Mode</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4x overdraw and higher</span></span><br><span class="line">        mCaches<span class="built_in">.</span>stencil<span class="built_in">.</span>enableDebugTest(<span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line">        drawColor(mCaches<span class="built_in">.</span>getOverdrawColor(<span class="number">4</span>), SkXfermode<span class="tag">::kSrcOver_Mode</span>);</span><br><span class="line"></span><br><span class="line">        mCaches<span class="built_in">.</span>stencil<span class="built_in">.</span>disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="literal">void</span> OpenGLRenderer<span class="tag">::countOverdraw</span>() &#123;</span><br><span class="line">    size_t count <span class="subst">=</span> mWidth <span class="subst">*</span> mHeight;</span><br><span class="line">    uint32_t<span class="subst">*</span> buffer <span class="subst">=</span> <span class="literal">new</span> uint32_t<span class="preprocessor">[</span>count<span class="preprocessor">]</span><span class="markup">;</span><br><span class="line">    glReadPixels(0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, &amp;amp;buffer</span><span class="preprocessor">[</span><span class="number">0</span><span class="preprocessor">]</span><span class="markup">);</span><br><span class="line"></span><br><span class="line">    size_t total = 0;</span><br><span class="line">    for (size_t i = 0; i &amp;lt; count; i++) &#123;</span><br><span class="line">        total += buffer</span><span class="preprocessor">[</span>i<span class="preprocessor">]</span><span class="markup"> &amp;amp; 0xff;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOverdraw = total / float(count);</span><br><span class="line"></span><br><span class="line">    delete</span><span class="preprocessor">[</span><span class="preprocessor">]</span><span class="markup"> buffer;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>还有QA可能用得到的一个指标：OverDraw数值，这个的源码位置在Framework/base/core/java/android/view/HardwareRender.java中(5.0中去掉了这个数值的显示)</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">private void debugOverdraw(View.AttachInfo attachInfo, Rect dirty,</span><br><span class="line">                HardwareCanvas canvas, DisplayList displayList) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">mDebugOverdraw =</span>= OVERDRAW_TYPE_COUNT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">mDebugOverdrawLayer =</span>= <span class="constant">null</span>) &#123;</span><br><span class="line">                    <span class="variable">mDebugOverdrawLayer =</span> createHardwareLayer(mWidth, mHeight, <span class="constant">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mDebugOverdrawLayer.getWidth() != mWidth ||</span><br><span class="line">                        mDebugOverdrawLayer.getHeight() != mHeight) &#123;</span><br><span class="line">                    mDebugOverdrawLayer.resize(mWidth, mHeight);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mDebugOverdrawLayer.isValid()) &#123;</span><br><span class="line">                    <span class="variable">mDebugOverdraw =</span> -<span class="number">1</span>;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                HardwareCanvas <span class="variable">layerCanvas =</span> mDebugOverdrawLayer.start(canvas, dirty);</span><br><span class="line">                countOverdraw(layerCanvas);</span><br><span class="line">                final int <span class="variable">restoreCount =</span> layerCanvas.save();</span><br><span class="line">                layerCanvas.drawDisplayList(displayList, <span class="constant">null</span>, DisplayList.FLAG_CLIP_CHILDREN);</span><br><span class="line">                layerCanvas.restoreToCount(restoreCount);</span><br><span class="line">                mDebugOverdrawLayer.end(canvas);</span><br><span class="line"></span><br><span class="line">                float <span class="variable">overdraw =</span> getOverdraw(layerCanvas);</span><br><span class="line">                DisplayMetrics <span class="variable">metrics =</span> attachInfo.mRootView.getResources().getDisplayMetrics();</span><br><span class="line"></span><br><span class="line">                drawOverdrawCounter(canvas, overdraw, metrics.density);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void drawOverdrawCounter(HardwareCanvas canvas, float overdraw, float density) &#123;</span><br><span class="line">            final String <span class="variable">text =</span> String.format(\<span class="string">"%.2fx\"</span>, overdraw);</span><br><span class="line">            final Paint <span class="variable">paint =</span> setupPaint(density);</span><br><span class="line">            // HSBtoColor will clamp the values <span class="keyword">in</span> the <span class="number">0</span>..<span class="number">1</span> range</span><br><span class="line">            paint.setColor(Color.HSBtoColor(<span class="number">0.28</span>f - <span class="number">0.28</span>f * overdraw / <span class="number">3.5</span>f, <span class="number">0.8</span>f, <span class="number">1.0</span>f));</span><br><span class="line"></span><br><span class="line">            canvas.drawText(text, density * <span class="number">4.0</span>f, mHeight - paint.getFontMetrics().bottom, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文章">参考文章</h2><ol>
<li><a href="http://www.curious-creature.org/2012/12/01/android-performance-case-study/" target="_blank" rel="external">优化过程</a></li>
<li><a href="http://blog.csdn.net/yihongyuelan/article/details/12169647" target="_blank" rel="external">反编译并添加gpu显示</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/reusing-layouts.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/reusing-layouts.html </a></li>
<li><a href="http://developer.android.com/training/improving-layouts/loading-ondemand.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/loading-ondemand.html</a></li>
<li><a href="http://developer.android.com/training/improving-layouts/smooth-scrolling.html" target="_blank" rel="external">http://developer.android.com/training/improving-layouts/smooth-scrolling.html </a></li>
<li><a href="http://developer.android.com/tools/help/hierarchy-viewer.html" target="_blank" rel="external">http://developer.android.com/tools/help/hierarchy-viewer.html</a></li>
<li><a href="http://tools.android.com/tips/lint" target="_blank" rel="external">http://tools.android.com/tips/lint</a></li>
</ol>
<hr>
<blockquote>
<p>作者：<a href="http://weibo.com/1315612820/profile?topnav=1&amp;wvr=6" target="_blank" rel="external">Gracker</a></p>
<p>出处：<a href="http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/" target="_blank" rel="external">androidperformance.com</a></p>
<p>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
<p>打赏一下： <a href="http://weibo.com/p/1001603801588257955883?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod" target="_blank" rel="external">微博打赏</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>博客有一段时间没有更新了，到了新公司后，一直比较忙，博客也更新地不那么频繁了，倒是利用这个VPS搭建的VPN每天都在用，速度也蛮不错的。最近一直在看Android上和性能相关的部分，也就是所谓的Android性能优化，才发现Android性能这一块，自己懂得还是太少了，所以从上层开始看，也算是一点一点入门吧。这个系列将讲解学习过程中总结的和性能相关的内容。</p>
<p>首先将讲解一下GPU过渡绘制，也是开发者最直接接触的部分吧，这个内容将分为两个部分来将讲，第一部分初步讲解一下gpu过渡绘制的原理，和一些优化建议，第二部分将用实际例子来讲解优化GPU过渡绘制的一般步骤。</p>
<h2 id="过渡绘制概念">过渡绘制概念</h2><p>GPU过渡绘制的概念：GPU过度绘制指的是在屏幕一个像素上绘制多次(超过一次),比如一个TextView后有背景，那么显示文本的像素至少绘了两次，一次是背景，一次是文本。GPU过度绘制或多或少对性能有些影响,设备的内存带宽是有限的，当过度绘制导致应用需要更多的带宽(超过了可用带宽)的时候性能就会降低。带宽的限制每个设备都可能是不一样的。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Android小技巧]:如何让EditText不自动获取焦点]]></title>
    <link href="http://androidperformance.com/2014/06/03/android-edittext-do-not-auto-get-focus/"/>
    <id>http://androidperformance.com/2014/06/03/android-edittext-do-not-auto-get-focus/</id>
    <published>2014-06-02T16:31:49.000Z</published>
    <updated>2015-03-27T05:26:19.000Z</updated>
    <content type="html"><![CDATA[<p>Android中,使用EditText作为输入框很方便,但是有时候EditText会自动获取焦点,其行为:点击进入这个页面后,EditText自动获取焦点,导致软键盘直接跳出.有时候这么做很方便,但是大部分时候我们还是希望在点击EditText的时候,软键盘才弹出来.</p>
<p>这里有个很简单也很实用的技巧,即在EditText的父Layout中,加入下面的两个属性即可:</p>
<p><pre class="lang:java decode:true ">android:focusable=”true”<br>android:focusableInTouchMode=”true”</pre><br>这样做的原理是让用户进入到这个页面之后,EditText的父控件 获取焦点,这样的话EditText就获取不到焦点,软键盘也不会自动弹起.只有在点击EditText的时候,软键盘才会弹起.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android中,使用EditText作为输入框很方便,但是有时候EditText会自动获取焦点,其行为:点击进入这个页面后,EditText自动获取焦点,导致软键盘直接跳出.有时候这么做很方便,但是大部分时候我们还是希望在点击EditText的时候,软键盘才弹出来.</p]]>
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Frame animation模拟脉搏跳动小动画]]></title>
    <link href="http://androidperformance.com/2014/06/01/android-frame-animation/"/>
    <id>http://androidperformance.com/2014/06/01/android-frame-animation/</id>
    <published>2014-06-01T10:07:18.000Z</published>
    <updated>2015-03-27T05:26:33.000Z</updated>
    <content type="html"><![CDATA[<p>逐帧动画是一种常见的动画形式（Frame By Frame），其原理是在“连续的关键帧”中分解动画动作，也就是在时间轴的每帧上逐帧绘制不同的内容，使其连续播放而成动画。 因为逐帧动画的帧序列内容不一样，不但给制作增加了负担而且最终输出的文件量也很大，但它的优势也很明显：逐帧动画具有非常大的灵活性，几乎可以表现任何想表现的内容，而它类似与电影的播放模式，很适合于表演细腻的动画。例如：人物或动物急剧转身、 头发及衣服的飘动、走路、说话以及精致的3D效果等等。</p>
<p>Android中的逐帧动画是Frame animation。<span style="\"color:" #000000;\"="">Frame animation可以被定义在XML文件中，也可以完全编码实现。3.0以前，android支持两种动画模式，tween animation,frame animation，在android3.0中又引入了一个新的动画系统：property animation，这三种动画模式在SDK中被称为property animation,view animation,drawable animation。 </span></p>
<a id="more"></a>
<p>本篇使用的方法是在xml中定义效果，以下是想达到的动画的效果。</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>1.首先准备所需图片（逐帧）。</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>2.在res/anim下或res/rawable下新建xml来编写动画效果。内容类似下图：</p>
<pre class="\"lang:java" decode:true\"="">&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"
    android:oneshot=\"false\"&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00040\" android:duration=\"100\" /&gt;//duration是每帧图片的时长，单位ms
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00041\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00042\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00043\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00044\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00045\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00046\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00047\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00048\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00049\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00050\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00051\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00052\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00053\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00054\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00055\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00056\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00057\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00058\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00059\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00060\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00061\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00062\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00063\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00064\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00065\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00066\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00067\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00068\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00069\" android:duration=\"100\" /&gt;
&lt;/animation-list&gt;</pre>

<p>xml保存为scanning_anim.xml.其中,</p>
<pre class="\"lang:java" decode:true\"="">animation-list//最外层是animition-list控件，可以容纳item，每个item是一帧图片。</pre>

<pre class="\"lang:java" decode:true\"="">android:oneshot=\"false\"<span style="\"color:" #000000;\"="">//如果为true，表示动画只播放一次停止在最后一帧上，如果设置为false表示动画循环播放。</span></pre>

<p>3.以上xml中定义的动画要以一个imageView作为载体来显示。以下例子用一个类稍稍封装：</p>
<pre class="\"lang:java" decode:true\"="">public class ScanningAnimationView extends ImageView {
    AnimationDrawable scanningDrawable;
    public ScanningAnimationView(Context context) {
        super(context);
    }
    public ScanningAnimationView(Context context, AttributeSet attrs) {
        super(context, attrs);
        setBackgroundResource(R.anim.scanning_anim);
        scanningDrawable=(AnimationDrawable)this.getBackground();
    }

    public void start() {
        scanningDrawable.start();
    }
    public void stop() {
        scanningDrawable.stop();
    }
}</pre>

<p>4.用户直接使用这个封装好的ImageView调用start和stop即可。</p>
<p>调用动画：</p>
<pre class="\"lang:java" decode:true\"="">public class MainActivity extends ActionBarActivity {
    ScanningAnimationView image;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        image = (ScanningAnimationView)findViewById(R.id.imageView);
        Button startButton = (Button) findViewById(R.id.start);
        Button endButton = (Button)findViewById(R.id.end);
        startButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                image.start();
            }
        });

        endButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                image.stop();
            }
        });
    }
</pre>

<p>imageView的布局：</p>
<pre class="\"lang:java" decode:true\"="">&lt;com.example.nurse.app.util.ScanningAnimationView
    android:layout_width=\"wrap_content\"
    android:layout_height=\"wrap_content\"
    android:id=\"@+id/imageView\"
    android:layout_centerHorizontal=\"true\"
    android:layout_alignParentTop=\"true\"
    android:layout_alignParentStart=\"true\"/&gt;</pre>

<p>本篇完。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>逐帧动画是一种常见的动画形式（Frame By Frame），其原理是在“连续的关键帧”中分解动画动作，也就是在时间轴的每帧上逐帧绘制不同的内容，使其连续播放而成动画。 因为逐帧动画的帧序列内容不一样，不但给制作增加了负担而且最终输出的文件量也很大，但它的优势也很明显：逐帧动画具有非常大的灵活性，几乎可以表现任何想表现的内容，而它类似与电影的播放模式，很适合于表演细腻的动画。例如：人物或动物急剧转身、 头发及衣服的飘动、走路、说话以及精致的3D效果等等。</p>
<p>Android中的逐帧动画是Frame animation。<span style=\"color: #000000;\">Frame animation可以被定义在XML文件中，也可以完全编码实现。3.0以前，android支持两种动画模式，tween animation,frame animation，在android3.0中又引入了一个新的动画系统：property animation，这三种动画模式在SDK中被称为property animation,view animation,drawable animation。 </span></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(2)]]></title>
    <link href="http://androidperformance.com/2014/05/31/android-tips-round-up-2/"/>
    <id>http://androidperformance.com/2014/05/31/android-tips-round-up-2/</id>
    <published>2014-05-31T10:20:47.000Z</published>
    <updated>2015-03-27T05:35:09.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第二篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/text/format/DateUtils.html#formatDateTime%28android.content.Context,%20long,%20int%29" target="_blank" rel="external">DateUtils.formatDateTime()</a> 用来进行区域格式化工作,输出格式化和本地化的时间或者日期.</p>
<a id="more"></a>
<p><a href="http://developer.android.com/reference/android/app/AlarmManager.html#setInexactRepeating(int, long, long, android.app.PendingIntent" target="_blank" rel="external">AlarmManager.setInexactRepeating</a>) 通过闹铃分组的方式省电,即使你只调用了一个闹钟,这也是一个好的选择,（可以确保在使用完毕时自动调用 AlarmManager.cancel ()。原文说的比较抽象,这里详细说一下:setInexactRepeating指的是设置非准确闹钟,使用方法:alarmManager.setInexactRepeating(AlarmManager.RTC, startTime,intervalL, pendingIntent),非准确闹钟只能保证大致的时间间隔，但是不一定准确，可能出现设置间隔为30分钟，但是实际上一次间隔20分钟，另一次间隔40分钟。它的最大的好处是可以合并闹钟事件，比如间隔设置每30分钟一次，不唤醒休眠，在休眠8小时后已经积累了16个闹钟事件，而在手机被唤醒的时候，非准时闹钟可以把16个事件合并为一个, 所以这么看来,非准时闹钟一般来说比较节约能源.</p>
<p><a href="http://developer.android.com/reference/android/text/format/Formatter.html#formatFileSize(android.content.Context, long" target="_blank" rel="external">Formatter.formatFileSize()</a>) 一个区域化的文件大小格式化工具。通俗来说就是把大小转换为MB,G,KB之类的字符串.</p>
<p><a href="http://developer.android.com/reference/android/app/ActionBar.html#hide(" target="_blank" rel="external">ActionBar.hide()</a>)/<a href="http://developer.android.com/reference/android/app/ActionBar.html#show(" target="_blank" rel="external">.show()</a>) 顾名思义,隐藏和显示ActionBar,可以优雅地在全屏和带Actionbar之间转换.</p>
<p><a href="http://developer.android.com/reference/android/text/util/Linkify.html#addLinks(android.text.Spannable, int" target="_blank" rel="external">Linkify.addLinks()</a>)  在Text上添加链接.很实用.</p>
<p><a href="http://developer.android.com/reference/android/text/StaticLayout.html" target="_blank" rel="external">StaticLayout</a> 在自定义 View 中渲染文字的时候很实用。</p>
<p><a href="http://developer.android.com/reference/android/app/Activity.html#onBackPressed(" target="_blank" rel="external">Activity.onBackPressed()</a>) 很方便的管理back键的方法,有时候需要自己控制返回键的事件的时候,可以重写一下.比如加入 “点两下back键退出” 功能.</p>
<p><a href="http://developer.android.com/reference/android/view/GestureDetector.html" target="_blank" rel="external">GestureDetector</a> 用来监听和相应对应的手势事件,比如点击,长按,慢滑动,快滑动,用起来很简单,比你自己实现要方便许多.</p>
<p><a href="http://developer.android.com/reference/android/graphics/DrawFilter.html" target="_blank" rel="external">DrawFilter</a> 可以让你在不调用onDrew方法的情况下,操作canvas,比了个如,你可以在创建自定义 View 的时候设置一个 DrawFilter，给父 View 里面的所有 View 设置反别名。</p>
<p><a href="http://developer.android.com/reference/android/app/ActivityManager.html#getMemoryClass(" target="_blank" rel="external">ActivityManager.getMemoryClass()</a>) 告诉你你的机器还有多少内存,在计算缓存大小的时候会比较有用.</p>
<p><a href="http://developer.android.com/reference/android/view/ViewStub.html" target="_blank" rel="external">ViewStub</a> 它是一个初始化不做任何事情的 View，但是之后可以载入一个布局文件。在慢加载 View 中很适合做占位符。唯一的缺点就是不支持标签，所以如果你不太小心的话，可能会在视图结构中加入不需要的嵌套。</p>
<p><a href="http://developer.android.com/reference/android/os/SystemClock.html#sleep(long" target="_blank" rel="external">SystemClock.sleep()</a>) 这个方法在保证一定时间的 sleep 时很方便，通常我用来进行 debug 和模拟网络延时。</p>
<p><a href="http://developer.android.com/reference/android/util/DisplayMetrics.html#density" target="_blank" rel="external">DisplayMetrics.density</a> 这个方法你可以获取设备像素密度,大部分时候最好让系统来自动进行缩放资源之类的操作,但是有时候控制的效果会更好一些.(尤其是在自定义View的时候).</p>
<p><a href="http://developer.android.com/reference/android/util/Pair.html#create(A, B" target="_blank" rel="external">Pair.create()</a>) 方便构建类和构造器的方法。</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/04/14/android-tips-round-up-part-2/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-2/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-2.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第二篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/text/format/DateUtils.html#formatDateTime%28android.content.Context,%20long,%20int%29">DateUtils.formatDateTime()</a> 用来进行区域格式化工作,输出格式化和本地化的时间或者日期.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(1)]]></title>
    <link href="http://androidperformance.com/2014/05/28/android-tips-round-up-1/"/>
    <id>http://androidperformance.com/2014/05/28/android-tips-round-up-1/</id>
    <published>2014-05-28T15:47:43.000Z</published>
    <updated>2015-03-27T05:34:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第一篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/app/Activity.html#startActivities(android.content.Intent[]" target="_blank" rel="external">Activity.startActivities()</a>) 常用于在应用程序中间启动其他的Activity.</p>
<a id="more"></a>
<p><a href="http://developer.android.com/reference/android/text/TextUtils.html#isEmpty(java.lang.CharSequence" target="_blank" rel="external">TextUtils.isEmpty()</a>) 简单的工具类,用于检测是否为空</p>
<p><a href="http://developer.android.com/reference/android/text/Html.html#fromHtml(java.lang.String" target="_blank" rel="external">Html.fromHtml()</a>) 用于生成一个Html,参数可以是一个字符串.个人认为它不是很快,所以我不怎么经常去用.（我说不经常用它是为了重点突出这句话：请多手动构建 Spannable 来替换 Html.fromHtml），但是它对渲染从 web 上获取的文字还是很不错的。</p>
<p><a href="http://developer.android.com/reference/android/widget/TextView.html#setError%28java.lang.CharSequence%29" target="_blank" rel="external">TextView.setError()</a> 在验证用户输入的时候很棒</p>
<p><a href="http://developer.android.com/reference/android/os/Build.VERSION_CODES.html" target="_blank" rel="external">Build.VERSION_CODES</a> 这个标明了当前的版本号,在处理兼容性问题的时候经常会用到.点进去可以看到各个版本的不同特性</p>
<p><a href="http://developer.android.com/reference/android/util/Log.html#getStackTraceString(java.lang.Throwable" target="_blank" rel="external">Log.getStackTraceString()</a>) 方便的日志类工具,方法Log.v()、Log.d()、Log.i()、Log.w()和Log.e()都是将信息打印到LogCat中，有时候需要将出错的信息插入到数据库或一个自定义的日志文件中，那么这种情况就需要将出错的信息以字符串的形式返回来，也就是使用static String getStackTraceString(Throwable tr)方法的时候.</p>
<p><a href="http://developer.android.com/reference/android/view/LayoutInflater.html#from%28android.content.Context%29" target="_blank" rel="external">LayoutInflater.from()</a> 顾名思义,用于Inflate一个layout,参数是layout的id.这个经常写Adapter的人会用的比较多.</p>
<p><a href="http://developer.android.com/reference/android/view/ViewConfiguration.html#getScaledTouchSlop%28%29" target="_blank" rel="external">ViewConfiguration.getScaledTouchSlop()</a> 使用 ViewConfiguration 中提供的值以保证所有触摸的交互都是统一的。这个方法获取的值表示:用户的手滑动这个距离后,才判定为正在进行滑动.当然这个值也可以自己来决定.但是为了一致性,还是使用标准的值较好.</p>
<p><a href="http://developer.android.com/reference/android/telephony/PhoneNumberUtils.html#convertKeypadLettersToDigits%28java.lang.String%29" target="_blank" rel="external">PhoneNumberUtils.convertKeypadLettersToDigits</a> 顾名思义.将字母转换为数字,类似于T9输入法,</p>
<p><a href="http://developer.android.com/reference/android/content/Context.html#getCacheDir%28%29" target="_blank" rel="external">Context.getCacheDir()</a> 获取缓存数据文件夹的路径,很简单但是知道的人不多,这个路径通常在SD卡上(这里的SD卡指的是广义上的SD卡,包括外部存储和内部存储)Adnroid/data/您的应用程序包名/cache/  下面.测试的时候,可以去这里面看是否缓存成功.缓存在这里的好处是:不用自己再去手动创建文件夹,不用担心用户把自己创建的文件夹删掉,在应用程序卸载的时候,这里会被清空,使用第三方的清理工具的时候,这里也会被清空.</p>
<p><a href="http://developer.android.com/reference/android/animation/ArgbEvaluator.html" target="_blank" rel="external">ArgbEvaluator</a> 用于处理颜色的渐变。就像 Chris Banes 说的一样，这个类会进行很多自动装箱的操作，所以最好还是去掉它的逻辑自己去实现它。这个没用过,不明其所以然,回头再补充.</p>
<p><a href="http://developer.android.com/reference/android/view/ContextThemeWrapper.html" target="_blank" rel="external">ContextThemeWrapper</a> 方便在运行的时候修改主题.</p>
<p><a href="http://developer.android.com/reference/android/widget/Space.html" target="_blank" rel="external">Space</a> space是Android 4.0中新增的一个控件，它实际上可以用来分隔不同的控件，其中形成一个空白的区域.这是一个轻量级的视图组件，它可以跳过Draw，对于需要占位符的任何场景来说都是很棒的。</p>
<p><a href="http://developer.android.com/reference/android/animation/ValueAnimator.html#reverse%28%29" target="_blank" rel="external">ValueAnimator.reverse()</a> 这个方法可以很顺利地取消正在运行的动画.我超喜欢.</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-1/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-1/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-1.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-1.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第一篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/app/Activity.html#startActivities(android.content.Intent[]">Activity.startActivities()</a>) 常用于在应用程序中间启动其他的Activity.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Android4.4]第三方APP无法操作外置SD卡原因分析以及延伸阅读]]></title>
    <link href="http://androidperformance.com/2014/05/17/apps-can-no-android4-4-app-longer-write-files-to-your-sd-card/"/>
    <id>http://androidperformance.com/2014/05/17/apps-can-no-android4-4-app-longer-write-files-to-your-sd-card/</id>
    <published>2014-05-17T03:20:30.000Z</published>
    <updated>2015-03-27T05:20:04.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-问题背景:">1.问题背景:</h3><p>最近做Android4.4的平台移植,遇到一个问题:在Android4.4中,第三方App是没有权限操作外置SD卡的(除非是与自己包名相同的目录),开始以为是自己申请的权限不足,最后发现是Google在Android中限制了这一权限.这是原文:</p>
<blockquote>
<p><span style="\"color:" #404040;\"="">The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions.</span></p>
</blockquote>
<p>意思就是说,只有主存储有读写的权限,第二存储(通常是外置SD卡或者USBOTG,这个可以在设置菜单中自己设置)只有读的权限.原因也有给出:</p>
<blockquote>
<p><span style="\"color:" #404040;\"="">Restricting writes in this way ensures the system can clean up files when applications are uninstalled.</span></p>
</blockquote>
<p>另一个原因我觉得是安全的问题,这一方面的陈述会在下面详细介绍.</p>
<a id="more"></a>
<h3 id="2-解决办法:">2.解决办法:</h3><p>解决办法分两种,一种针对用户,一种针对开发者.</p>
<p><strong><em>针对用户:</em></strong></p>
<p>已经root的用户可以通过修改:<span style="\"color:" #444444;\"="">/system/etc/permissions/platform.xml</span> 文件(使用RE文件管理器即可),找到如下代码块:</p>
<pre class="\"lang:java" decode:true\"="" title="\"写sd卡的权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>修改为:</p>
<pre class="\"lang:java" decode:true\"="" title="\"修改后的写SD卡权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;group gid=\"media_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>然后重启.就可以读写SD卡了.</p>
<p>这个做法其实就是给<span style="\"color:" #666666;\"="">android.permission.WRITE_EXTERNAL_STORAGE</span> 这个权限组加上对media的读写权限.</p>
<p><strong><em>针对开发者:</em></strong></p>
<p><span style="\"color:" #323333;\"="">XDA论坛上的方法，先把文件改为图片类型，再用media content provider来删除.</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"转换成媒体文件,再进行操作\"">private static final Uri FILES_URI = MediaStore.Files.getContentUri(\"external\");
    public static boolean deleteFile(Context context, String path) {
        ContentResolver cr = context.getContentResolver();
        if (cr == null) return false;
        final String selection = FileColumns.DATA + \"=?\";
        final String[] selectionArgs = new String[] { path };
        ContentValues values = new ContentValues();
        values.put(FileColumns.MEDIA_TYPE, FileColumns.MEDIA_TYPE_IMAGE);
        return cr.update(FILES_URI, values, selection, selectionArgs) &gt; 0
                &amp;&amp; cr.delete(FILES_URI, selection, selectionArgs) &gt; 0;
    }</pre>

<p>这样做是因为MediaProvider拥有读写SD卡的 权限,通过它去操作文件也可以达到目标.不过有人反映如果把默认存储设置为内置SD卡，该方法貌似就失效了。不知道有没有更好的办法？</p>
<p><strong><em>针对rom开发者:</em></strong></p>
<p>rom开发者有更好的选择,<span style="\"color:" #444444;\"="">platform.xml的文件位置在源代码:frameworks/base/data/etc/中,和方法1中的步骤一样:</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"写sd卡的权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>修改为:</p>
<pre class="\"lang:java" decode:true\"="" title="\"修改后的写SD卡权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;group gid=\"media_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>然后重新编译一个rom即可.</p>
<p>&nbsp;</p>
<h3 id="3-延伸阅读">3.延伸阅读</h3><p>Google这么做的原因,我也查阅了一些文章,下面是一些我觉得比较好的回答,大家感兴趣可以自己看一下:</p>
<p>第一篇是Google+上的一个人的分析,大概解释了一下google这样做的原因以及造成的影响(英文很简单):</p>
<blockquote>
<p><span style="\"color:" #404040;\"="">KitKat will make your SD Card completely useless: per the Android API specification, apps can no longer write files to your SD card.  And Samsung is following it.This only applies to dual-storage devices, i.e., devices with a user-writable internal flash storage <strong>AND</strong> a removable SD card.</span></p>
<p><span style="\"color:" #404040;\"="">From </span><span style="\"color:" #427fed;\"=""><a href="http://source.android.com/devices/tech/storage/index.html" target="_blank" rel="external">http://source.android.com/devices/tech/storage/index.html</a></span><span style="\"color:" #404040;\"="">:\”The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions.\”</span></p>
<p><span style="\"color:" #404040;\"="">If your device has user-accessible internal flash storage, your SD Card is a \”secondary external storage device\”.</span></p>
<p><span style="\"color:" #404040;\"="">What this means is that with KitKat, applications will no longer be able create, modify, or remove files and folders on your external SD card.  As a for-instance, you can no longer use a file manager to copy files from your computer to the SD card over a network.  This ability, which has existed since the beginning of Android, has been taken away.</span></p>
<p><span style="\"color:" #404040;\"="">The only stated reason for this removal of functionality is that, \”Restricting writes in this way ensures the system can clean up files when applications are uninstalled.\”  I do not pretend to understand this logic.  Apps are still allowed to write in arbitrary directories on the primary storage (with the appropriate permission), but are denied the same access to external storage.</span></p>
<p><span style="\"color:" #404040;\"="">Samsung has implemented this feature with their KitKat OTA updates.  Note3 users are now complaining that FX File Explorer can no longer write to their external SD cards.  There are solutions to this problem for users with root access.  Users without root access appear to be screwed.</span></p>
<p><span style="\"color:" #404040;\"="">I\’m not quite certain how Google intends for you to place files on your SD card.  Perhaps you have to use proprietary Google apps that contain permissions unavailable to the rest of the developer world.  Perhaps you\’re supposed to put everything on the cloud and pay carrier data fees to get it there.  Perhaps you\’re supposed to use some kind of WIRE to attach your WIRELESS device to your computer and have the computer do that work for you.</span></p>
<p><span style="\"color:" #404040;\"="">In my opinion this is a horrible misstep by Google and the Android Open Source Project.  Functionality has been removed without reason, to the severe detriment of users and developers alike.</span></p>
<p><span style="\"color:" #404040;\"="">I apologize for not bringing this to everyone\’s attention when KitKat 4.4 was released, but it was not mentioned in the Android 4.4 changes document:</span><span style="\"color:" #427fed;\"=""><a href="http://developer.android.com/about/versions/android-4.4.html" target="_blank" rel="external">http://developer.android.com/about/versions/android-4.4.html</a></span><span style="\"color:" #404040;\"="">.  It\’s only mentioned in the article on </span><span style="\"color:" #427fed;\"="">source.android.com</span><span style="\"color:" #404040;\"="">.  I was only made aware of its existence from user reports as a result of Samsung implementing this change in its KitKat OTA updates. </span></p>
</blockquote>
<p>第二篇是知乎上的讨论,大家自行脑补:</p>
<blockquote>
<p><span style="\"color:" #232323;\"="">这有可能真的只是一个限制，影响很小，因为这个限制并不彻底，primary external storage 仍然可写，而支持双 SD 的设备并不很多。我们大家更期待的是让 primary external storage 也同样受到这个限制，虽然这个修改将涉及到更多应用的不兼容。</span></p>
<p><span style="\"color:" #232323;\"="">所以这个问题并没有彻底解决，到对 primary external storage 也限制的那个时候，才真正的解决了这个问题。</span></p>
<p><span style="\"color:" #232323;\"="">就目前而言，第二 SD 卡仍然是可以读写的，只是要读写到指定的目录（具体应该在 /Android/data/）。这样的规定意味着应用程序只能对 SD 卡的指定目录进行读写，不能读写任意目录。相当于 Google 出手对 SD 卡目录结构进行了规范。之前 android 不限制目录，所以各种应用就随意的在 SD 卡上建一个目录。然后 SD 卡上的目录到处都是，用户对这种现象早就深恶痛绝了！如果 Google 对这件事情下狠手，只能说是<strong>大快人心</strong>。</span></p>
<p><span style="\"color:" #232323;\"="">另外说一下，SD 卡上的指定目录是这样获取的：</span><br><span style="\"color:" #232323;\"="">1，程序相关的 内置存储目录，这个目录位于内置 flash，应用程序可以随意读写：</span></p>
<p><pre class="\"lang:java" decode:true\"="">getFilesDir();</pre><br><span style="\"color:" #232323;\"="">2，程序相关的 SD 卡外部存储目录，这个目录位于 SD 卡，应用程序可以随意读写：</span></p>
<p><pre class="\"lang:java" decode:true="" crayon-selected\"="">getExternalFilesDir(null);</pre><br><span style="\"color:" #232323;\"="">3，SD 卡公共目录，这些目录仍然可以访问，不受权限限制：</span></p>
<p><pre class="\"lang:java" decode:true\"="">Environment.getExternalStoragePublicDirectory(x)</pre><br><span style="\"color:" #232323;\"="">其中 x 可以是 Environment.DIRECTORY_ALARMS 等预定义的常量。可以查找 Environment 的帮助。</span></p>
<p><span style="\"color:" #232323;\"="">如果大家要存储数据，可以用 1 或者 2 的方法，获取正确的目录，然后进行任意读写，这样不会把 SD 卡的目录写乱。</span></p>
</blockquote>
<p>第三篇也是知乎上一个讨论:</p>
<blockquote>
<p><span style="\"color:" #232323;\"="">Google 给出的理由有一定的道理——相信很多有洁癖的人都很讨厌第三方应用在 SD 卡或者内置存储下随意建立文件夹吧，有节操的应用应该只在以自己的包名区分的目录下存放需要的文件。</span></p>
<p><span style="\"color:" #232323;\"="">至于为什么只限制 SD 卡，不包括内置存储，我觉得是因为 SD 卡是可以插在别的地方的，目录结构是有可能暴露出来的，也有可能被修改。规范应用在 SD 卡的读写，可以使得这个 SD 卡上的目录和文件可以在其他设备上被电脑「理解」——「这个目录是在某一个 Android 设备上用到的，我不必理会它」，如果第三方应用随意在 SD 卡根目录创建命名不规范并且无规律的目录，这个 SD 卡在其他地方就会使电脑或者人迷惑——「这个目录是干什么的？是谁创建的？我可不可以删掉它？」。手机的内部存储空间不能拆卸，所以其目录结构不会轻易暴露给用户，也不会放在别的设备上，所以可以暂时不管。</span></p>
</blockquote>
<p>&nbsp;</p>
<p>参考:</p>
<p>1.<a href="\">https://plus.google.com/+TodLiebeck/posts/gjnmuaDM8sn</a></p>
<p>2.<a href="\">http://www.zhihu.com/question/22778889</a></p>
<p>3.<a href="\">http://source.android.com/devices/tech/storage/index.html</a></p>
<p>&nbsp;</p>
<p>相关阅读 :</p>
<ol>
<li><a href="\">Android4.4中扫描文件广播权限变更分析</a></li>
</ol>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-问题背景:">1.问题背景:</h3><p>最近做Android4.4的平台移植,遇到一个问题:在Android4.4中,第三方App是没有权限操作外置SD卡的(除非是与自己包名相同的目录),开始以为是自己申请的权限不足,最后发现是Google在Android中限制了这一权限.这是原文:</p>
<blockquote>
<p><span style=\"color: #404040;\">The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions.</span></p>
</blockquote>
<p>意思就是说,只有主存储有读写的权限,第二存储(通常是外置SD卡或者USBOTG,这个可以在设置菜单中自己设置)只有读的权限.原因也有给出:</p>
<blockquote>
<p><span style=\"color: #404040;\">Restricting writes in this way ensures the system can clean up files when applications are uninstalled.</span></p>
</blockquote>
<p>另一个原因我觉得是安全的问题,这一方面的陈述会在下面详细介绍.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Android4.4]Permission Denial: not allowed to send broadcast android.intent.action.MEDIA_MOUNTED]]></title>
    <link href="http://androidperformance.com/2014/05/14/android4-4permission-denial-not-allowed-to-send-broadcast-android-intent-action-media-mounted/"/>
    <id>http://androidperformance.com/2014/05/14/android4-4permission-denial-not-allowed-to-send-broadcast-android-intent-action-media-mounted/</id>
    <published>2014-05-14T15:37:28.000Z</published>
    <updated>2015-03-27T05:19:36.000Z</updated>
    <content type="html"><![CDATA[<h4 id="摘要:_Android4-4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案-">摘要: Android4.4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案.</h4><p>&nbsp;</p>
<h3 id="0-_问题背景">0. 问题背景</h3><p>在Android4.4之前，许多应用程序使用如下代码去通知更新文件数据库</p>
<pre class="\"lang:java" decode:true\"="" title="\"通知系统更新文件系统\"">sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>这样做的坏处：每次发送这个广播，都会<span style="\"color:" #222222;\"="">让MediaScanner重新扫描一次系统文件，很影响设备的电池寿命。当然传入的路径可以</span> 是单个文件或者内容很少的文件夹，会减轻扫描系统文件的压力，但是还是会因为扫描频繁而浪费电。所以在Android4.4<span style="\"color:" #222222;\"="">开始，只允许系统应用发送这样的intent。</span> 所以在Android4.4系统的机器上会出现如下错误：</p>
<pre class="\"lang:java" decode:true\"="" title="\"错误\""> Permission Denial: not allowed to send broadcast android.intent.action.MEDIA_MOUNTED</pre>

<h3 id="1-_解决办法：">1. 解决办法：</h3><p>1 . 将Intent换为 <a href="\"><code>ACTION_MEDIA_SCANNER_SCAN_FILE</code></a><span style="\"color:" #000000;\"="">.</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"ACTION_MEDIA_SCANNER_SCAN_FILE\"">sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>但是这个Intent只扫描文件，不扫描文件夹。如果你的应用只操作单个文件而不是文件夹，就可以使用这个。 2. 不发广播，换为MediaScannerConnection进行通知更新</p>
<pre class="\"lang:java" decode:true\"="" title="\"MediaScannerConnection\""> MediaScannerConnection.scanFile(this,
          new String[] { file.toString() }, null,
          new MediaScannerConnection.OnScanCompletedListener() {
      public void onScanCompleted(String path, Uri uri) {
          Log.i(\"ExternalStorage\", \"Scanned \" + path + \":\");
          Log.i(\"ExternalStorage\", \"-&gt; uri=\" + uri);
      }
 });</pre>

<p>这样做就属于不发送广播,在4.4上可以正常工作.</p>
<a id="more"></a>
<h4 id="拓展">拓展</h4><p>代码跟踪,让我们看看scanFile做了什么事: 1.查看scanFile的源码:</p>
<pre class="\"lang:java" decode:true\"="" title="\"scanFile\"">    public static void scanFile(Context context, String[] paths, String[] mimeTypes,
            OnScanCompletedListener callback) {
        ClientProxy client = new ClientProxy(paths, mimeTypes, callback);
        MediaScannerConnection connection = new MediaScannerConnection(context, client);
        client.mConnection = connection;
        connection.connect();
    }</pre>

<p>2.ClintProxy源码:</p>
<pre class="\"lang:java" decode:true\"="" title="\"ClientProxy\"">    static class ClientProxy implements MediaScannerConnectionClient {
        final String[] mPaths;
        final String[] mMimeTypes;
        final OnScanCompletedListener mClient;
        MediaScannerConnection mConnection;
        int mNextPath;

        ClientProxy(String[] paths, String[] mimeTypes, OnScanCompletedListener client) {
            mPaths = paths;
            mMimeTypes = mimeTypes;
            mClient = client;
        }

        public void onMediaScannerConnected() {
            scanNextPath();
        }

        public void onScanCompleted(String path, Uri uri) {
            if (mClient != null) {
                mClient.onScanCompleted(path, uri);
            }
            scanNextPath();
        }

        void scanNextPath() {
            if (mNextPath &gt;= mPaths.length) {
                mConnection.disconnect();
                return;
            }
            String mimeType = mMimeTypes != null ? mMimeTypes[mNextPath] : null;
            mConnection.scanFile(mPaths[mNextPath], mimeType);
            mNextPath++;
        }
    }</pre>

<p>3.MediaScannerConnection的connect方法:</p>
<pre class="\"lang:java" decode:true\"="" title="\"connect\"">    /**
     * Initiates a connection to the media scanner service.
     * {@link MediaScannerConnectionClient#onMediaScannerConnected()}
     * will be called when the connection is established.
     */
    public void connect() {
        synchronized (this) {
            if (!mConnected) {
                Intent intent = new Intent(IMediaScannerService.class.getName());
                intent.setComponent(
                        new ComponentName(\"com.android.providers.media\",
                                \"com.android.providers.media.MediaScannerService\"));
                mContext.bindService(intent, this, Context.BIND_AUTO_CREATE);
                mConnected = true;
            }
        }
    }</pre>

<p>这里可以看到,最后是start了一个service:MediaScannerService MediaScannerService 的源码可以在<a href="\">这里看到</a>:我们重点看一下scan方法:</p>
<pre class="\"lang:java" decode:true\"="" title="\"scan\"">private void scan(String[] directories, String volumeName) {
        // don\'t sleep while scanning
        mWakeLock.acquire();

        ContentValues values = new ContentValues();
        values.put(MediaStore.MEDIA_SCANNER_VOLUME, volumeName);
        Uri scanUri = getContentResolver().insert(MediaStore.getMediaScannerUri(), values);

        Uri uri = Uri.parse(\"file://\" + directories[0]);
        sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_STARTED, uri));

        try {
            if (volumeName.equals(MediaProvider.EXTERNAL_VOLUME)) {
                 openDatabase(volumeName);    
            }

            MediaScanner scanner = createMediaScanner();
            scanner.scanDirectories(directories, volumeName);
        } catch (Exception e) {
            Log.e(TAG, \"exception in MediaScanner.scan()\", e); 
        }

        getContentResolver().delete(scanUri, null, null);

        sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, uri));
        mWakeLock.release();
    }</pre>

<p>可以看到最终调用了<span style="\"color:" #48484c;\"="">MediaScanner来进行扫描,扫描结束后,发送ACTION_MEDIA_SCANNER_FINISHED广播.应用程序可以接受此广播来更新界面之类</span></p>
<p>&nbsp;</p>
<p>参考资料：</p>
<ol>
<li><p><a href="\">http://stackoverflow.com/questions/18624235/android-refreshing-the-gallery-after-saving-new-images</a></p>
</li>
<li><p><a href="\">http://stackoverflow.com/questions/21469431/permission-denial-not-allowed-to-send-broadcast-in-android</a></p>
</li>
<li><p><a href="\">http://www.androideng.com/?p=1108</a></p>
</li>
</ol>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="摘要:_Android4-4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案-">摘要: Android4.4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案.</h4><p>&nbsp;</p>
<h3 id="0-_问题背景">0. 问题背景</h3><p>在Android4.4之前，许多应用程序使用如下代码去通知更新文件数据库</p>
<pre class=\"lang:java decode:true\" title=\"通知系统更新文件系统\">sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>这样做的坏处：每次发送这个广播，都会<span style=\"color: #222222;\">让MediaScanner重新扫描一次系统文件，很影响设备的电池寿命。当然传入的路径可以</span> 是单个文件或者内容很少的文件夹，会减轻扫描系统文件的压力，但是还是会因为扫描频繁而浪费电。所以在Android4.4<span style=\"color: #222222;\">开始，只允许系统应用发送这样的intent。</span> 所以在Android4.4系统的机器上会出现如下错误：</p>
<pre class=\"lang:java decode:true\" title=\"错误\"> Permission Denial: not allowed to send broadcast android.intent.action.MEDIA_MOUNTED</pre>

<h3 id="1-_解决办法：">1. 解决办法：</h3><p>1 . 将Intent换为 <a href="\"><code>ACTION_MEDIA_SCANNER_SCAN_FILE</code></a><span style=\"color: #000000;\">.</span></p>
<pre class=\"lang:java decode:true\" title=\"ACTION_MEDIA_SCANNER_SCAN_FILE\">sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>但是这个Intent只扫描文件，不扫描文件夹。如果你的应用只操作单个文件而不是文件夹，就可以使用这个。 2. 不发广播，换为MediaScannerConnection进行通知更新</p>
<pre class=\"lang:java decode:true\" title=\"MediaScannerConnection\"> MediaScannerConnection.scanFile(this,
          new String[] { file.toString() }, null,
          new MediaScannerConnection.OnScanCompletedListener() {
      public void onScanCompleted(String path, Uri uri) {
          Log.i(\"ExternalStorage\", \"Scanned \" + path + \":\");
          Log.i(\"ExternalStorage\", \"-&gt; uri=\" + uri);
      }
 });</pre>

<p>这样做就属于不发送广播,在4.4上可以正常工作.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android开发:Log2File工具类]]></title>
    <link href="http://androidperformance.com/2014/05/02/android_log_to_file/"/>
    <id>http://androidperformance.com/2014/05/02/android_log_to_file/</id>
    <published>2014-05-02T05:25:35.000Z</published>
    <updated>2015-03-27T05:19:46.000Z</updated>
    <content type="html"><![CDATA[<div style="color: #000000;">Log2File工具类是用于Android程序将Log记录到文件中(如sd卡)的工具,应用场景：</div><br><div style="color: #000000;"><br><br>1.  无法连接电脑进行调试（usb线被usbotg占用）<br>2.  Log不容易被抓取<br>3.  Bug出现很随机，不是必出现<br>4.  其他自己脑补<br><br>##  0.说明<br><br>这篇文章最早是在我的CSDN博客上面发布了:<a href="http://blog.csdn.net/grackergao/article/details/18322749" title="Log2File类的使用" target="_blank" rel="external">http://blog.csdn.net/grackergao/article/details/18322749</a> .现在讲他转移到了这里,代码的Github地址 :<a href="https://github.com/Gracker/Android-Utils/blob/master/Log2File.java" title="Log2File的github地址" target="_blank" rel="external">https://github.com/Gracker/Android-Utils/blob/master/Log2File.java</a><br><br><a id="more"></a><br><br>## 1.Log2File工具类源码<br><br><pre class="lang:java decode:true " title="Log2File工具类源码">import java.io.BufferedWriter;<br>import java.io.File;<br>import java.io.FileWriter;<br>import java.io.IOException;<br>import java.util.Date;<br><br>import android.content.Context;<br>import android.os.Environment;<br><br>public class Log2File<br>{<br>    private static boolean  logInit;<br>    private static BufferedWriter writer;<br><br>    private Log2File()<br>    {<br><br>    }<br><br>    /<strong><br>     <em> 初始化Log,创建log文件
     </em> @param ctx<br>     <em> @param fileName
     </em> @return<br>     */<br>    public static boolean init(Context ctx, String fileName)<br>    {<br>        if(!logInit)<br>        {<br>            String state = Environment.getExternalStorageState();<br>            if (Environment.MEDIA_MOUNTED.equals(state))<br>            {<br>                File sdDir = Environment.getExternalStorageDirectory();<br>                File logDir = new File(sdDir.getAbsolutePath() + “/log2file/“ +<br>                        ctx.getPackageName() + “/“);<br><br>                try {<br>                    if(!logDir.exists())<br>                    {<br>                        logDir.mkdirs();<br>                    }<br><br>                    File logFile = new File(logDir, fileName);<br>                    logFile.createNewFile();<br><br>                    writer = new BufferedWriter(new FileWriter(logFile, true));<br>                    logInit = true;<br>                } catch (IOException e) {<br>                    // TODO Auto-generated catch block<br>                    e.printStackTrace();<br>                }<br><br>            }<br><br>        }<br><br>        return logInit;<br>    }<br><br>    /</strong><br>     <em> 写一条log
     </em> @param msg<br>     <em>/<br>    public static void w(String msg)<br>    {<br>        if(logInit)<br>        {<br>            try {<br>                Date date = new Date();<br>                writer.write(“[“ + date.toLocaleString() + “] “ + msg);<br>                writer.newLine();<br>                writer.flush();<br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>            }<br>        }<br>    }<br><br>    /**
     </em> 关闭log<br>     */<br>    public static void close()<br>    {<br>        if(logInit)<br>        {<br>            try {<br>                writer.close();<br>                writer = null;<br><br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>                e.printStackTrace();<br>            }<br><br>            logInit = false;<br>        }<br>    }<br>}<br></pre><br><br>##  2.Log2File类的使用<br><br><div>这个工具类的使用比较简单</div><br><div>1.首先调用init进行初始化</div><br><div><br><pre class="lang:java decode:true " title="Log2File类的初始化">Log2File.init(context, fileName);</pre><br>2.调用w()进行输出<br><pre class="lang:java decode:true " title="调用w(String msg)函数进行输出">Log2File.w(String msg);</pre><br>3.使用完毕后，记得要关闭Log<br><pre class="lang:java decode:true  crayon-selected" title="关闭Log">Log2File.close();</pre><br></div><br></div>]]></content>
    <summary type="html">
    <![CDATA[<div style="color: #000000;">Log2File工具类是用于Android程序将Log记录到文件中(如sd卡)的工具,应用场景：</div><br><div style="color: #000000;"><br><br>1.  无法连接电脑进行调试（usb线被usbotg占用）<br>2.  Log不容易被抓取<br>3.  Bug出现很随机，不是必出现<br>4.  其他自己脑补<br><br>##  0.说明<br><br>这篇文章最早是在我的CSDN博客上面发布了:<a href="http://blog.csdn.net/grackergao/article/details/18322749" title="Log2File类的使用">http://blog.csdn.net/grackergao/article/details/18322749</a> .现在讲他转移到了这里,代码的Github地址 :<a href="https://github.com/Gracker/Android-Utils/blob/master/Log2File.java" title="Log2File的github地址">https://github.com/Gracker/Android-Utils/blob/master/Log2File.java</a><br><br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Github" scheme="http://androidperformance.com/categories/Android/Github/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <link href="http://androidperformance.com/2014/04/12/analysishashmap/"/>
    <id>http://androidperformance.com/2014/04/12/analysishashmap/</id>
    <published>2014-04-11T18:26:27.000Z</published>
    <updated>2015-03-31T01:32:05.000Z</updated>
    <content type="html"><![CDATA[<div style="text-align: left">          链表和数组可以按照人们意愿排列元素的次序，但是，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，直到找到为止。如果集合中元素很多，将会消耗很多时间。有一种数据结构可以快速查找所需要查找的对象，这个就是哈希表（hash table）。</div><br><div>          HashMap是基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</div><br><div>          1.HashMap的数据结构：</div><br><div><a href="http://www.grackertalk.com/wp-content/uploads/2014/04/hm01.png" target="_blank" rel="external"><img src="http://www.grackertalk.com/wp-content/uploads/2014/04/hm01.png" alt="hm01"></a></div><br><div>           HashMap使用数组和链表来共同组成的。可以看出底层是一个数组，而数组的每个元素都是一个链表头。</div><br><div></div><br><div><br><br><a id="more"></a><br><br><pre class="theme:eclipse lang:java decode:true">    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {<br>        final K key;<br>        V value;<br>        Entry&lt;K,V&gt; next;<br>        int hash;<br>        …<br>     }</pre><br><div align="left">Entry是HashMap中的一个内部静态类，包级私有，实现了Map中的接口Entey&lt;K,V&gt;。可以看出来它内部含有一个指向下一个元素的指针。</div><br><div align="left"><span style="font-family: Consolas"> </span></div><br><div>          2.构造函数</div><br><div>          HashMap的构造函数有四个：</div><br><div>HashMap()</div><br><div>          构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。</div><br><div>HashMap(int initialCapacity)</div><br><div>          构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</div><br><div>HashMap(int initialCapacity, float loadFactor)</div><br><div>          构造一个带指定初始容量和加载因子的空 HashMap。</div><br><div>HashMap(Map&lt;? extends K,? extends V&gt; m)</div><br><div>          构造一个映射关系与指定 Map 相同的新 HashMap。</div><br><div>实际上就两种，一个是指定初始容量和加载因子，一个是用一个给定的映射关系生成一个新的HashMap。先来说第一个。</div><br><div><br><pre class="theme:eclipse lang:java decode:true">    /<strong><br>     <em> Constructs an empty &lt;tt&gt;HashMap &lt;/tt&gt; with the specified initial
     </em> capacity and load factor.<br>     <em>
     </em> @param  initialCapacity the initial capacity<br>     <em> @param  loadFactor      the load factor
     </em> @throws IllegalArgumentException if the initial capacity is negative<br>     <em>         or the load factor is nonpositive
     </em>/<br>    public HashMap( int initialCapacity, float loadFactor) {<br>        if (initialCapacity &lt; 0)<br>            throw new IllegalArgumentException( “Illegal initial capacity: “ +<br>                                               initialCapacity);<br>        if (initialCapacity &gt; MAXIMUM_CAPACITY)<br>            initialCapacity = MAXIMUM_CAPACITY;<br>        if (loadFactor &lt;= 0 || Float. isNaN(loadFactor))<br>            throw new IllegalArgumentException( “Illegal load factor: “ +<br>                                               loadFactor);<br><br>        // Find a power of 2 &gt;= initialCapacity<br>        int capacity = 1;<br>        while (capacity &lt; initialCapacity)<br>            capacity &lt;&lt;= 1;<br><br>        this.loadFactor = loadFactor;<br>        threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);<br>        table = new Entry[capacity];<br>        useAltHashing = sun.misc.VM. isBooted() &amp;&amp;<br>                (capacity &gt;= Holder. ALTERNATIVE_HASHING_THRESHOLD);<br>        init();<br>    }</strong></pre><br>&nbsp;<br><div><br><div align="left">参数很简单，初始容量，和加载因子。初始容量定义了初识数组的大小，加载因子和初始容量的乘积确定了一个阈值。阈值最大是(1&lt;&lt;30) + 1。初始容量一定是2的N次方，而且刚刚比要设置的值大。默认初始容量是16，默认加载因子是0.75。当表中的元素数量大于等于阈值时，数组的容量会翻倍，并重新插入元素到新的数组中，所以HashMap不保证顺序恒久不变。</div><br><div align="left">当输入的加载因子小于零或者不是浮点数时会抛出异常（IllegalArgumentException）。</div><br><div align="left"></div><br><div align="left"><br><div>3.put操作</div><br><div><br><pre class="theme:eclipse lang:java decode:true ">    /<br>     <em> Associates the specified value with the specified key in this map.
     </em> If the map previously contained a mapping for the key, the old<br>     <em> value is replaced.
     </em><br>     <em> @param key key with which the specified value is to be associated
     </em> @param value value to be associated with the specified key<br>     <em> @return the previous value associated with &lt;tt&gt;key &lt;/tt&gt;, or
     </em>         &lt;tt&gt;null &lt;/tt&gt; if there was no mapping for &lt;tt&gt; key&lt;/tt&gt; .<br>     <em>         (A &lt;tt&gt;null &lt;/tt&gt; return can also indicate that the map
     </em>         previously associated &lt;tt&gt;null &lt;/tt&gt; with &lt;tt&gt; key&lt;/tt&gt; .)<br>     <em>/<br>    public V put(K key, V value) {<br>        if (key == null)<br>            return putForNullKey(value);<br>        int hash = hash(key);<br>        int i = indexFor(hash, table .length );<br>        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e. next) {<br>            Object k;<br>            if (e. hash == hash &amp;&amp; ((k = e. key) == key || key.equals(k))) {<br>                V oldValue = e. value;<br>                e. value = value;<br>                e.recordAccess( this);<br>                return oldValue;<br>            }<br>        }<br><br>        modCount++;<br>        addEntry(hash, key, value, i);<br>        return null;<br>    }</em></pre><br>&nbsp;<br><div>由于HashMap只是key值为null，所以首先要判断key值是不是为null，是则进行特殊处理。</div><br></div><br></div><br></div><br></div><br>&nbsp;<br><pre class="theme:eclipse lang:java decode:true ">    /**
      Offloaded version of put for null keys<br>     <em>/<br>    private V putForNullKey(V value) {<br>        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e. next) {<br>            if (e. key == null) {<br>                V oldValue = e. value;<br>                e. value = value;<br>                e.recordAccess( this);<br>                return oldValue;<br>            }<br>        }<br>        modCount++;<br>        addEntry(0, null, value, 0);<br>        return null;<br>    }</em></pre><br>&nbsp;<br><div><br><div align="left">可以看出key值为null则会插入到数组的第一个位置。如果第一个位置存在，则替代，不存在则添加一个新的。稍后会看到addEntry函数。</div><br><div align="left">PS：考虑一个问题，key值为null会插入到table[0]，那为什么还要遍历整个链表呢？</div><br><div align="left">回到put函数中。在判断key不为null后，会求key的hash值，并通过indexFor函数找出这个key应该存在table中的位置。</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Returns index for hash code h.<br>     <em>/<br>    static int indexFor (int h, int length) {<br>        return h &amp; (length-1);<br>    }</em></pre><br>&nbsp;<br><div><br><div align="left">indexFor函数很简短，但是却实现的很巧妙。一般来说我们把一个数映射到一个固定的长度会用取余（%）运算，也就是h % length，但里巧妙地运用了table.length的特性。还记得前面说了数组的容量都是很特殊的数，是2的N次方。用二进制表示也就是一个1后面N个0，（length-1）就是N个1了。这里直接用与运算，运算速度快，效率高。但是这是是利用了length的特殊性，如果length不是2的N次方的话可能会增加冲突。</div><br><div align="left">前面的问题在这里就有答案了。因为indexFor函数返回值的范围是0到（length-1），所以可能会有key值不是null的Entry存到table[0]中，所以前面还是需要遍历链表的。</div><br><div align="left">得到key值对应在table中的位置，就可以对链表进行遍历，如果存在该key则，替换value，并把旧的value返回，modCount++代表操作数加1。这个属性用于Fail-Fast机制，后面讲到。如果遍历链表后发现key不存在，则要插入一个新的Entry到链表中。这时就会调用addEntry函数。</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Adds a new entry with the specified key, value and hash code to<br>     <em> the specified bucket.  It is the responsibility of this
     </em> method to resize the table if appropriate.<br>     <em>
     </em> Subclass overrides this to alter the behavior of put method.<br>     <em>/<br>    void addEntry (int hash, K key, V value, int bucketIndex) {<br>        if ((size &gt;= threshold) &amp;&amp; ( null != table[bucketIndex])) {<br>            resize(2 </em> table. length);<br>            hash = ( null != key) ? hash(key) : 0;<br>            bucketIndex = indexFor(hash, table.length);<br>        }<br><br>        createEntry(hash, key, value, bucketIndex);<br>    }</pre><br>&nbsp;<br><div>这个函数有四个参数，第一个是key的hash值，第二个第三个分别是key和value，最后一个是这个key在table中的位置，也就是indexFor(hash(key), table.length-1)。首先会判断size（当前表中的元素个数）是不是大于或等于阈值。并且判断数组这个位置是不是空。如果条件满足则要resize(2 <em> table. length)，等下我们来看这个操作。超过阈值要resize是为了减少冲突，提高访问效率。判断当前位置不是空时才resize是为了尽可能减少resize次数，因为这个位置是空，放一个元素在这也没有冲突，所以不影响效率，就先不进行resize了。</em></div><br><div><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Rehashes the contents of this map into a new array with a<br>     <em> larger capacity.  This method is called automatically when the
     </em> number of keys in this map reaches its threshold.<br>     <em>
     </em> If current capacity is MAXIMUM_CAPACITY, this method does not<br>     <em> resize the map, but sets threshold to Integer.MAX_VALUE.
     </em> This has the effect of preventing future calls.<br>     <em>
     </em> @param newCapacity the new capacity, MUST be a power of two;<br>     <em>        must be greater than current capacity unless current
     </em>        capacity is MAXIMUM_CAPACITY (in which case value<br>     <em>        is irrelevant).
     </em>/<br>    void resize(int newCapacity) {<br>        Entry[] oldTable = table;<br>        int oldCapacity = oldTable. length;<br>        if (oldCapacity == MAXIMUM_CAPACITY) {<br>            threshold = Integer. MAX_VALUE;<br>            return;<br>        }<br><br>        Entry[] newTable = new Entry[newCapacity];<br>        boolean oldAltHashing = useAltHashing;<br>        useAltHashing |= sun.misc.VM. isBooted() &amp;&amp;<br>                (newCapacity &gt;= Holder. ALTERNATIVE_HASHING_THRESHOLD);<br>        boolean rehash = oldAltHashing ^ useAltHashing;<br>        transfer(newTable, rehash);<br>        table = newTable;<br>        threshold = (int)Math.min(newCapacity <em> loadFactor , MAXIMUM_CAPACITY + 1);<br>    }</em></pre><br>&nbsp;<br><div><br><div align="left">resize操作先要判断当前table的长度是不是已经等于最大容量（1&lt;&lt;30）了，如果是则把阈值调到整数的最大值（(1&lt;&lt;31) - 1），就没有再拓展table的必要了。如果没有到达最大容量，就要生成一个新的空数组，长度是原来的两倍。这时候可能要问了，如果oldTable. length不等于MAXIMUM_CAPACITY，但是（2  oldTable. length）也就是newCapacity大于MAXIMUM_CAPACITY怎么办？这个是不可能的，因为数组长度是2的N次方，而MAXIMUM_CAPACITY = 1&lt;&lt;30。</div><br><div align="left">生成新的数组后要执行transfer函数。</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true">    /<strong><br>     <em> Transfers all entries from current table to newTable.
     </em>/<br>    void transfer(Entry[] newTable, boolean rehash) {<br>        int newCapacity = newTable. length;<br>        for (Entry&lt;K,V&gt; e : table) {<br>            while( null != e) {<br>                Entry&lt;K,V&gt; next = e. next;<br>                if ( rehash) {<br>                    e. hash = null == e. key ? 0 : hash(e. key);<br>                }<br>                int i = indexFor(e.hash, newCapacity);<br>                e. next = newTable[i];<br>                newTable[i] = e;<br>                e = next;<br>            }<br>        }<br>    }</strong></pre><br>&nbsp;<br><div><br><div align="left">这个函数要做的就是把原来table中的值挨个拿出来插到新数组中，由于数组长度发生了改变，所以元素的位置肯定发生变化，所以HashMap不能保证该顺序恒久不变。回到resize函数，这时新的数组已经生成了，只需要替换原来数组就好了。并且要更新一下阈值。可以看出来resize是个比较消耗资源的函数，所以能减少resize的次数就尽量减少。</div><br><div align="left">回到函数addEntry 中，判断完是不是需要resize后就需要创建一个新的Entry了。</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true ">    /<br>     <em> Like addEntry except that this version is used when creating entries
     </em> as part of Map construction or “pseudo -construction” (cloning,<br>     <em> deserialization).  This version needn’t worry about resizing the table.
     </em><br>     <em> Subclass overrides this to alter the behavior of HashMap(Map),
     </em> clone, and readObject.<br>     <em>/<br>    void createEntry( int hash, K key, V value, int bucketIndex) {<br>        Entry&lt;K,V&gt; e = table[bucketIndex];<br>        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);<br>        size++;<br>    }</em></pre><br>&nbsp;<br><div>调用createEntry函数，参数跟addEntry一样，第一个是key的hash值，第二个第三个分别是key和value，最后一个是这个key在table中的位置。这里的操作与Entry的构造函数有关系。</div><br><div><br><pre class="theme:eclipse lang:java decode:true ">        /**
          Creates new entry.<br>         <em>/<br>        Entry (int h, K k, V v, Entry&lt;K,V&gt; n) {<br>            value = v;<br>            next = n;<br>            key = k;<br>            hash = h;<br>        }</em></pre><br>&nbsp;<br><div>构造函数中传入一个Entry对象，并把它当做这个新生成的Entry的next。所以createEntry函数中的操作相当于把table[bucketIndex]上的链表拿下来，放在新的Entry后面，然后再把新的Entry放到table[bucketIndex]上。</div><br><div><a href="http://www.grackertalk.com/wp-content/uploads/2014/04/hm02.png" target="_blank" rel="external"><img src="http://www.grackertalk.com/wp-content/uploads/2014/04/hm02.png" alt="hm02"></a></div><br><div></div><br><div><br><div><br><div align="left">到这里整个put函数算是结束了。如果新插入的K，V则会返回null。</div><br><div align="left"></div><br><div align="left">4.get操作</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Returns the value to which the specified key is mapped,<br>     <em> or {@code null} if this map contains no mapping for the key.
     </em><br>     <em> &lt;p&gt;More formally, if this map contains a mapping from a key
     </em> {@code k} to a value {@code v} such that {@code (key==null ? k==null :<br>     <em> key.equals(k))}, then this method returns {@code v}; otherwise
     </em> it returns {@code null}.  (There can be at most one such mapping.)<br>     <em>
     </em> &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily &lt;/i&gt;<br>     <em> indicate that the map contains no mapping for the key; it’s also
     </em> possible that the map explicitly maps the key to {@code null}.<br>     <em> The {@link #containsKey containsKey} operation may be used to
     </em> distinguish these two cases.<br>     <em>
     </em> @see #put(Object, Object)<br>     <em>/<br>    public V get(Object key) {<br>        if (key == null)<br>            return getForNullKey();<br>        Entry&lt;K,V&gt; entry = getEntry(key);<br><br>        return null == entry ? null : entry.getValue();<br>    }</em></pre><br>&nbsp;<br><div>也是先判断key是不是null，做特殊处理。直接上代码，不赘述。</div><br><div><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Offloaded version of get() to look up null keys.  Null keys map<br>     <em> to index 0.  This null case is split out into separate methods
     </em> for the sake of performance in the two most commonly used<br>     <em> operations (get and put), but incorporated with conditionals in
     </em> others.<br>     <em>/<br>    private V getForNullKey() {<br>        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e. next) {<br>            if (e. key == null)<br>                return e. value;<br>        }<br>        return null;<br>    }</em></pre><br>&nbsp;<br><div>key不是null则会调用getEntry函数，并返回一个Entry对象，如果不是null，就返回entry的value。</div><br><div><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Returns the entry associated with the specified key in the<br>     <em> HashMap.  Returns null if the HashMap contains no mapping
     </em> for the key.<br>     <em>/<br>    final Entry&lt;K,V&gt; getEntry(Object key) {<br>        int hash = (key == null) ? 0 : hash(key);<br>        for (Entry&lt;K,V&gt; e = table[ indexFor(hash, table.length)];<br>             e != null;<br>             e = e. next) {<br>            Object k;<br>            if (e. hash == hash &amp;&amp;<br>                ((k = e. key) == key || (key != null &amp;&amp; key.equals(k))))<br>                return e;<br>        }<br>        return null;<br>    }</em></pre><br>&nbsp;<br><div><br><div align="left">直接求key值hash值，然后求table中的位置，遍历链表。有返回entry对象，没有返回null。</div><br><div align="left"></div><br><div align="left">5. Fail-Fast机制：</div><br></div><br></div><br></div><br><pre class="theme:eclipse lang:java decode:true ">    /**
      The number of times this HashMap has been structurally modified<br>     <em> Structural modifications are those that change the number of mappings in
     </em> the HashMap or otherwise modify its internal structure (e.g.,<br>     <em> rehash).  This field is used to make iterators on Collection-views of
     </em> the HashMap fail -fast.  (See ConcurrentModificationException).<br>     */<br>    transient int modCount;</pre><br>&nbsp;<br><div><br><div align="left">    我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</div><br><div align="left">    这一策略在源码中的实现是通过modCount域，保证线程之间修改的可见性。，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</div><br><div>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</div><br><div></div><br><div><br><div><br><div>《Core JAVA》</div><br><div>《JDK 中文文档》</div>

<div style="color: #000000;font-family: 微软雅黑"><br>        <table><br>            <tr><br>                <td>Article Name:</td><br>                <td>HashMap源码分析</td><br>            </tr><br>            <tr><br>                <td>Author:</td><br>                <td>刘天昊</td><br>            </tr><br>            <tr><br>                <td>Email:</td><br>                <td>liutianhao.pro@gmail.com</td><br>            </tr><br>        </table><br></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div>]]></content>
    <summary type="html">
    <![CDATA[<div style="text-align: left">          链表和数组可以按照人们意愿排列元素的次序，但是，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，直到找到为止。如果集合中元素很多，将会消耗很多时间。有一种数据结构可以快速查找所需要查找的对象，这个就是哈希表（hash table）。</div><br><div>          HashMap是基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</div><br><div>          1.HashMap的数据结构：</div><br><div><a href="http://www.grackertalk.com/wp-content/uploads/2014/04/hm01.png"><img src="http://www.grackertalk.com/wp-content/uploads/2014/04/hm01.png" alt="hm01"></a></div><br><div>           HashMap使用数组和链表来共同组成的。可以看出底层是一个数组，而数组的每个元素都是一个链表头。</div><br><div></div><br><div><br><br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://androidperformance.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Service：开发自己的通知中心(2):辅助性服务实战]]></title>
    <link href="http://androidperformance.com/2014/04/01/android-service-build-your-own-notification-servers-app/"/>
    <id>http://androidperformance.com/2014/04/01/android-service-build-your-own-notification-servers-app/</id>
    <published>2014-03-31T16:05:47.000Z</published>
    <updated>2015-03-27T05:27:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-辅助性服务实战介绍">1.辅助性服务实战介绍</h2><p>上一篇文章介绍了什么是Accessibility以及简单的使用，这一篇文章就来讲讲如何使用Accessibility服务来创建一个简单的Android通知中心。Android中通知中心是一个系统层面的服务，负责显示应用和系统发来的通知（Notification，比如USB插入、选择输入法、未接来电、截图、天气信息、新闻推送等等）。在android4.3之前，一般的第三方应用是无法获取Notification list的（在Android4.3之后，有了一个新的接口,NotificationListenerService.getActiveNotifications(),可以获取当前的Notification）。但是利用Accessibility服务可以监听到各种事件的特性，可以开发一个第三方的通知中心，实现与系统通知栏类似的功能。</p>
<a id="more"></a>
<p>下面就来介绍如何开发自己的通知中心。</p>
<h2 id="2-开发第三方通知中心">2.开发第三方通知中心</h2><h3 id="2-1继承AccessibilitySerivce">2.1继承AccessibilitySerivce</h3><p>按照上一篇辅助性服务的介绍，一个辅助性服务可以被捆绑到一个标准的应用程序上，或者以一个单独的安卓工程被创建，我们这里建立一个服务，继承AccessibilitySerivce</p>
<pre class="\"lang:java" decode:true\"="" title="\"继承AccessibilityService\"">import android.accessibilityservice.AccessibilityService;
import android.accessibilityservice.AccessibilityServiceInfo;
import android.app.Notification;
import android.app.PendingIntent;
import android.content.Intent;
import android.os.Parcelable;
import android.util.Log;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;
import android.view.accessibility.AccessibilityRecord;
import android.widget.Toast;

public class NotificationFetcherService extends AccessibilityService {

    private static final String TAG = \"NotificationFetcherService: \";

    public void onAccessibilityEvent(AccessibilityEvent event) {
        if (!(event.getEventType() == AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED) ){
            return;
        }

        Notification localNotification = (Notification)event.getParcelableData();

        if (localNotification != null) {
            Intent intent=new Intent();
            intent.putExtra(\"NotifyData\", localNotification);
            intent.setAction(\".NotificationFetcherService\");
            sendBroadcast(intent);
        }

    }

    @Override
    protected void onServiceConnected() {

        // Define it in both xml file and here,  for compatibility with pre-ICS devices
        AccessibilityServiceInfo info = new AccessibilityServiceInfo();
        info.eventTypes = AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED |
                AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED | 
                AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED;

        info.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;
        setServiceInfo(info);
    }

    @Override
    public void onInterrupt() {
        System.out.println(\"onInterrupt\");
    }

}</pre>

<p>继承AccessibilitySerivce必须要重写几个重要的方法：</p>
<p>onServiceConnected方法负责在服务和Activity绑定的时候，进行初始化数据，这里新建了一个AccessibilityServiceInfo对象，并将TYPE_NOTIFICATION_STATE_CHANGED、TYPE_WINDOW_STATE_CHANGED、TYPE_WINDOW_CONTENT_CHANGED纳入监听范围，TYPE_NOTIFICATION_STATE_CHANGED表示这个服务可以监听Notification的变化，我们正是使用这个特性来实现第三方的通知中心功能。</p>
<p>onInterrupt是服务断开时调用的函数</p>
<p>onAccessibilityEvent是最重要的，它负责监听所注册的eventTypes（在onServiceConnected中注册的）的事件。从上面的代码中我们可以得到一个Notification对象：</p>
<pre class="\"lang:java" decode:true\"="" title="\"得到Notification对象\"">Notification localNotification = (Notification)event.getParcelableData();</pre>

<p>得到Notification对象之后，就可以进行自己的操作，我这里是通过广播的形式，将收到的Notification发送给Activity进行处理。</p>
<p>这里也会碰到一个小问题：当一个Notification对象太大时（比如截图、未接来电等，Notification.contentView就很大，通过广播传播会出现data过大无法传输的问题），这时可以把Notification.contentView对象暂时保存在Application中，然后再置为null，Activity中接收到数据后，再进行赋值。</p>
<h3 id="2-2在Manifest中注册service">2.2在Manifest中注册service</h3><pre class="\"lang:java" decode:true\"="">&lt;service
            android:name=\".NotificationFetcherService\"
            android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\" &gt;
            &lt;intent-filter&gt;
                &lt;action android:name=\"android.accessibilityservice.AccessibilityService\" /&gt;
            &lt;/intent-filter&gt;

            &lt;meta-data
                android:name=\"android.accessibilityservice\"
                android:resource=\"@xml/accessibilityserviceconfig /&gt;
&lt;/service&gt;</pre>

<p>这里就是普通的service注册，注意 &lt;mate-data&gt;标签中的xml文件：从Android 4.0版本开始，有另外一种方法：使用XML文件来配置这类服务。如果你以XML的形式来定义你的服务，某些像canRetrieveWindowContent可配置的选项就可用了。和service一样的配置，使用XML来定义。如果你要使用XML路径，要在你的mainfest文件中指定它，在你的服务声明中添加&lt;meta-data&gt;标签,并指向这个XML资源文件。比如上面的代码，我们在res/xml/中建立accessibilityaseviceconfig.xml，内容如下：</p>
<pre class="\"lang:java" decode:true\"="">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;
&lt;accessibility-service xmlns:android=\"http://schemas.android.com/apk/res/android\"
    android:accessibilityEventTypes=\"typeWindowStateChanged|typeNotificationStateChanged|typeWindowContentChanged\"
    android:accessibilityFeedbackType=\"feedbackGeneric\"
/&gt;</pre>

<p>服务这里就配置好了。</p>
<h3 id="2-3_接受并处理Notification">2.3 接受并处理Notification</h3><p>下面的Activity中就可以接受这个数据，然后怎么处理就看自己了，这里只是简单地显示出来。</p>
<pre class="\"lang:java" decode:true\"="">import android.app.Activity;
import android.app.Application;
import android.app.Notification;
import android.app.PendingIntent;
import android.app.PendingIntent.CanceledException;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.Parcelable;
import android.os.Process;
import android.text.method.ScrollingMovementMethod;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.RemoteViews;
import android.widget.TextView;

public class NotificaitonActivity extends Activity {
    private static final int NOTIFY_DATA_FLAG = 1;
    private static final String NOTIFY_DATA_ID_STR= \"NotifyData\";

    private NotifyDataReceiver  receiver;
    private TextView textView;
    private LinearLayout rootLayout;
    private Button button;

    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);
        textView = (TextView) findViewById(R.id.notify_test_textview);
        textView.setMovementMethod(ScrollingMovementMethod.getInstance());
        rootLayout = (LinearLayout) findViewById(R.id.root_layout);

        registerBroadcast();

        button = (Button) findViewById(R.id.test_button);
        button.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Button b = new Button(NotificaitonActivity.this);
                b.setText(\"Tthis\");
                rootLayout.addView(b);
            }
        });
    }

    private void registerBroadcast() {
        receiver = new NotifyDataReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(\".NotificationFetcherService\");
        this.registerReceiver(receiver, filter);
        Log.e(\"Dx:\", \"Broadcast registered.........\");
    }

    private void addToUi(RemoteViews remoteView) {
        rootLayout.addView(remoteView);
    }

    private void showNotify(String notiString) {
        textView.setText(textView.getText() + \"n\" + notiString);
    }

    private class NotifyDataReceiver extends BroadcastReceiver{

        @Override
        public void onReceive(Context context, Intent intent) {
            Log.e(\"Dx:\", \"Receiver got msg in onReceive()...\");

            Parcelable notifyParcelable = intent.getParcelableExtra(\"NotifyData\");

            if (notifyParcelable != null) {

                Notification notification = (Notification) notifyParcelable;
                showNotify(\"tickerText: \" + notification.tickerText);
                showNotify(\"toString: \" + (String)(notification.toString()));

                RemoteViews remoteV = notification.contentView;
                if (remoteV==null) {
                    showNotify(\"remoteView is: null\" );
                } else {
                    showNotify(\"remoteView is: not null\" );

                    addToUi(remoteV);
                }

                PendingIntent pendIntent = notification.contentIntent;
                if (pendIntent==null) {
                    showNotify(\"pendIntent is: null\" );
                } else {
                showNotify(\"pendIntent is: not null\" );
                }

                showNotify(\"**************************\" );
                showNotify(\"                    \" );

            }

        }
    }

}</pre>

<p><span style="\"color:" #ff0000;\"="">注：这里有很重要的一点，由于AccessibilityService的特殊性，用户必须手动到设置-辅助功能中，打开对应的服务，我们才可以通过AccessibilityService获得对应的数据，这一点非常重要。</span></p>
<p>上面的Activity只是简单地显示Notification，关于更多Notification的操作，可以参考Notification这个类，其中重要的属性有：contentView，flags。要模拟真正的通知中心，还是要费一番功夫的。这里由于公司项目的保密，暂不提供对应的实现代码（其实得到Notification就已经成功了一半了），有兴趣的同学可以私下和我交流。</p>
<h2 id="3-总结和问题">3.总结和问题</h2><p>AccessibilityService的实战就讲到这里，这一篇博文也是拖了一段时间才写完的，也算是为前一段时间的项目做个了结。</p>
<p>项目中目前还存在的问题：</p>
<ol>
<li>无法获取安装这个应用之前的系统的Notification</li>
<li>得到的Notification对象没法保存在本地，所以这个服务被杀掉之后，所有的数据都会丢失。（试过用db4o这种对象数据库来进行存储，发现行不通）</li>
<li>对Android系统的Notification对象的行为模仿不够（有些系统的事件监听不到，比如usb的插拔、usb调试的开关等）</li>
</ol>
<p>上面的问题，如果你有好的想法，我们私下交流。</p>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-辅助性服务实战介绍">1.辅助性服务实战介绍</h2><p>上一篇文章介绍了什么是Accessibility以及简单的使用，这一篇文章就来讲讲如何使用Accessibility服务来创建一个简单的Android通知中心。Android中通知中心是一个系统层面的服务，负责显示应用和系统发来的通知（Notification，比如USB插入、选择输入法、未接来电、截图、天气信息、新闻推送等等）。在android4.3之前，一般的第三方应用是无法获取Notification list的（在Android4.3之后，有了一个新的接口,NotificationListenerService.getActiveNotifications(),可以获取当前的Notification）。但是利用Accessibility服务可以监听到各种事件的特性，可以开发一个第三方的通知中心，实现与系统通知栏类似的功能。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android:Ubuntu下执行Adb命令找不到设备]]></title>
    <link href="http://androidperformance.com/2014/03/25/ubuntu-adb-can-not-find-devices/"/>
    <id>http://androidperformance.com/2014/03/25/ubuntu-adb-can-not-find-devices/</id>
    <published>2014-03-25T03:15:17.000Z</published>
    <updated>2015-03-27T05:25:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-问题概述">1.问题概述</h2><p><span style="color: #000000;">最近开发Nokia项目，遇到的问题如下：</span></p>
<p><span style="color: #000000;">插入Nokia x后，电脑没有反应，即不识别，同事的windows也不识别，最后在谷歌上搜索了良久，才找到了解决方案，但是没有记录，后来又要给别人配置的时候，发现忘记怎么配置了。想想这也是一个具有通性的问题，还是记录下来，分享给大家。</span></p>
<h2 id="2-问题解决方案">2.问题解决方案</h2><p><span style="color: #000000;">首先问题是：执行adb命令提示找不到设备，在做其他操作之前，请先确认已经做了如下操作：</span></p>
<ol>
<li><span style="color: #000000;">确定已经打开了USB调试选项（设置-开发者选项-USB调试），有的机器没有开发者选项，需要到关于里面点击版本号若干下，或者去百度谷歌。</span></li>
<li><span style="color: #000000;">确定使用sudo命令adb kill-server 和adb start-server后仍然没有用。</span><br><span style="color: #000000;">如果上述操作都确认了，还是找不到设备，那么继续往下看：</span></li>
</ol>
<a id="more"></a>
<h3 id="2-1-运行lsusb"><span style="color: #000000;">2.1.运行lsusb</span></h3><pre class="lang:java decode:true">~ » lsusb                                                                  
Bus 002 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 003 Device 004: ID 1532:0016 Razer USA, Ltd DeathAdder Mouse
Bus 003 Device 003: ID 05d5:624c Super Gate Technology Co., Ltd 
Bus 003 Device 033: ID 0421:06e8 Nokia Mobile Phones 
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hu</pre>

<h3 id="2-2-注册到udve的rules文件"><span style="color: #000000;">2.2.注册到udve的rules文件</span></h3><pre class="lang:java decode:true">vim  /etc/udev/rules.d/51-android.rules    
添加这个ID：1ebf，如下：    
SUBSYSTEM=="usb", SYSFS{"Nokia Mobile Phones"}=="0421", MODE="06e8"   
保存文件并运行：    
sudo chmod a+rx /etc/udev/rules.d/51-android.rules    
sudo /etc/init.d/udev restart    
运行结果如下：    
Rather than invoking init scripts through /etc/init.d, use the service(8)    
utility, e.g. service udev restart    
Since the script you are attempting to invoke has been converted to an    
Upstart job, you may also use the stop(8) and then start(8) utilities,    
e.g. stop udev ; start udev. The restart(8) utility is also available.    
udev stop/waiting    
udev start/running, process 14636</pre>

<h3 id="2-3-使用sudo_关闭和启动adb"><span style="color: #000000;"> 2.3.使用sudo 关闭和启动adb</span></h3><p><pre class="lang:java decode:true">cd ~/tools/android-sdk-linux_x86/platform-tools<br>sudo ./adb kill-server<br>sudo ./adb start-server</pre><br><span style="color: #000000;"><span style="color: #ff0000;"> 注：一般情况下，上面的操作就可以。特殊情况下，usb设备还是不能被识别，比如我手上这台Nokia X</span>。那么继续：</span></p>
<h3 id="2-4-打开_～/-android/adb_usb-ini，加入之前的lsusb得到的信息"><span style="color: #000000;">2.4.打开 ～/.android/adb_usb.ini，加入之前的lsusb得到的信息</span></h3><p><pre class="lang:java decode:true"># ANDROID 4RD PARTY USB VENDOR ID LIST — DO NOT EDIT.</pre></p>
<h1 id="USE_‘android_update_adb’_TO_GENERATE-">USE ‘android update adb’ TO GENERATE.</h1><h1 id="1_USB_VENDOR_ID_PER_LINE">1 USB VENDOR ID PER LINE</h1><h1 id="for_nokia_x">for nokia x</h1><p>0x0421<br><span style="color: #000000;"> 保存关闭后，就可以识别了。windows下也是如此，不多叙述了。</span></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-问题概述">1.问题概述</h2><p><span style="color: #000000;">最近开发Nokia项目，遇到的问题如下：</span></p>
<p><span style="color: #000000;">插入Nokia x后，电脑没有反应，即不识别，同事的windows也不识别，最后在谷歌上搜索了良久，才找到了解决方案，但是没有记录，后来又要给别人配置的时候，发现忘记怎么配置了。想想这也是一个具有通性的问题，还是记录下来，分享给大家。</span></p>
<h2 id="2-问题解决方案">2.问题解决方案</h2><p><span style="color: #000000;">首先问题是：执行adb命令提示找不到设备，在做其他操作之前，请先确认已经做了如下操作：</span></p>
<ol>
<li><span style="color: #000000;">确定已经打开了USB调试选项（设置-开发者选项-USB调试），有的机器没有开发者选项，需要到关于里面点击版本号若干下，或者去百度谷歌。</span></li>
<li><span style="color: #000000;">确定使用sudo命令adb kill-server 和adb start-server后仍然没有用。</span><br><span style="color: #000000;">如果上述操作都确认了，还是找不到设备，那么继续往下看：</span></li>
</ol>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Linux" scheme="http://androidperformance.com/categories/Android/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Service：开发自己的通知中心(1):辅助性服务介绍]]></title>
    <link href="http://androidperformance.com/2014/03/17/android-build-your-own-android-notification-service-app/"/>
    <id>http://androidperformance.com/2014/03/17/android-build-your-own-android-notification-service-app/</id>
    <published>2014-03-17T06:07:53.000Z</published>
    <updated>2015-03-27T05:26:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id=""> </h2><h1 id="1_辅助性服务介绍">1 辅助性服务介绍</h1><p>辅助性服务是安卓框架的一个特性，它的设计是为了让已经安装在安卓设备上的应用程序能够为用户提供一种导航式(引导式）回应。一个辅助性服务能够传达给<br>用户关于这个应用程序的利益，例如把文本转换成语音、当用户手指停留屏幕的一个重要区域时的haptic反馈。这一节涵盖了怎样去创建一个辅助性服务，如何处理应用程序的信息接收，还有如何把信息反馈给用户。<br>创建自己的辅助性服务</p>
<a id="more"></a>
<h1 id="2_创建自己的辅助性服务">2 创建自己的辅助性服务</h1><h2 id="2-1_继承AccessibilitySerivce">2.1 继承AccessibilitySerivce</h2><p>一个辅助性服务可以被捆绑到一个标准的应用程序上，或者以一个单独的安卓工程被创建。在任何情况下，创建这类服务的步骤都是一样的。在你的工程中，创建一个类继续AccessibilitySerivce。</p>
<pre class="\"lang:java" decode:true\"="" title="\"继承AccessibilityService\"">package com.example.android.apis.accessibility;

import android.accessibilityservice.AccessibilityService;

public class MyAccessibilityService extends AccessibilityService {
...
    @Override
    public void onAccessibilityEvent(AccessibilityEvent event) {
    }

    @Override
    public void onInterrupt() {
    }

...
}</pre>

<p>&nbsp;</p>
<h2 id="2-2_在mainfest中声明service">2.2 在mainfest中声明service</h2><p>像其他服务一样，你也可以在mainfest文件中声明它。记得要指定它处理android.accessibilityservice这个意图。以便当应用程序触发一个AccessibilityEvent时，这个服务能被调用。</p>
<pre class="\"lang:java" decode:true\"="" title="\"进行配置\"">&lt;application ...&gt;
...
&lt;service android:name=\".MyAccessibilityService\"&gt;
     &lt;intent-filter&gt;
         &lt;action android:name=\"android.accessibilityservice.AccessibilityService\" /&gt;
     &lt;/intent-filter&gt;
     . . .
&lt;/service&gt;
...
&lt;/application&gt;</pre>

<p>&nbsp;</p>
<h2 id="2-3_配置serivce">2.3 配置serivce</h2><p>如果你为这个服务创建一个新的工程的话，且不打算要一个应用程序，你可以把它启动活动的类（通常叫做MainActivity.java)从你的源文件中删除。同时也把相应的活动元素从你的mainfest文件中删除。<br>配置自己的辅助性服务<br>为你的辅助性服务设置配置变量，用它来告诉系统，如何和何时你想要它运行。哪一类事件你想要去响应？这个服务对所有的应用程序都是活动的吗？或者只有指定的包名的？它使用什么样的反馈？<br>你有两种方法去设置这些变量。反向兼容的方法是以代码的形式来设置它们。<br>可以使setServiceInfo(android.accessibilityservice.AccessibilityServiceInfo).如果要这样做的话，要重写onServiceConnected()方法，然后配置在那里配置你的服务。</p>
<pre class="\"lang:java" decode:true\"=""> 
@Override
public void onServiceConnected() {
    // Set the type of events that this service wants to listen to.  Others
    // won\'t be passed to this service.
    info.eventTypes = AccessibilityEvent.TYPE_VIEW_CLICKED |
            AccessibilityEvent.TYPE_VIEW_FOCUSED;

    // If you only want this service to work with specific applications, set their
    // package names here.  Otherwise, when the service is activated, it will listen
    // to events from all applications.
    info.packageNames = new String[]
            {\"com.example.android.myFirstApp\", \"com.example.android.mySecondApp\"};

    // Set the type of feedback your service will provide.
    info.feedbackType = AccessibilityServiceInfo.FEEDBACK_SPOKEN;

    // Default services are invoked only if no package-specific ones are present
    // for the type of AccessibilityEvent generated.  This service *is*
    // application-specific, so the flag isn\'t necessary.  If this was a
    // general-purpose service, it would be worth considering setting the
    // DEFAULT flag.

    // info.flags = AccessibilityServiceInfo.DEFAULT;

    info.notificationTimeout = 100;

    this.setServiceInfo(info);

}</pre>

<p>从Android 4.0版本开始，有另外一种方法：使用XML文件来配置这类服务。如果你以XML的形式来定义你的服务，某些像canRetrieveWindowContent可配置的选项就可用了。和上面一样的配置，使用XML来定义，格式如下所示：</p>
<pre class="\"lang:java" decode:true\"="">&lt;accessibility-service
     android:accessibilityEventTypes=\"typeViewClicked|typeViewFocused\"
     android:packageNames=\"com.example.android.myFirstApp, com.example.android.mySecondApp\"
     android:accessibilityFeedbackType=\"feedbackSpoken\"
     android:notificationTimeout=\"100\"
     android:settingsActivity=\"com.example.android.apis.accessibility.TestBackActivity\"
     android:canRetrieveWindowContent=\"true\"
/&gt;</pre>

<p>如果你要使用XML路径，要在你的mainfest文件中指定它，在你的服务声明中添加&lt;meta-data&gt;标签,并指向这个XML资源文件。假如你把你的XML文件存储在res/xml/serviceconfig.xml这个路径下，新的标签格式如下所示：</p>
<pre class="\"lang:java" decode:true\"="">&lt;service android:name=\".MyAccessibilityService\"&gt;
     &lt;intent-filter&gt;
         &lt;action android:name=\"android.accessibilityservice.AccessibilityService\" /&gt;
     &lt;/intent-filter&gt;
     &lt;meta-data android:name=\"android.accessibilityservice\"
     android:resource=\"@xml/serviceconfig\" /&gt;
&lt;/service&gt;</pre>

<p>&nbsp;</p>
<h2 id="2-4_响应AccessibilityEvents事件">2.4 响应AccessibilityEvents事件</h2><p>现在,您的服务被设置为运行和监听事件，写一些代码，这样当一个AccessibilityEvent真的到来，它就知道要做什么了！<br>从重写onAccessibilityEvent(AccessibilityEvent)方法开始。然后使用getEventType()来确定事件类型，然后用getContentDescription来取出任何与触发事件相关的标签文本。</p>
<pre class="\"lang:java" decode:true\"=""> 
@Override
public void onAccessibilityEvent(AccessibilityEvent event) {
    final int eventType = event.getEventType();
    String eventText = null;
    switch(eventType) {
        case AccessibilityEvent.TYPE_VIEW_CLICKED:
            eventText = \"Focused: \";
            break;
        case AccessibilityEvent.TYPE_VIEW_FOCUSED:
            eventText = \"Focused: \";
            break;
    }

    eventText = eventText + event.getContentDescription();

    // Do something nifty with this text, like speak the composed string
    // back to the user.
    speakToUser(eventText);
    ...
}</pre>

<p>为更多的上下文查询视图层次结构<br>这一步是可选的，然而它非常有用。Android 4.0(API level 14)的一个新特性：可以用AccessibilityService来查询视图层次结构，收集事件所生成的一些UI组件信息，还有这些UI的父控件和子控件。要做到这一点，确保在你的XML配置文件中做了如下设置：</p>
<pre class="\"lang:java" decode:true\"="">android:canRetrieveWindowContent=\"true\"</pre>

<p>如果设置了，通过getSource()可获得一个AccessibilityNodeInfo对象。如果发起的窗口事件仍然是活动的窗口，该调用将会返回一个对象,否则，会返回null。下面这段代码演示何时接收一个事件，步骤如下：<br>立即捕获触发事件的父视图。<br>在那个视图中，寻找一个标签和一个复选框作的子视图。<br>如果找到，创建一个字符串来向用户报告，以表明这个标签是否被选择了。<br>如果遍历视图层次结构后返回null,则会退出该方法。</p>
<pre class="\"lang:java" decode:true\"=""> 
// Alternative onAccessibilityEvent, that uses AccessibilityNodeInfo

@Override
public void onAccessibilityEvent(AccessibilityEvent event) {

    AccessibilityNodeInfo source = event.getSource();
    if (source == null) {
        return;
    }

    // Grab the parent of the view that fired the event.
    AccessibilityNodeInfo rowNode = getListItemNodeInfo(source);
    if (rowNode == null) {
        return;
    }

    // Using this parent, get references to both child nodes, the label and the checkbox.
    AccessibilityNodeInfo labelNode = rowNode.getChild(0);
    if (labelNode == null) {
        rowNode.recycle();
        return;
    }

    AccessibilityNodeInfo completeNode = rowNode.getChild(1);
    if (completeNode == null) {
        rowNode.recycle();
        return;
    }

    // Determine what the task is and whether or not it\'s complete, based on
    // the text inside the label, and the state of the check-box.
    if (rowNode.getChildCount() &lt; 2 || !rowNode.getChild(1).isCheckable()) {
        rowNode.recycle();
        return;
    }

    CharSequence taskLabel = labelNode.getText();
    final boolean isComplete = completeNode.isChecked();
    String completeStr = null;

    if (isComplete) {
        completeStr = getString(R.string.checked);
    } else {
        completeStr = getString(R.string.not_checked);
    }
    String reportStr = taskLabel + completeStr;
    speakToUser(reportStr);
}</pre>

<p>现在你有一个完整的，可以工作的辅助性服务。现在，你也可以试着配置一下，看看Android的text-to-speech engine,或使用Vibrator提供触觉反馈是如何与用户交互。</p>
<p>最后，要使用配置好的service，必须要到“设置—辅助性服务”中打开对应的service，然后才能相应对应的事件。</p>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id=""> </h2><h1 id="1_辅助性服务介绍">1 辅助性服务介绍</h1><p>辅助性服务是安卓框架的一个特性，它的设计是为了让已经安装在安卓设备上的应用程序能够为用户提供一种导航式(引导式）回应。一个辅助性服务能够传达给<br>用户关于这个应用程序的利益，例如把文本转换成语音、当用户手指停留屏幕的一个重要区域时的haptic反馈。这一节涵盖了怎样去创建一个辅助性服务，如何处理应用程序的信息接收，还有如何把信息反馈给用户。<br>创建自己的辅助性服务</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
</feed>