<!doctype html>
<html class="theme-next use-motion theme-next-next">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>




  <link rel="stylesheet" type="text/css" href="../../vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="../../css/main.css?v=0.4.0"/>





    <meta name="keywords" content="Android,Performance" />





    <link rel="shorticon icon" type="image/x-icon" href="../..//favicon.ico?v=0.4.0" />




  <title> Android Perofrmance </title>
</head>

<body>
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Android Perofrmance</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>


  <ul id="menu" class="menu">
    
      
      <li class="menu-item menu-item-home">
        <a href="../..//">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="../..//archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="../..//tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
            
          

          <div id="posts" class="posts-expand">
            
  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2014/05/17/apps-can-no-android4-4-app-longer-write-files-to-your-sd-card/">
                [Android4.4]第三方APP无法操作外置SD卡原因分析以及延伸阅读
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-05-17
          
        </span>

        
          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <a href="../../categories/Android/">Android</a>

                
                

              
            </span>
          
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/05/17/apps-can-no-android4-4-app-longer-write-files-to-your-sd-card/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/05/17/apps-can-no-android4-4-app-longer-write-files-to-your-sd-card/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h3 id="1-问题背景:">1.问题背景:</h3><p>最近做Android4.4的平台移植,遇到一个问题:在Android4.4中,第三方App是没有权限操作外置SD卡的(除非是与自己包名相同的目录),开始以为是自己申请的权限不足,最后发现是Google在Android中限制了这一权限.这是原文:</p>
<blockquote>
<p><span style="\"color:" #404040;\"="">The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions.</span></p>
</blockquote>
<p>意思就是说,只有主存储有读写的权限,第二存储(通常是外置SD卡或者USBOTG,这个可以在设置菜单中自己设置)只有读的权限.原因也有给出:</p>
<blockquote>
<p><span style="\"color:" #404040;\"="">Restricting writes in this way ensures the system can clean up files when applications are uninstalled.</span></p>
</blockquote>
<p>另一个原因我觉得是安全的问题,这一方面的陈述会在下面详细介绍.</p>
<h3 id=""> </h3><h3 id="2-解决办法:">2.解决办法:</h3><p>解决办法分两种,一种针对用户,一种针对开发者.</p>
<p><strong><em>针对用户:</em></strong></p>
<p>已经root的用户可以通过修改:<span style="\"color:" #444444;\"="">/system/etc/permissions/platform.xml</span> 文件(使用RE文件管理器即可),找到如下代码块:</p>
<pre class="\"lang:java" decode:true\"="" title="\"写sd卡的权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>修改为:</p>
<pre class="\"lang:java" decode:true\"="" title="\"修改后的写SD卡权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;group gid=\"media_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>然后重启.就可以读写SD卡了.</p>
<p>这个做法其实就是给<span style="\"color:" #666666;\"="">android.permission.WRITE_EXTERNAL_STORAGE</span> 这个权限组加上对media的读写权限.</p>
<p><strong><em>针对开发者:</em></strong></p>
<p><span style="\"color:" #323333;\"="">XDA论坛上的方法，先把文件改为图片类型，再用media content provider来删除.</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"转换成媒体文件,再进行操作\"">private static final Uri FILES_URI = MediaStore.Files.getContentUri(\"external\");
    public static boolean deleteFile(Context context, String path) {
        ContentResolver cr = context.getContentResolver();
        if (cr == null) return false;
        final String selection = FileColumns.DATA + \"=?\";
        final String[] selectionArgs = new String[] { path };
        ContentValues values = new ContentValues();
        values.put(FileColumns.MEDIA_TYPE, FileColumns.MEDIA_TYPE_IMAGE);
        return cr.update(FILES_URI, values, selection, selectionArgs) &gt; 0
                &amp;&amp; cr.delete(FILES_URI, selection, selectionArgs) &gt; 0;
    }</pre>

<p>这样做是因为MediaProvider拥有读写SD卡的 权限,通过它去操作文件也可以达到目标.不过有人反映如果把默认存储设置为内置SD卡，该方法貌似就失效了。不知道有没有更好的办法？</p>
<p><strong><em>针对rom开发者:</em></strong></p>
<p>rom开发者有更好的选择,<span style="\"color:" #444444;\"="">platform.xml的文件位置在源代码:frameworks/base/data/etc/中,和方法1中的步骤一样:</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"写sd卡的权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>修改为:</p>
<pre class="\"lang:java" decode:true\"="" title="\"修改后的写SD卡权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;group gid=\"media_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>然后重新编译一个rom即可.</p>
<p>&nbsp;</p>
<h3 id="3-延伸阅读">3.延伸阅读</h3><p>Google这么做的原因,我也查阅了一些文章,下面是一些我觉得比较好的回答,大家感兴趣可以自己看一下:</p>
<p>第一篇是Google+上的一个人的分析,大概解释了一下google这样做的原因以及造成的影响(英文很简单):</p>
<blockquote>
<p><span style="\"color:" #404040;\"="">KitKat will make your SD Card completely useless: per the Android API specification, apps can no longer write files to your SD card.  And Samsung is following it.This only applies to dual-storage devices, i.e., devices with a user-writable internal flash storage <strong>AND</strong> a removable SD card.</span></p>
<p><span style="\"color:" #404040;\"="">From </span><span style="\"color:" #427fed;\"=""><a href="http://source.android.com/devices/tech/storage/index.html" target="_blank" rel="external">http://source.android.com/devices/tech/storage/index.html</a></span><span style="\"color:" #404040;\"="">:\”The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions.\”</span></p>
<p><span style="\"color:" #404040;\"="">If your device has user-accessible internal flash storage, your SD Card is a \”secondary external storage device\”.</span></p>
<p><span style="\"color:" #404040;\"="">What this means is that with KitKat, applications will no longer be able create, modify, or remove files and folders on your external SD card.  As a for-instance, you can no longer use a file manager to copy files from your computer to the SD card over a network.  This ability, which has existed since the beginning of Android, has been taken away.</span></p>
<p><span style="\"color:" #404040;\"="">The only stated reason for this removal of functionality is that, \”Restricting writes in this way ensures the system can clean up files when applications are uninstalled.\”  I do not pretend to understand this logic.  Apps are still allowed to write in arbitrary directories on the primary storage (with the appropriate permission), but are denied the same access to external storage.</span></p>
<p><span style="\"color:" #404040;\"="">Samsung has implemented this feature with their KitKat OTA updates.  Note3 users are now complaining that FX File Explorer can no longer write to their external SD cards.  There are solutions to this problem for users with root access.  Users without root access appear to be screwed.</span></p>
<p><span style="\"color:" #404040;\"="">I\’m not quite certain how Google intends for you to place files on your SD card.  Perhaps you have to use proprietary Google apps that contain permissions unavailable to the rest of the developer world.  Perhaps you\’re supposed to put everything on the cloud and pay carrier data fees to get it there.  Perhaps you\’re supposed to use some kind of WIRE to attach your WIRELESS device to your computer and have the computer do that work for you.</span></p>
<p><span style="\"color:" #404040;\"="">In my opinion this is a horrible misstep by Google and the Android Open Source Project.  Functionality has been removed without reason, to the severe detriment of users and developers alike.</span></p>
<p><span style="\"color:" #404040;\"="">I apologize for not bringing this to everyone\’s attention when KitKat 4.4 was released, but it was not mentioned in the Android 4.4 changes document:</span><span style="\"color:" #427fed;\"=""><a href="http://developer.android.com/about/versions/android-4.4.html" target="_blank" rel="external">http://developer.android.com/about/versions/android-4.4.html</a></span><span style="\"color:" #404040;\"="">.  It\’s only mentioned in the article on </span><span style="\"color:" #427fed;\"="">source.android.com</span><span style="\"color:" #404040;\"="">.  I was only made aware of its existence from user reports as a result of Samsung implementing this change in its KitKat OTA updates. </span></p>
</blockquote>
<p>第二篇是知乎上的讨论,大家自行脑补:</p>
<blockquote>
<p><span style="\"color:" #232323;\"="">这有可能真的只是一个限制，影响很小，因为这个限制并不彻底，primary external storage 仍然可写，而支持双 SD 的设备并不很多。我们大家更期待的是让 primary external storage 也同样受到这个限制，虽然这个修改将涉及到更多应用的不兼容。</span></p>
<p><span style="\"color:" #232323;\"="">所以这个问题并没有彻底解决，到对 primary external storage 也限制的那个时候，才真正的解决了这个问题。</span></p>
<p><span style="\"color:" #232323;\"="">就目前而言，第二 SD 卡仍然是可以读写的，只是要读写到指定的目录（具体应该在 /Android/data/）。这样的规定意味着应用程序只能对 SD 卡的指定目录进行读写，不能读写任意目录。相当于 Google 出手对 SD 卡目录结构进行了规范。之前 android 不限制目录，所以各种应用就随意的在 SD 卡上建一个目录。然后 SD 卡上的目录到处都是，用户对这种现象早就深恶痛绝了！如果 Google 对这件事情下狠手，只能说是<strong>大快人心</strong>。</span></p>
<p><span style="\"color:" #232323;\"="">另外说一下，SD 卡上的指定目录是这样获取的：</span><br><span style="\"color:" #232323;\"="">1，程序相关的 内置存储目录，这个目录位于内置 flash，应用程序可以随意读写：</span></p>
<p><pre class="\"lang:java" decode:true\"="">getFilesDir();</pre><br><span style="\"color:" #232323;\"="">2，程序相关的 SD 卡外部存储目录，这个目录位于 SD 卡，应用程序可以随意读写：</span></p>
<p><pre class="\"lang:java" decode:true="" crayon-selected\"="">getExternalFilesDir(null);</pre><br><span style="\"color:" #232323;\"="">3，SD 卡公共目录，这些目录仍然可以访问，不受权限限制：</span></p>
<p><pre class="\"lang:java" decode:true\"="">Environment.getExternalStoragePublicDirectory(x)</pre><br><span style="\"color:" #232323;\"="">其中 x 可以是 Environment.DIRECTORY_ALARMS 等预定义的常量。可以查找 Environment 的帮助。</span></p>
<p><span style="\"color:" #232323;\"="">如果大家要存储数据，可以用 1 或者 2 的方法，获取正确的目录，然后进行任意读写，这样不会把 SD 卡的目录写乱。</span></p>
</blockquote>
<p>第三篇也是知乎上一个讨论:</p>
<blockquote>
<p><span style="\"color:" #232323;\"="">Google 给出的理由有一定的道理——相信很多有洁癖的人都很讨厌第三方应用在 SD 卡或者内置存储下随意建立文件夹吧，有节操的应用应该只在以自己的包名区分的目录下存放需要的文件。</span></p>
<p><span style="\"color:" #232323;\"="">至于为什么只限制 SD 卡，不包括内置存储，我觉得是因为 SD 卡是可以插在别的地方的，目录结构是有可能暴露出来的，也有可能被修改。规范应用在 SD 卡的读写，可以使得这个 SD 卡上的目录和文件可以在其他设备上被电脑「理解」——「这个目录是在某一个 Android 设备上用到的，我不必理会它」，如果第三方应用随意在 SD 卡根目录创建命名不规范并且无规律的目录，这个 SD 卡在其他地方就会使电脑或者人迷惑——「这个目录是干什么的？是谁创建的？我可不可以删掉它？」。手机的内部存储空间不能拆卸，所以其目录结构不会轻易暴露给用户，也不会放在别的设备上，所以可以暂时不管。</span></p>
</blockquote>
<p>&nbsp;</p>
<p>参考:</p>
<p>1.<a href="\">https://plus.google.com/+TodLiebeck/posts/gjnmuaDM8sn</a></p>
<p>2.<a href="\">http://www.zhihu.com/question/22778889</a></p>
<p>3.<a href="\">http://source.android.com/devices/tech/storage/index.html</a></p>
<p>&nbsp;</p>
<p>相关阅读 :</p>
<ol>
<li><a href="\">Android4.4中扫描文件广播权限变更分析</a></li>
</ol>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2014/05/14/android4-4permission-denial-not-allowed-to-send-broadcast-android-intent-action-media-mounted/">
                [Android4.4]Permission Denial: not allowed to send broadcast android.intent.action.MEDIA_MOUNTED
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-05-14
          
        </span>

        
          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <a href="../../categories/Android/">Android</a>

                
                

              
            </span>
          
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/05/14/android4-4permission-denial-not-allowed-to-send-broadcast-android-intent-action-media-mounted/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/05/14/android4-4permission-denial-not-allowed-to-send-broadcast-android-intent-action-media-mounted/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h4 id="摘要:_Android4-4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案-">摘要: Android4.4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案.</h4><p>&nbsp;</p>
<h3 id="0-_问题背景">0. 问题背景</h3><p>在Android4.4之前，许多应用程序使用如下代码去通知更新文件数据库</p>
<pre class="\"lang:java" decode:true\"="" title="\"通知系统更新文件系统\"">sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>这样做的坏处：每次发送这个广播，都会<span style="\"color:" #222222;\"="">让MediaScanner重新扫描一次系统文件，很影响设备的电池寿命。当然传入的路径可以</span> 是单个文件或者内容很少的文件夹，会减轻扫描系统文件的压力，但是还是会因为扫描频繁而浪费电。所以在Android4.4<span style="\"color:" #222222;\"="">开始，只允许系统应用发送这样的intent。</span> 所以在Android4.4系统的机器上会出现如下错误：</p>
<pre class="\"lang:java" decode:true\"="" title="\"错误\""> Permission Denial: not allowed to send broadcast android.intent.action.MEDIA_MOUNTED</pre>

<h3 id="1-_解决办法：">1. 解决办法：</h3><p>1 . 将Intent换为 <a href="\"><code>ACTION_MEDIA_SCANNER_SCAN_FILE</code></a><span style="\"color:" #000000;\"="">.</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"ACTION_MEDIA_SCANNER_SCAN_FILE\"">sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>但是这个Intent只扫描文件，不扫描文件夹。如果你的应用只操作单个文件而不是文件夹，就可以使用这个。 2. 不发广播，换为MediaScannerConnection进行通知更新</p>
<pre class="\"lang:java" decode:true\"="" title="\"MediaScannerConnection\""> MediaScannerConnection.scanFile(this,
          new String[] { file.toString() }, null,
          new MediaScannerConnection.OnScanCompletedListener() {
      public void onScanCompleted(String path, Uri uri) {
          Log.i(\"ExternalStorage\", \"Scanned \" + path + \":\");
          Log.i(\"ExternalStorage\", \"-&gt; uri=\" + uri);
      }
 });</pre>

<p>这样做就属于不发送广播,在4.4上可以正常工作.</p>
<h4 id="拓展">拓展</h4><p>代码跟踪,让我们看看scanFile做了什么事: 1.查看scanFile的源码:</p>
<pre class="\"lang:java" decode:true\"="" title="\"scanFile\"">    public static void scanFile(Context context, String[] paths, String[] mimeTypes,
            OnScanCompletedListener callback) {
        ClientProxy client = new ClientProxy(paths, mimeTypes, callback);
        MediaScannerConnection connection = new MediaScannerConnection(context, client);
        client.mConnection = connection;
        connection.connect();
    }</pre>

<p>2.ClintProxy源码:</p>
<pre class="\"lang:java" decode:true\"="" title="\"ClientProxy\"">    static class ClientProxy implements MediaScannerConnectionClient {
        final String[] mPaths;
        final String[] mMimeTypes;
        final OnScanCompletedListener mClient;
        MediaScannerConnection mConnection;
        int mNextPath;

        ClientProxy(String[] paths, String[] mimeTypes, OnScanCompletedListener client) {
            mPaths = paths;
            mMimeTypes = mimeTypes;
            mClient = client;
        }

        public void onMediaScannerConnected() {
            scanNextPath();
        }

        public void onScanCompleted(String path, Uri uri) {
            if (mClient != null) {
                mClient.onScanCompleted(path, uri);
            }
            scanNextPath();
        }

        void scanNextPath() {
            if (mNextPath &gt;= mPaths.length) {
                mConnection.disconnect();
                return;
            }
            String mimeType = mMimeTypes != null ? mMimeTypes[mNextPath] : null;
            mConnection.scanFile(mPaths[mNextPath], mimeType);
            mNextPath++;
        }
    }</pre>

<p>3.MediaScannerConnection的connect方法:</p>
<pre class="\"lang:java" decode:true\"="" title="\"connect\"">    /**
     * Initiates a connection to the media scanner service.
     * {@link MediaScannerConnectionClient#onMediaScannerConnected()}
     * will be called when the connection is established.
     */
    public void connect() {
        synchronized (this) {
            if (!mConnected) {
                Intent intent = new Intent(IMediaScannerService.class.getName());
                intent.setComponent(
                        new ComponentName(\"com.android.providers.media\",
                                \"com.android.providers.media.MediaScannerService\"));
                mContext.bindService(intent, this, Context.BIND_AUTO_CREATE);
                mConnected = true;
            }
        }
    }</pre>

<p>这里可以看到,最后是start了一个service:MediaScannerService MediaScannerService 的源码可以在<a href="\">这里看到</a>:我们重点看一下scan方法:</p>
<pre class="\"lang:java" decode:true\"="" title="\"scan\"">private void scan(String[] directories, String volumeName) {
        // don\'t sleep while scanning
        mWakeLock.acquire();

        ContentValues values = new ContentValues();
        values.put(MediaStore.MEDIA_SCANNER_VOLUME, volumeName);
        Uri scanUri = getContentResolver().insert(MediaStore.getMediaScannerUri(), values);

        Uri uri = Uri.parse(\"file://\" + directories[0]);
        sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_STARTED, uri));

        try {
            if (volumeName.equals(MediaProvider.EXTERNAL_VOLUME)) {
                 openDatabase(volumeName);    
            }

            MediaScanner scanner = createMediaScanner();
            scanner.scanDirectories(directories, volumeName);
        } catch (Exception e) {
            Log.e(TAG, \"exception in MediaScanner.scan()\", e); 
        }

        getContentResolver().delete(scanUri, null, null);

        sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, uri));
        mWakeLock.release();
    }</pre>

<p>可以看到最终调用了<span style="\"color:" #48484c;\"="">MediaScanner来进行扫描,扫描结束后,发送ACTION_MEDIA_SCANNER_FINISHED广播.应用程序可以接受此广播来更新界面之类</span></p>
<p>&nbsp;</p>
<p>参考资料：</p>
<ol>
<li><p><a href="\">http://stackoverflow.com/questions/18624235/android-refreshing-the-gallery-after-saving-new-images</a></p>
</li>
<li><p><a href="\">http://stackoverflow.com/questions/21469431/permission-denial-not-allowed-to-send-broadcast-in-android</a></p>
</li>
<li><p><a href="\">http://www.androideng.com/?p=1108</a></p>
</li>
</ol>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2014/05/11/crazy-coder/">
                读书笔记
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-05-11
          
        </span>

        
          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <a href="../../categories/读书笔记/">读书笔记</a>

                
                

              
            </span>
          
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/05/11/crazy-coder/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/05/11/crazy-coder/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <p><address>读书交流群：78985869   欢迎加入一起分享读书的乐趣。</address><address> </address><address><span style="color: #111111;">本书描写了绝影等程序员的成长之路，分为大学、工作、创业三部分。作者笔下以绝影、BOSS liu、Bug Yang等为代表的程序员是大多程序员成长的真实写照，很多网友看过小说之后都说“这些事好像就是我身上发生的事情，但是我写不出来，绝影写出来了”。绝影给疯狂的程序员下了一个定义,现在在我看来,是相当精髓的:‘疯狂的程序员’绝对不是靠狂妄和拼命的程序员，而是能够踏实，持续努力的程序员。等你真正做到了这两点，技术上去了，在写程序这个领域，能够限制你的只有你的想像力，到那个时候，你才算个‘疯狂的程序员’，这种程序员阿，是能令竞争对手无比恐惧的。” </span></address>第一次读&lt;&lt;疯狂的程序员&gt;&gt;这本书,还是在大学的时候,现在也不记得当时是如何知道这本书的,总之读了之后,便一发不可收拾,翻来覆去读了好几遍,每次读完,都有种被打了鸡血的感觉. 绝影的身影陪伴着我读过了大学的一半生活. 工作了之后再来看这本书,还是依旧有那种感觉.在多看上看了以后,我在其中做了有一些笔记和书摘,摘录在下面,大家一起感受下.<span style="color: #111111;">这是本值得程序员或IT界的年轻人一读的书。绝影和boss liu的经历一定会给年轻的程序员以鼓舞和启发。 读完这本书，我觉得绝影他们研究的技术并不难，但是很实在。我现在却是想得太多，动手太少，可以称做伪程序员吧，欠练。 我觉得在关注技术的同时也不能对身边的人关心太少。绝影原来的女朋友小燕还是不错的，只是一直以来绝影对她的关心太少了。等到失去的时候才发现这一点就太晚了。</span></p>
<p>另外作者在书中反复强调的一个观点就是:<span style="color: #111111;">要么做第一个，要么做最好的一个. 这也是绝影所一直坚持的,所以对待每件事情都很认真,每件事情都去做到完美,他更像是给自己做东西,而不是给别人打工.</span></p>
<p>当然作者也是很幽默的,这一点让他和其他的程序员有所不同,这本书从头到尾读起来都很轻松,这也归功于作者的文笔:</p>
<blockquote>
<p><span style="color: #a9a9a9;">2013-07-17 00:41:18</span></p>
<p>人无非有两种方法提高自己，一是真的提高自己，二是打击别人提高自己</p>
<p><span style="color: #a9a9a9;">2013-07-17 11:59:55</span></p>
<p>越是神秘的东西人们就越好奇，越好奇就越羡慕。为啥老说别人的老婆比自己的好，肤浅地说是因为“审美疲劳”，有深度一点，那是因为你天天对着她，早没了神秘感。比如黑客。黑客是啥？其实黑客还不是人，还不是要吃饭睡觉泡妹妹。但是因为他神秘，为什么神秘？因为你不知道他在干什么，更不知道他干那些是用的什么技术方法，但是他又能干些你想都想不到的事情，所以好多人就羡慕黑客。正如鲁迅先生说的：“看不懂的文章，至少别人不会说是坏文章。</p>
<p><span style="color: #a9a9a9;">2013-07-17 13:36:46</span></p>
<p>程序员是值得尊敬的，程序员的双手是魔术师的双手。他们把枯燥无味的代码变成了丰富多彩的软件……</p>
<p><span style="color: #a9a9a9;">2013-07-17 13:42:54</span></p>
<p>所以说人活得很累，有很多事情，像学习，在很多时候都不是为自己学，是为别人学。为什么？因为你在别人心目中是个高手。你不得不花比别人更多时间去维护你在别人心目中高手的形象。你做到了，但那又有什么，别人认为你理所当然应该是个高手，那是你应该，他才不会管你比自己多花了多少时间和精力而来赞扬你刻苦，值得学习</p>
<p><span style="color: #a9a9a9;">2013-07-17 13:45:44</span></p>
<p>他想谭老教授凭这书也赚了不少钱吧。这也没什么不好，能够真正给别人带来好处的东西就是应该让人赚到钱，当然，如果你的东西真的有价值，你也不用愁赚不到钱。可现在的人一天到晚还是愁：哎呀物价涨了，啥时候才能赚大钱啊？这样想的时候你自己好好反省一下：你真的有多高的技术么？你真的有多高的智商么？你做的东西真的有那么大的价值么？</p>
<p><span style="color: #a9a9a9;">2013-07-17 13:47:50</span></p>
<p>这种可怕思想存在于现在大部分人的头脑中。别人就算真的好，那也不是真的好，因为我不懂，你跟我讲你水平高，没用，我不懂啊。除非你给我出具一份专家的鉴定书。所以，你比他好一点，他不会承认你，会嫉妒你。要是你比他好很多，他才会承认你，然后会很崇拜你。所以你要做，就应该比别人做得好很多。</p>
<p><span style="color: #a9a9a9;">2013-07-17 13:59:07</span></p>
<p>所以我们有时候也要理解老师，他们天天在讲台上讲，对他来说下面坐的有80%都是文盲――有文化的文盲，当然他们会很认真地记着笔记，甚至能预感到那些是重点，那些是考点。你以为老师喜欢这样的人吗？他觉得他在对着一群猪讲课，他觉得自己心中的东西比起书上来，那都是至理名言，可是，以他们的智商，他们无法理解</p>
<p><span style="color: #a9a9a9;">2013-07-18 00:51:17</span></p>
<p>所以有时候人的技术啊，知识啊也许并不是学出来的，是逼出来的。比如你去考软件设计师，本来至少有半年的时间来准备，可以那编译原理里面什么词法分析语法分析什么正则表达式啊看得你头都大了，这很正常，毕竟你是数学专业的就不是计算机专业的，是计算机专业的就不是数学专业的，甚至你跟这两个专业都不沾边。最后想算了还是放弃了，反正考试还有那么多内容，其它的学好点，一样能过。后来工作了，有一天，你BOSS跟你说：“小张啊，你从来没让我们失望过啊，最近很多程序员反应咱们那编译器不好用，你看干脆咱们自己开发个编译器算了。给你一个月时间够了吧，你可从来没让我们失望过啊。”他这么一说，尽管在那一个月中你每天都在心中骂他，可最后你自己都吓了一跳――居然还是把编译器给搞出来了。就这么一个月的时间逼一下，比那半年的效率都高得多。其实就算做不出来也没什么，做不出来很正常，做出来了你是牛人，这一个月要这么累死累活地工作是为什么？不是为了钱，是为了别人对你的信任和肯定。所以你骂完BOSS，偶尔回想起来也许你还是会感谢他的。</p>
<p><span style="color: #a9a9a9;">2013-07-18 00:52:32</span></p>
<p>对程序员来说，大部分快乐是从解决问题特别是独立解决问题中来的，不是从这个CASE有多大，奖金有多少中来的</p>
<p><span style="color: #a9a9a9;">2013-07-18 00:54:52</span></p>
<p>所以写程序有时候就是很有意思。比如你搞数学的，一就是一二就是二绝不可能出来三，但程序就不一样，方法自由，很多时候解决一个问题的方法直接反应出这个程序员的性格和思想</p>
<p><span style="color: #a9a9a9;">2013-07-18 10:36:59</span></p>
<p>艺术家和程序员有一个共同点就是对自己的作品宝贝得不得了，像自己的儿子似的，就算自己的儿子有一点瑕疵，但终归是自己的儿子，不到万不得已也不愿意轻易去修改它。这就是为什么在公司里面开会的结果是大家一致认为程序应该这样这样改，就是程序员不同意修改。</p>
<p><strong> 23 出差</strong></p>
<p><span style="color: #a9a9a9;">2013-07-22 10:54:37</span></p>
<p>对于“Sense”这个概念当然是老总的看法，你要是真听进去了，飘飘然觉得自己真的在写程序上有“Sense”那你就完了。你以为自己有“Sense”比别人聪明比别人学得快，于是你就放慢了学习的脚步。本来回家还要看三个小时的代码结果你去打了三个小时游戏，第二天去了公司当然就什么也不知道。这就是看三个小时代码和打三个小时游戏的区别，也是有没有“Sense”的区别。看了，你就有，没看，你就没有</p>
<p><strong> 24 BOSS Liu</strong></p>
<p><span style="color: #a9a9a9;">2013-07-22 10:58:02</span></p>
<p>所以程序员实际上就是一个幕后工作者。你程序写得好，客户用得很满意，他们会说：“哦，这个KIPACS软件不错，软件很好用。”不会说：“哦，这个绝影写的KIPACS软件很不错，绝影很厉害。”如果你程序写得不好，虽然他们不会说：“哦，绝影这人写的软件很糟糕。”但是你自己知道。很多时候，别人说你技术不行你都可以接受也可以理解，再牛B的程序员也会有自己不擅长的方面，但是如果别人说你做的东西不行，你往往会非常失望和难过，因为这不仅仅意味着你在某一方面的技术不行。</p>
<p><span style="color: #a9a9a9;">2013-07-22 11:07:25</span></p>
<p>所以很多时候面试官活得很累，不断提高自己设计高水平的面试题目当然是他们份内的事情，问题是一个好的面试官每一道题目都是他的劳动成果，就像你写的程序一样。可是那些回答问题的人根本就管这些，他们的唯一的目的就是把这题答出来，为了达到目的，往往不惜编造假话。有些回答一听就知道是错误的，或者是骗人的，可他们回答得怔怔有词，好像在他们眼中你这题就是专门为他们准备的或者你出这题没有一点技术含量，想到自己花了那么多心思来准备的题目被搞成这样，搞得你自己都开始怀疑自己的智商。</p>
<p><strong> 27 毕业</strong></p>
<p><span style="color: #a9a9a9;">2013-07-22 11:19:18</span></p>
<p>所以现在赚钱就是这样，什么技术啊，水平啊，味道啊，服务啊对人来说都是瞎扯淡，48块钱一杯的极品南山和98块钱一杯的极品南山有几个人能喝出50块钱的价格差？要命的是明明啥都没喝出来，还故作深沉地说：“看，这就是98和48的差别，这个余味太带酸……”什么才能赚钱？是噱头，是眼球。哪怕你死了，你要死得其所，让人杀人焚尸，成了大案子，最好上了新闻头条上了公安厅挂牌督办。知道了这一点，你就能够明白为什么现在“芙蓉姐姐”火爆得不得了，也狠赚了一笔钱</p>
<p><strong> 31 大CASE</strong></p>
<p><span style="color: #a9a9a9;">2013-07-22 12:39:21</span></p>
<p>所以有时候写程序就像放屁。放屁这个事情毕竟是件不雅的事，所以大部分人还是要偷偷地放。比如几十个人挤在公交车里，冷不丁谁偷偷放个屁，于是大家一边捂着鼻子一边互相指责：“你放的，你放的。”而真正放屁的人看到这情况，为掩人耳目，也充当起南郭先生，不断说：“谁放的？谁放的？”在这种情况下，屁很容易就放出来了。要是真正让你在大庭广众众目睽睽之下来放屁，怕就算你吃下两斤豌豆也放不出也不敢放出一个来，最要命的是肚子咕咕姑不断叫，就是不敢放</p>
<p><strong> 33 燕儿的工作</strong></p>
<p><span style="color: #a9a9a9;">2013-07-22 12:52:54</span></p>
<p>所以资本家确实有值得我们学习的地方：一、可以招个文员进来，应付公司打杂的琐情；二、本科刚毕业，工资不用开很高；三、可以和绝影安排在一个宿舍，节省了公司开销；四、最关键的，还让绝影觉得自己像欠了他好大一个人请，以后就得巴心巴干跟着他干。此乃三十六计中借刀杀人的最高境界――借了别人刀，把别人杀了，还让别人掉下的头给自己说声：谢谢。</p>
<p><strong> 37 动摇</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 06:47:47</span></p>
<p>早几年人们都觉得做技术的人很牛B，往往给人的印象是生活粗糙，不修边幅，做的又尽是些匪夷所思的事情。那毕竟是做的脑力劳动，中国几千年的思想下来就是“劳心者治人，劳力者治于人”，所以搞技术的莫名其妙有了优越感，越是有优越感，就越是不修边幅，鲁迅先生能做到把喝咖啡的时间都拿来工作，我还不能做到把梳头洗脸的时间拿来工作？ 所以封建社会的腐朽思想害死人：人人都认为搞技术好，于是人人都来搞技术，搞到最后技术实在太多了，反而如何把技术销售出去才成了摆在人们面前的最重要的问题，于是慢慢地搞销售才成了王道</p>
<p><strong> 38 张厂长的遥控器</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 14:24:04</span></p>
<p>，全世界对软件都有偏见，都觉得硬件好，念初中的时候，老师就说：什么是硬件？硬件就是看得见摸得着的东西。什么是软件？软件就是看不见摸不着的东西。人们的心态就是这样，往往更喜欢实实在在捏在手中的东西。早些年布雷顿森林体系的时候，你跟他说金属本位制，美元也是硬通货，直接跟黄金挂钩的，可人们还是偏偏喜欢黄金，眼看金融危机一来，赶紧把美元全部换成黄金，搞得美国也没了那么多金子，不得不放弃美元，美元也变成了货币符号，最后害了谁？还不是害了自己，自己辛辛苦苦挣再多钱，不过是货币符号而已。</p>
<p><strong> 39 真正的注册机</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 14:29:14</span></p>
<p>。现在单位里特别是国有单位，年轻人往往对年长的领导腹绯很多，而上了年纪的领导又对这些年轻人意见很大，归根到底，人老了，不求有功，但求无过，凡事畏畏缩缩，又觉得年轻人办事不牢靠，太激进太冒险。</p>
<p><strong> 40 精华和糟粕</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 14:37:14</span></p>
<p>所以说人跟人不同，狗和狗有异，同样一个妹妹走在学校里，西师的瞅也不瞅一眼，川大的说：“美女呀！”要是放到绝影他们学校，土匪多半会惊叫：“快看，女的！</p>
<p><span style="color: #a9a9a9;">2013-07-23 16:11:57</span></p>
<p>所以人活着累，自己技术菜，首先是被同行、老板看不起，挣的钱不多，还被老婆同学看不起。几个同行走到一起别人都兴高采烈讨论inline hook，你插一句：SSDT用什么函数获取？你自己都不好意思。 混了几年，好不容易技术高了点，也就是比上不足比下有余吧，顶级高手又不屑你，正如美女都不在街上逛一样，高手根本不混群。美女去哪里了？多半在私家车上。高手去哪里了？多半在写程序。即使这样，菜鸟也有有求于你的时候，菜鸟毕竟是菜鸟，出招都不按常理，有些问题问得你自己都吃紧，但是没办法，谁叫你是程序员呢？谁叫你技术比人家高点呢？你就得想办法帮别人解决。 再混几年，终于到顶级高手的地步了，突然发现群里没法混了。你想一个资格的大学教授可能去幼儿园教小朋友吗？即使你给他8000块钱一个月，人家还不一定愿意去教，好钢得用在刀刃上啊。于是自己来研究问题。先前那两个阶段，都还有很多东西可以参考，群上啊，网上啊，什么问题都能找到点资料。现在自己到了这个阶段，啥事都只能靠自己，费尽心机研究点成果出来又不敢独自偷偷享用。谁叫你是高手呢，你总得经常发表点研究成果吧。这是什么精神？这就是新时代的雷锋精神</p>
<p><strong> 41 网吧</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 16:18:46</span></p>
<p>还是《长江七号》里的小屁孩子说得对，做公司就要做大的，做什么不重要，关键是要做大，你一个小小的公司，不要说销售，就是贷款，都还要看银行脸色，做大了就不一样，银行是天天请客吃饭求你着贷款，要是做到VIP，据说银行那漂亮的公关部经理还可以单独跟你共进晚餐</p>
<p><span style="color: #a9a9a9;">2013-07-23 16:19:07</span></p>
<p>所以程序员要做就得做高手，做什么都无不重要，关键是要做成牛人。你一个小小的程序员，公司有你不多缺你不少，代码得由你来写，出了BUG还得由你负责，不服气，不服气滚一边去，反正你不愿意做有的是人来做。成牛人了就不一样，掌握了公司核心技术，体力活就分给下面的人去做？老板敢随便让你走吗？你一走随便再去一个公司或者马上自己创业搞对他都是极大的心理压力</p>
<p><span style="color: #a9a9a9;">2013-07-23 16:20:16</span></p>
<p>所以说公司对员工，就像谈恋爱。你没有百分之百的把握，就不要轻易给你女朋友承诺什么。你这个CASE没做完，就先不要承诺这个周末我带你去看电影。你永远要记住，承诺本身只能让她在当时那几分中里开心，履行自己的承诺才能让她开心一辈子，而且承诺的东西做不到，时间长了，她会连那几分钟的开心都没有，反而变成对你承诺的厌恶。男人最可怕的是没有钱，最可悲的是没有人信任你。</p>
<p><strong> 42 工资和房价</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 16:23:53</span></p>
<p>你区区一个内务府总管，五品官，我堂堂一个八部巡府，一品官，公堂之上你坐着我站着，不骂你骂谁。</p>
<p><span style="color: #a9a9a9;">2013-07-23 16:44:40</span></p>
<p>东西和技术都是给逼出来，你不向周总保证一周做完，你就永远不可能在一周内把一个月的工作做完。</p>
<p><strong> 43 背出来的面试题</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 16:47:11</span></p>
<p>资本家在各方面都是尽可能降低成本，这种思想放到产品上，就是偷工减料，放到人事上，就是能用大学生的绝不用研究生，能一个人做的绝不让两个人做。而一些国企又恰恰相反，大学生就能解决的一定要让研究生来解决，这叫“对工作重视 ”；一个人就能做的一定要让三四个人甚至一个小组一起上，这叫“人多力量大</p>
<p><span style="color: #a9a9a9;">2013-07-23 16:48:25</span></p>
<p>本来真的不懂，但把自己逼一下，又懂了一些，于是似懂非懂地去公司干，干一段时间下来又发现自己似乎真的懂了。</p>
<p><strong> 44 真正的大CASE</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 16:54:33</span></p>
<p>当美国经济不景气到谷底美国总统就想打仗，转移人们视线，正好这个时候萨达姆又冒了出来，你以为美国真是民主国家，你以为美国都是美国人们说了算，你以为布什不敢打你？不打你打谁？总之你伊拉克一个小国家，这个CASE总能摆平，你管我打你打得对不对，总之能完成CASE才是王道</p>
<p><span style="color: #a9a9a9;">2013-07-23 16:59:56</span></p>
<p>所以中国学校的教育就是死板，那数学从小学学到大学，从加减乘除学到导数微积分复变函数，按照学校的教法到底有多大用处，恐怕用得最多的也就是做生意算下几斤几两多少钱收多少找多少，其实数学的用处可大着呢。各个教材把自己的学问教得头头是道，就是不告诉你物理学里面的矢量就相当于数学里面的复数，就是不告诉你匀速圆周运动的轨迹可以用几何学来求解，归根结底，就是不告诉你这门学问到底有啥用处</p>
<p><span style="color: #a9a9a9;">2013-07-23 17:00:21</span></p>
<p>大环境如此，搞得写程序也如此，不管是学校里程序设计课程，还是社会上这样培训班那样电脑学校，都只管各自教各自的，学汇编就80x68，学C语言就TurboC，搞得最后大学C语言课程学完，连C语言能写Windows下窗口程序都不知道。最后写程序是教了，那教的是如何去写程序，根本不教你为什么要写程序，写程序能写些什么出来</p>
<p><span style="color: #a9a9a9;">2013-07-23 17:01:06</span></p>
<p>所以对人来说，什么思维最重要，当然是抽象思维。狗也会做梦，甚至还会说梦话，但是狗会抽象思维吗？你能让狗把一堆人民币想像成一堆骨头吗？不能，既然只有人这种高等动物才会抽象，那就要把它发挥到淋漓尽致</p>
<p><span style="color: #a9a9a9;">2013-07-23 17:03:41</span></p>
<p>在他看来，这世界上最幸福的事莫过于亲眼看着别人把自己的设想变成现实，你要明白，为什么T台上的模特虽然能够吸引众多的闪光灯和眼球，但是设计师总是最后出场，而且总是被这些美女模特们簇拥着出场。这就像修房子，虽然里面的一砖一瓦不知道凝结了多少工人的心血，但他们永远体会不到一座座高楼拔地而起的幸福和成就感，因为在他们眼中，只能看到一块砖或一片瓦，只有设计师，在他眼中看到的是整栋雄伟的大厦</p>
<p><span style="color: #a9a9a9;">2013-07-23 17:03:22</span></p>
<p>人呐，眼光放长远一些，看到的东西就更多一些，生活得也更有意义一些</p>
<p><strong> 45 向业主致敬</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 17:06:38</span></p>
<p>其实你要知道，什么是程序员，能为一两千块工资天天在公司加班加点回家还继续干到两三点甚至通宵的程序员，他们根本就不在乎挣多少钱。程序员，他们想的是什么？他们想的永远都是技术，他们崇尚的也永远是技术，哪怕我现在身上只有两毛前，只要有志同道合的人跟我聊技术，我一样敢跟他从C++聊到ASM，从API钩子聊到inline hook，从Ring3聊到Ring0。聊完了，今天晚上吃什么？吃什么并不重要，重要的是如何才能获取Kernel基址</p>
<p><strong> 48 非洲</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 22:26:26</span></p>
<p>所以人啊，特别是现在的年轻人，总觉得压力大，要买房，要买车，要结婚要生孩子，压力还不大？其实根本没必要去考虑这些，你考虑得再多，房价还是一样往上涨。就站在工薪阶层来说，一套房子几十万，你挣几十年钱一次性付清买套房子，压力倒是没有，不过住不了几年又要入土为安。现在有机会让你先把房子住上，等于多让你享几十年的福，还不赶紧去住上，现在房子少人多，你不去住多的是人去做，到时候人把房子住满了，你又得后悔，还考虑啥压力？房子标价五十万，或者贷款二十万，这都是死的，可人是活的，今年你只挣两万三万不代表你一辈子只挣两万三万。 所以技术也是如此，现在你觉得自己菜，到明年你技术又会比今年有所提高，虽然你自己不怎么感觉得到，但提高是实实在在的。不怕人没长进，就怕人没耐心，等不到明年就打退堂鼓。</p>
<p><strong> 49 技术经理</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 22:29:03</span></p>
<p>所以女人呐，天天到晚都在说烦烦烦。早上起来没赶上公车迟到了烦，跟同事相处不顺了烦，出门下雨了弄脏衣服烦，不下雨出太阳晒黑皮肤了烦，不下雨不出太阳刮点风吹乱了头发也烦，老公天天下班回家不出门觉得生活太平淡了烦，老公天天下班不回家出去玩怀疑他有外遇了也烦。</p>
<p><span style="color: #a9a9a9;">2013-07-23 22:30:21</span></p>
<p>理想就如同美女，生活就如同大便。</p>
<p><strong> 50 Bug Yang</strong></p>
<p><span style="color: #a9a9a9;">2013-07-25 07:23:11</span></p>
<p>现在的年轻人啊，就是这么自以为是。BUG？BUG在哪里？我没看到BUG就是没有BUG。牛人？牛人在哪里啊？我没看到牛人我就是世界上最牛的人。技术？这技术有什么用？我没看到这技术的用途它就是没用。抱着这种思想，于是一天只想着我要做什么，根本就不考虑我应该做什么。久而久之，胆子越来越大，大话越来越牛，技术反而越来越粗糙</p>
<p><strong> 53 Architect</strong></p>
<p><span style="color: #a9a9a9;">2013-07-26 06:36:56</span></p>
<p>可现在的资本家呀，啥事都只想向钱看齐，就像现在流行的说法，撞伤不如撞死，好多司机一见撞了人，干脆又把车倒回去撞死算了，最后结果呢？本来撞伤了人，属交通意外，承担民事责任就行了，现在搞成了故意伤害，还得追求刑事责任还附带民事赔偿。而资本家呢？自以为自己聪明，放弃后续维护以小博大赚了大头，结果坏了自己名声，本来人家还有个一两千万的大CASE，正考虑你上个CASE还做得不错，要不要把这个也给你算了，反正大家合作过，再合作起来也比较方面。可是到最后，才这么一点小小的问题你就不去给人家维护了，这下可好，到手的大CASE又飞了。</p>
<p><strong> 54 失败的EB</strong></p>
<p><span style="color: #a9a9a9;">2013-07-26 06:44:47</span></p>
<p>这就是中国的现实啊。在中国，做技术的人不能说不多，技术也不能说比国外差得十万八千里，可中国的软件还是发展不上去，中国做技术的人还始终还活在尴尬中。为什么？也许有一天，技术真正和商业利益分开了，中国的软件就有希望了，中国的程序员也就有希望了。</p>
<p><strong> 60 Nothing Impossible</strong></p>
<p><span style="color: #a9a9a9;">2013-07-28 11:30:40</span></p>
<p>谈到最后，你不愿意归不愿意，不去也得去，去多久还不是公司说了算，领导们总认为自己的决定是高瞻远瞩，站在台上挥一挥手，下面的群众便立刻斗志昂扬――那是农民起义的事了。纵观历史上，农民起义为什么总失败，或者就算不失败到最后也是被地主阶级利用，成为他们改朝换代的工具？历史书上说得很清楚了，是因为农民阶级没有先进理论作指导。 资本家当然自认为比地主阶级高级，事实在，资本家总是认为自己比谁都高级，地主阶级都能利用的事情，他们当然也不在话下。 问题是时代不同了，现在的人，特别是搞IT的，谁没有文化？一个比一个有文化。早几年没有社会经验，当然轻易被忽悠了，现在吃的亏多了，哪里还能轻易被忽悠的。赵本山的小品不正是这个过程的反应吗？ 这</p>
<p><strong> 61 校园</strong></p>
<p><span style="color: #a9a9a9;">2013-07-28 11:54:38</span></p>
<p>技术也是如此，以前天天用SDK，MFC写着程序，去网上看牛人们动辄就是RING0，RING0的，觉得这RING0是如此神奇，于是崇拜得要命，好像一但进入RING0自己便从菜鸟一跃而成牛人，也就是佛法上讲的天天坐在那里不吃不喝，有一天突然就“顿悟”了，成佛了。 等有一天要是你真正去搞驱动了，搞内核了，又觉得RING0也不过尔尔，不过就是多了些特权指令，换了些导入库而已。于是搞着RING0的人觉得RING0也不过瘾，没搞RING0的人又觉得RING0如此神奇，崇拜得要命。技术本身没有什么区别，区别在于人们对他的看法而已</p>
<p><strong> 68 外挂</strong></p>
<p><span style="color: #a9a9a9;">2013-07-28 17:08:20</span></p>
<p>现实生活中，哪个男人不是自作一副清高状，骂妓女，骂小姐，骂她们不要脸。但是骂完后呢？还不是跟妓女跟小姐玩得很Happy。再看看一些当官的，开起反腐倡廉的会来在上面说得头头是道，转身一下讲台手马上又伸了出来。他们对妓女有成见，很大程度上是对‘别人和妓女Happy’有成见，他们对腐败深恶痛绝，很大程度上是对“别人腐败”深恶痛绝。要是换成了自己，就有足够理由把这些成见抛开了。这叫啥？这就叫假正经。”</p>
<p><strong> 72 西班牙布局</strong></p>
<p><span style="color: #a9a9a9;">2013-07-29 08:06:28</span></p>
<p>这就比如现在搞软件开发，什么VC，VB，Delphi工具多得要死，就连VC都还分VC6,VC7.1,VC8好几个版本。新人一上来便问：“什么工具最好啊？”，“有中文版的吗？”，“最新版本是多少？”结果一个个上来就装上动辄几个G的恐龙般大小的IDE。要知道，这个时候，BOSS Liu还用着VC6呢。 在他们看来，学技术当然要学最先进的技术，用工具当然也得用最先进的工具。为什么？不知道，但是最新的就是最好的。可是抱着这样的思想，学技术就累得要死，技术那么多，而且在天天更新啊。开发环境也复杂得要死，你总不可能随时用个硬盘把VC8啊，SQL 2005啊这些庞然大物带在身边。所以一换台电脑，所有工作便无从下手了。</p>
<p><strong> 75 搞IT的民工</strong></p>
<p><span style="color: #a9a9a9;">2013-07-29 18:56:50</span></p>
<p>我们一直在追求技术，一直努力把自己的每个CASE做好，可以说这么多年了，我们都对得起我们做的每一个CASE，对得起我们的老板，对得起我们的客户。外人都觉得我们搞IT的很风光阿，每天坐在空调办公室里，在电脑面前打打字就能拿到那么多薪水，人家门卫整天日晒雨淋才那么一点钱。可那些人想过没有，对他们来说上班就是上班，下班就是下班，有时候加班，还拿加班费？我们呢？可以说我们根本没有下班。我们上班是上班，回到家还是写程序，有人给我们算加班吗？有人给我们拿加班费吗？</p>
<p><strong> 80 夭折</strong></p>
<p><span style="color: #a9a9a9;">2013-08-02 23:30:59</span></p>
<p>“是啊。以前我们就经常忙，经常熬夜。最开始，是对新知识，新技术的好奇，那时候我们疯狂地吸取知识。后来去公司了，我们还是经常加班经常熬夜，还不是为了能按时把CASE做下来，为了得到老板和同事，甚至用户的肯定。可现在呢？说实话我觉得我们现在的热情还不如一些菜鸟，像Bug Yang，他学习起来就比我们疯狂。工作上就更不用说了，什么肯定啊，赞扬啊，当然有，但那都是老板们停留在口头上的。有些话说了一次又一次，说实话，我都觉得我们对技术的追求和对CASE负责的心理是被资本家们利用了。所以，要我说，写程序就两种：要么纯粹就是爱好，不计任何回报，就像我们刚学写程序那样；要么就是给自己写程序，为自己挣钱，就像我们现在一样。要是一直给资本家写程序，写到最后，就两个字：痛苦！。</p>
<p><strong> 81 丁骨牛排</strong></p>
<p><span style="color: #a9a9a9;">2013-08-02 23:34:21</span></p>
<p>所以，在绝影看来，写程序永远不要停留在只跟代码打交道，只跟机器打交道的地步。这就像下棋。初学的时候怕丢人，还是偷偷买套软件回来下。你发现这机器真是太神奇了，你无论多么努力居然还是下不赢它。可机器毕竟是机器，你总是会慢慢进步的。有一天，你终于把它下赢了，于是你发现，从那以后，它居然再也下不过你。这时候，你就觉得，跟机器下棋实在是件很没意思的事情，下棋，还是得跟人下。</p>
<p><span style="color: #a9a9a9;">2013-08-02 23:34:29</span></p>
<p>写程序，还是得跟人打交道，只有跟人，你来我往，才是真正智慧上的交流，无论输赢，这才是最有意思的事情。</p>
<p><strong> 84 BOSS Liu和VB</strong></p>
<p><span style="color: #a9a9a9;">2013-08-02 23:54:06</span></p>
<p>‘疯狂的程序员’绝对不是靠狂妄和拼命的程序员，而是能够踏实，持续努力的程序员。等你真正做到了这两点，技术上去了，在写程序这个领域，能够限制你的只有你的想像力，到那个时候，你才算个‘疯狂的程序员’，这种程序员阿，是能令竞争对手无比恐惧的。”</p>
<p><strong> 86 装孙子</strong></p>
<p><span style="color: #a9a9a9;">2013-08-03 00:01:00</span></p>
<p>你知道燕儿为什么要跟我分手吗？她跟我说：‘你确实对我很好，也给了我很多，可是几年下来，我渐渐发现你给我的其实并不是我想要的。’我问她：‘那你想要什么呢？’她也答不上来，只是说：很多她想要的东西别人轻轻松松就能给她，在她生气的时候别人很容易就能哄她开心，别人说的话也都正和她意。可是为什么都只是别人，而不是绝影我呢？为什么我和她在一起，相互之间就总是指责，总是争吵呢？</p>
<p><span style="color: #a9a9a9;">2013-08-03 00:01:55</span></p>
<p>我告诉她。在很多时候，看起来我的确忽视了她，但我心里一直把她放在最重要的位置。我们在一起几年了，我和她都知道她也并不是个完美的人，我总是很明确地指出她的不足，她的缺点，因为我爱她，我要对她负责，我应该让她不断地变得完美。这些批评她的话让她听了，肯定会不舒服。可是别人不一样，她的那些朋友，只是普通朋友而已，他们不需要为她负什么责任，不需要担心她有没有自己喜欢的事业，不需要关心她的工作有没有前途。所以他们可以总是说她喜欢听的话，总是迁就她的缺点。这，也许就是为什么我总不能哄她开心的原因吧。她跟朋友在一起的时间不多，所以他们在一起的时候，总会做一些很开心很值得回味的事情。可是这又和我不一样，我和她，要面对的是每一天的生活，有时候单调而乏味的每一天。这和我们俩一个道理，以前我们在一起工作时，空余时间不是一起吃烧烤就是陪你喝酒。现在呢？我们总是用有限的在一起的时间，尽可能多地讨论问题，分享经验和心得。 “我又告诉她，也许我她的才是你真正需要的东西，只是因为你有了，所以你不觉得这有多么宝贵，等到有一天你失去这些的时候，也许你会后悔。</p>
<p><span style="color: #a9a9a9;">2013-08-03 00:02:19</span></p>
<p>，技术其实还是我们最需要的东西，以前我们没有技术，所以疯狂的追求它。现在呢？有了一点，它才显得不那么重要，如果这样放任下去，等到我们失去它的那一天，我们一定会后悔莫及的</p>
<p><span style="color: #808080;">多看笔记 来自多看阅读 for Kindle</span></p>
</blockquote>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2014/05/02/android_log_to_file/">
                Android开发:Log2File工具类
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-05-02
          
        </span>

        
          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <a href="../../categories/Android/">Android</a>

                
                
                  ， 
                

              
                <a href="../../categories/Android/Github/">Github</a>

                
                

              
            </span>
          
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/05/02/android_log_to_file/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/05/02/android_log_to_file/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <div style="color: #000000;">Log2File工具类是用于Android程序将Log记录到文件中(如sd卡)的工具,应用场景：</div><br><div style="color: #000000;"><br><br>1.  无法连接电脑进行调试（usb线被usbotg占用）<br>2.  Log不容易被抓取<br>3.  Bug出现很随机，不是必出现<br>4.  其他自己脑补<br><br>##  0.说明<br><br>这篇文章最早是在我的CSDN博客上面发布了:<a href="http://blog.csdn.net/grackergao/article/details/18322749" title="Log2File类的使用" target="_blank" rel="external">http://blog.csdn.net/grackergao/article/details/18322749</a> .现在讲他转移到了这里,代码的Github地址 :<a href="https://github.com/Gracker/Android-Utils/blob/master/Log2File.java" title="Log2File的github地址" target="_blank" rel="external">https://github.com/Gracker/Android-Utils/blob/master/Log2File.java</a><br><br>## 1.Log2File工具类源码<br><br><pre class="lang:java decode:true " title="Log2File工具类源码">import java.io.BufferedWriter;<br>import java.io.File;<br>import java.io.FileWriter;<br>import java.io.IOException;<br>import java.util.Date;<br><br>import android.content.Context;<br>import android.os.Environment;<br><br>public class Log2File<br>{<br>    private static boolean  logInit;<br>    private static BufferedWriter writer;<br><br>    private Log2File()<br>    {<br><br>    }<br><br>    /<strong><br>     <em> 初始化Log,创建log文件
     </em> @param ctx<br>     <em> @param fileName
     </em> @return<br>     */<br>    public static boolean init(Context ctx, String fileName)<br>    {<br>        if(!logInit)<br>        {<br>            String state = Environment.getExternalStorageState();<br>            if (Environment.MEDIA_MOUNTED.equals(state))<br>            {<br>                File sdDir = Environment.getExternalStorageDirectory();<br>                File logDir = new File(sdDir.getAbsolutePath() + “/log2file/“ +<br>                        ctx.getPackageName() + “/“);<br><br>                try {<br>                    if(!logDir.exists())<br>                    {<br>                        logDir.mkdirs();<br>                    }<br><br>                    File logFile = new File(logDir, fileName);<br>                    logFile.createNewFile();<br><br>                    writer = new BufferedWriter(new FileWriter(logFile, true));<br>                    logInit = true;<br>                } catch (IOException e) {<br>                    // TODO Auto-generated catch block<br>                    e.printStackTrace();<br>                }<br><br>            }<br><br>        }<br><br>        return logInit;<br>    }<br><br>    /</strong><br>     <em> 写一条log
     </em> @param msg<br>     <em>/<br>    public static void w(String msg)<br>    {<br>        if(logInit)<br>        {<br>            try {<br>                Date date = new Date();<br>                writer.write(“[“ + date.toLocaleString() + “] “ + msg);<br>                writer.newLine();<br>                writer.flush();<br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>            }<br>        }<br>    }<br><br>    /**
     </em> 关闭log<br>     */<br>    public static void close()<br>    {<br>        if(logInit)<br>        {<br>            try {<br>                writer.close();<br>                writer = null;<br><br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>                e.printStackTrace();<br>            }<br><br>            logInit = false;<br>        }<br>    }<br>}<br></pre><br><br>##  2.Log2File类的使用<br><br><div>这个工具类的使用比较简单</div><br><div>1.首先调用init进行初始化</div><br><div><br><pre class="lang:java decode:true " title="Log2File类的初始化">Log2File.init(context, fileName);</pre><br>2.调用w()进行输出<br><pre class="lang:java decode:true " title="调用w(String msg)函数进行输出">Log2File.w(String msg);</pre><br>3.使用完毕后，记得要关闭Log<br><pre class="lang:java decode:true  crayon-selected" title="关闭Log">Log2File.close();</pre><br></div><br></div>
          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2014/05/02/use-vps-and-vpn/">
                使用VPS搭建VPN+VPN路由设置+MacOS的VPN登录设置
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-05-02
          
        </span>

        
          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <a href="../../categories/Linux/">Linux</a>

                
                

              
            </span>
          
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/05/02/use-vps-and-vpn/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/05/02/use-vps-and-vpn/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h4 id="虚拟专用网（英语：Virtual_Private_Network，简称VPN），是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。虚拟私人网络的讯息透过公用的网络架构（例如：互联网）来传送内联网的网络讯息。它利用已加密的通道协议（Tunneling_Protocol）来达到保密、传送端认证、信息准确性等私人信息安全效果。这种技术可以用不安全的网络（例如：互联网）来传送可靠、安全的信息。需要注意的是，加密信息与否是可以控制的。没有加密的虚拟专用网信息依然有被窃取的危险。"><strong>虚拟专用网</strong>（<span style="\"color:" #0645ad;\"="">英语</span>：<a href="\"><strong>Virtual Private Network</strong></a>，简称<strong>VPN</strong>），是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。虚拟私人网络的讯息透过公用的网络架构（例如：<span style="\"color:" #0645ad;\"="">互联网</span>）来传送内联网的网络讯息。它利用已加密的<span style="\"color:" #0645ad;\"="">通道协议</span>（Tunneling Protocol）来达到保密、传送端认证、信息准确性等私人信息安全效果。这种技术可以用不安全的网络（例如：互联网）来传送可靠、安全的信息。需要注意的是，加密信息与否是可以控制的。没有加密的虚拟专用网信息依然有被窃取的危险。</h4><h1 id=""> </h1><h2 id="1-搭建VPN">1.搭建VPN</h2><p>使用这个VPS已经有一个月了，wordpress也折腾得差不多了，之前一直说要搭建一个VPN，由于种种原因没有去做，今天刚好有时间，就照着教程来了一遍，总算是搞定了，在Doit上划掉这个Task的时候，幸福感满满的。</p>
<p>搭建过程还是蛮无聊的，教程都写得很清楚，我之所以要搬运一下，是因为搭建+配置+登录，这一套组合拳下来，才能在<a href="\">facebook</a>、<a href="\">youtube</a>上刷网，但是各个教程都只是讲了一部分。我把基本操作搬运过来，然后再加上自己遇到的问题和解决方法，可以让看博客的人对着这篇一路下来就可以直接上网了。</p>
<h3 id="1-1_前提条件">1.1 前提条件</h3><p>首先，你要有一个VPS，国外的VPS。如果不懂可以查看<a href="\" title="\">如何搭建VPS</a>  我使用的是Linode在日本美帝的的服务器（如果你也想买Linode的VPS，购买的时候输入我的邀请code：a96df99ce34b5e0f76695558608c87fb2db5cc03 或者直接：<a href="\" title="\">https://www.linode.com/r=a96df99ce34b5e0f76695558608c87fb2db5cc03</a>）</p>
<p>其次，要懂一点Linux，一点点就可以了。</p>
<h3 id="1-2_搭建VPN">1.2 搭建VPN</h3><p>本人的Vps的操作系统用的是Ubuntu12.04 LTS ,所以下面的操作基于Ubuntu,悉知:</p>
<p><span style="\"color:" #323333;\"=""><strong>1、用root账户登陆服务器</strong></span><br><span style="\"color:" #323333;\"=""><strong>2、安装PPTPD</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"安装pptpd\"">apt-get install pptpd</pre>

<p><span style="\"color:" #323333;\"=""><strong>3、编辑pptpd.conf文件</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"编辑配置文件\"">vi /etc/pptpd.conf</pre>

<p><span style="\"color:" #323333;\"="">取消注释下面内容</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"需要去掉注释的部分\"">option /etc/ppp/pptpd-options
localip 192.168.0.1
remoteip 192.168.0.234-238,192.168.0.245</pre>

<p><span style="\"color:" #323333;\"="">这几句的意思是：当外部计算机通过pptp联接到vpn后所能拿到的ip地址范围和服务器的ip地址设置。</span><br><span style="\"color:" #323333;\"=""><strong>4、添加用于登陆的账户</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"编辑用户信息\"">vi /etc/ppp/chap-secrets</pre>

<p><span style="\"color:" #323333;\"="">格式如下：</span><br><span style="\"color:" #323333;\"="">用户名 pptpd \”密码\” *   比如:</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"账号密码例子\"">Gracker pptpd \"Ab1234567890\" *</pre>

<p>&nbsp;</p>
<p>密码需要用英文双引号星号(*)代表允许接入的ip可以是任意ip。这样，vpn就搭建好了，不过大多数人包括我在内，用国外服务器搭VPN都是为了偶尔能跳出局域网，所以我们还需要配置转发。</p>
<p><span style="\"color:" #323333;\"=""><strong>5、设置DNS解析，编辑pptpd-options文件</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"编辑转发\"">vi /etc/ppp/pptpd-options</pre>

<p><span style="\"color:" #323333;\"="">找到ms-dns，取消掉注释，并修改DNS地址，这里我推荐大家用Google DNS 8.8.8.8 和 8.8.4.4</span><br><span style="\"color:" #323333;\"=""><strong>6、开启转发</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"开启转发\"">vi /etc/sysctl.conf</pre>

<p><span style="\"color:" #323333;\"="">取消注释以下内容</span></p>
<pre class="\"lang:java" decode:true\"="">net.ipv4.ip_forward=1</pre>

<p><span style="\"color:" #323333;\"="">这句话意思是：打开内核IP转发,执行下面的命令让配置生效(感谢@扎啤 提醒)</span></p>
<pre class="\"lang:java" decode:true\"="">sysctl –p</pre>

<p><span style="\"color:" #323333;\"=""><strong>7、安装iptables并设置</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"安装iptables并设置\"">apt-get install iptables
iptables -t nat -I POSTROUTING -j MASQUERADE</pre>

<p><span style="\"color:" #323333;\"="">后面这句话作用是：立刻让LINUX支持NAT(platinum)</span></p>
<pre class="\"lang:java" decode:true\"="">iptables -I FORWARD -p tcp --syn -i ppp+ -j TCPMSS --set-mss 1356</pre>

<p><span style="\"color:" #323333;\"="">假如有部分网站访问不正确，则加入这句，将MTU值调小，这句将MTU值设置为1356。</span><br><span style="\"color:" #323333;\"="">　但是，只是这样，iptables 的规则会在下次重启时被清除，所以我们还需要把它保存下来，方法是使用 iptables-save 命令：   iptables-save &gt; /etc/iptables-rules然后修改 /etc/network/interfaces 文件，找到 eth0 那一节，在对 eth0 的设置最末尾加上下面这句：    pre-up iptables-restore &lt; /etc/iptables-rules这样当网卡 eth0 被加载的时候就会自动载入我们预先用 iptables-save 保存下的配置。</span><br><span style="\"color:" #323333;\"=""><strong>8、重新启动服务</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"重启pptp\"">/etc/init.d/pptpd restart</pre>

<p><span style="\"color:" #323333;\"=""><strong>9、到这一步,VPN就算搭建好了,登录账号密码之后就可以等脸书,推特等之前呵呵呵的网站了.不过这还不算完,登录过程中也有少许坑,下面将一一介绍.</strong></span></p>
<p>&nbsp;</p>
<h2 id="2-配置路由表">2.配置路由表</h2><p><span style="\"color:" #323333;\"="">VPN 是好用，挂上之后国外的网站是能访问了，但原来国内正常访问嘻唰唰的网站立刻变得慢吞吞了，怎么破？这是个问题。如果连了 VPN 没做任何设置的话，会导致所有网络都是通过 VPN 访问，缺点有二：1、VPN 的流量问题，严重的话还可能导致被 VPN 提供商封杀。2、嘻唰唰变慢吞吞的问题。我们上面搭建的VPN如果直接连接的话,就会导致国内的网站访问速度变慢,解决办法就是配置路由表.下面是<a href="\" title="\">维基百科中关于路由表的介绍</a>:</span></p>
<blockquote>
<p>在<a href="\" title="\">计算机网络</a>中，<strong>路由表</strong>（routing table）或称<strong>路由择域信息库</strong>（RIB, Routing Information Base），是一个存储在<a href="\" title="\">路由器</a>或者联网计算机中的电子表格（文件）或<a href="\" title="\">类数据库</a>。路由表存储着指向特定网络地址的路径（在有些情况下，还记录有路径的<a href="\" title="\">路由度量值</a>）。路由表中含有网络周边的<a href="\" title="\">拓扑</a>信息。路由表建立的主要目标是为了实现<a href="\" title="\">路由协议</a>和静态路由选择。</p>
<p>在现代路由器构造中，路由表不直接参与<a href="\" title="\">数据包</a>的传输，而是用于生成一个小型指向表，这个指向表仅仅包含由路由算法选择的数据包传输优先路径，这个表格通常为了优化硬件存储和查找而被压缩或提前编译。本文将忽略这个执行的详细情况而选择整个路径选择／传输信息子系统作为路由表来说明。</p>
</blockquote>
<p>具体步骤(Mac,Windows和Linux自行补脑):</p>
<p><span style="\"color:" #323333;\"="">1. 打开系统偏好设置—&gt;网络，增加 VPN 设置，VPN 类型选择PPTP，根据提示设置用户名密码等信息即可。</span></p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p><span style="\"color:" #323333;\"="">2. 下载 chnroutes.py，相关网址：<a href="https://code.google.com/p/chnroutes/downloads/list" target="_blank" rel="external">https://code.google.com/p/chnroutes/downloads/list</a></span></p>
<p><span style="\"color:" #323333;\"="">3. 打开终端进入下载文件的目录，执行：python chnroutes.py -p mac，该目录下会生成两个文件「ip-up」和「ip-down」。</span></p>
<p><span style="\"color:" #323333;\"="">4. 把这两个文件复制到 /etc/ppp 下，然后进入该目录执行：sudo chmod a+x ip-up ip-down</span></p>
<p><span style="\"color:" #323333;\"="">测试一下，在终端执行：netstat -nr，检查路由表的输出信息。连接 VPN，然后再次执行：netstat -nr，你会发现路由表已经发生了变化。这时再去访问国内的网站，你发现他们又变得嘻唰唰了，同时还能访问 Twitter 和 Facebook！</span></p>
<p>&nbsp;</p>
<h2 id="3-MacOs的VPN登录设置">3.MacOs的VPN登录设置</h2><h3 id="1-调整vpn网络顺序">1.调整vpn网络顺序</h3><p>Mac上登录vpn很简单,<span style="\"color:" #323333;\"="">打开系统偏好设置—&gt;网络，增加 VPN 设置，VPN 类型选择PPTP，根据提示设置用户名密码等信息即可.但是这样还不能登录Facebook之类的网站的话,就还得把VPN这个网络放到默认网络前面,才能正常登录(<span style="\"color:" #ff0000;\"="">注意VPN的位置</span>):</span></p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>具体步骤:</p>
<p>1.</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>2.</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>&nbsp;</p>
<p>大功告成.</p>
<h3 id="2-给小伙伴共享劳动成果">2.给小伙伴共享劳动成果</h3><p>vpn搭建好了之后,默认我们只设置了一个用户,在/etc/ppp/chap-secrets中,如果有其他小伙伴也想使用的话,按照前面添加用户的方法,在下一行添加即可.由于Linode的vps套餐送的流量很多,一个人通常是用不完的.Linode最近服务升级,官网变得小清新了之外,套餐也变得很给力:</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>Update at : 2014-7-24</p>
<p>Linode有了新的套餐:如下</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>参考:</p>
<p>1.<a href="\" title="\">http://www.storyday.com/html/y2011/2843_vpn_route_tables.html</a></p>
<p>2.<a href="\" title="\">http://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E7%A7%81%E4%BA%BA%E7%B6%B2%E8%B7%AF</a></p>
<p>3.<a href="\" title="\">http://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E8%A1%A8</a></p>
<p>4.<a href="\" title="\">http://www.cnblogs.com/Heisenbug/p/3442522.html</a></p>
<p>5.<a href="\" title="\">http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;amp;mid=200062863&amp;amp;idx=1&amp;amp;sn=ecd28282f9d500db4fdb8df39f3726b2&amp;amp;scene=1#rd</a></p>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2014/05/02/gracker-booklist/">
                Gracker的书单(持续更新,欢迎推荐书籍)(10月30更新)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-05-01
          
        </span>

        
          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <a href="../../categories/读书笔记/">读书笔记</a>

                
                

              
            </span>
          
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/05/02/gracker-booklist/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/05/02/gracker-booklist/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <address>读书交流群：78985869   欢迎加入一起分享读书的乐趣。</address>

<address>Github: <a href="\" title="\">https://github.com/Gracker/Gracker-book-list</a></address>

<address> </address>

<h4 id="自从买了KindlePW,刷了多看之后,读了不少书,也涨了很多见识,这里把我读过的书记录在这里,分享的同时也作为一个记录,以此勉励我-也希望能找到志同道合的小伙伴一起读书-">自从买了KindlePW,刷了多看之后,读了不少书,也涨了很多见识,这里把我读过的书记录在这里,分享的同时也作为一个记录,以此勉励我.也希望能找到志同道合的小伙伴一起读书.</h4><h3 id="读过的书(非技术相关):">读过的书(非技术相关):</h3><ol>
<li>疯狂的程序员     by绝影</li>
<li>MacTalk 人生元编程  by 池建强</li>
<li>黑客与画家  by<a href="\">Paul Graham</a><span style="\"color:" #111111;\"=""> </span></li>
<li>创业的乐趣  by Jason Yin</li>
<li>天行健    by燕垒生</li>
<li>三体1:地球往事    by<span style="\"color:" #212121;\"="">刘慈欣</span></li>
<li>三体2:黑暗森林  by<span style="\"color:" #212121;\"="">刘慈欣</span></li>
<li>三体3:死神永生  by<span style="\"color:" #212121;\"="">刘慈欣</span></li>
<li>Doom启示录  by<a href="\">大卫·卡什诺</a><span style="\"color:" #111111;\"=""> </span></li>
<li>明朝那些事儿(1-7)  by当年明月</li>
<li>南明那些事儿   by<a href="\">洪兵</a><span style="\"color:" #111111;\"=""> </span></li>
<li>晚明兵变  by李文志</li>
<li>中国的天空   by<a href="\">周斌</a><span style="\"color:" #111111;\"=""> / </span><a href="\">邹新奇</a><span style="\"color:" #111111;\"=""> </span></li>
<li>抗日战争的细节  by<a href="\">魏风华</a><span style="\"color:" #111111;\"=""> </span></li>
<li>重说中国近代史   by<a href="\">张鸣</a><span style="\"color:" #111111;\"=""> </span></li>
<li>太平天国十四年   by <a href="\">盛巽昌</a><span style="\"color:" #111111;\"=""> </span></li>
<li>极简欧洲史   by<a href="\">约翰·赫斯特（John Hirst</a>)</li>
<li>日本简史  by<a href="\">王新生</a><span style="\"color:" #111111;\"=""> </span></li>
<li><span style="\"color:" #111111;\"="">图解不一样的日本史  by<a href="\">陈秉霖</a> </span></li>
<li>情报日本  by<a href="\">胡平</a><span style="\"color:" #111111;\"=""> </span></li>
<li>美国的耻辱:珍珠港事件内幕  by</li>
<li>一九八四   by<a href="\">乔治·奥威尔</a><span style="\"color:" #111111;\"=""> </span></li>
<li>那卡的曙光   by<a href="\">特威西格耶•杰克逊•卡古瑞</a><span style="\"color:" #111111;\"=""> / </span><a href="\">苏珊•林维尔</a><span style="\"color:" #111111;\"=""> </span></li>
<li>冰与火之歌   by <a href="\">乔治·R. R. 马丁</a><span style="\"color:" #111111;\"=""> </span></li>
<li>羊毛战记  by <a href="\">休·豪伊</a><span style="\"color:" #111111;\"=""> </span></li>
<li>我的奋斗   by <a href="\">罗永浩</a><span style="\"color:" #111111;\"="">  &amp;&amp; <a href="\">希特勒</a> </span></li>
<li>北京法源寺 by 李敖</li>
<li><span style="\"color:" #111111;\"="">唯心有物王阳明正传  by<a href="\">赵家三郎</a> </span></li>
<li>黑鹰坠落  by <a href="\">马克·博登</a><span style="\"color:" #111111;\"=""> </span></li>
<li>爱是有故事的旅行   by 汤佳</li>
<li>达芬奇密码  by<a href="\">[美] 丹·布朗</a></li>
<li>肖申克的救赎  by<a href="\">斯蒂芬·金</a><span style="\"color:" #111111;\"=""> </span></li>
<li>幻影书   by<a href="\">保罗·奥斯特</a><span style="\"color:" #111111;\"=""> </span></li>
<li>Facebook效应   by<a href="\">大卫·柯克帕特里克</a><span style="\"color:" #111111;\"=""> </span></li>
<li>掘金黑客  by<a href="\">凯文·保尔森</a><span style="\"color:" #111111;\"=""> </span></li>
<li>黑客   by<a href="\">Steven Levy</a><span style="\"color:" #111111;\"=""> </span></li>
<li>爆发    by<a href="\">艾伯特-拉斯洛·巴拉巴西</a><span style="\"color:" #111111;\"=""> </span></li>
<li>打造Facebook    by<a href="\">王淮</a><span style="\"color:" #111111;\"=""> / </span><a href="\">祝文让</a><span style="\"color:" #111111;\"=""> </span></li>
<li>陆犯焉识  by <a href="\">严歌苓</a><span style="\"color:" #111111;\"=""> </span></li>
<li>冰与火之歌(1-5) by  <a href="\">[美]乔治·R.R.马丁</a><span style="\"color:" #111111;\"=""> </span></li>
<li>帝国最后的荣耀-大明1592抗日援朝  by  <a href="\">马伯庸</a> / <a href="\">汗青</a></li>
<li>赌球记 by   <a href="\">孔二狗</a></li>
<li>为奴十二年 by  <a href="\">[美]所罗门·诺瑟普</a></li>
<li>了不起的盖茨比 by  <a href="\">[美]菲茨杰拉德</a></li>
<li>天行健 by <a href="\">燕垒生</a></li>
<li>狼图腾 by <a href="\">姜戎</a></li>
<li>追风筝的人 by <a href="\">[美] 卡勒德·胡赛尼</a></li>
<li><a href="\" title="\">1988：我想和这个世界谈谈</a>  by <a href="\">韩寒</a></li>
<li><a href="\" title="\">杜拉拉升职记</a> by <a href="\">李可</a></li>
<li><a href="\" title="\">三重门</a> by <a href="\">韩寒</a></li>
<li>to be continue……</li>
</ol>
<h3 id="读过的书(技术和工作相关)">读过的书(技术和工作相关)</h3><ol>
<li>番茄工作法图解   by<a href="\">Staffan Nöteberg</a><span style="\"color:" #111111;\"=""> </span></li>
<li>卓越程序员密码   by <a href="\">Ka Wai Cheung</a><span style="\"color:" #111111;\"=""> </span></li>
<li>程序员,你伤不起  by <a href="\">吉日嘎拉</a><span style="\"color:" #111111;\"=""> </span></li>
<li>若干Java书籍</li>
<li>若干C++书籍</li>
<li>若干Android书籍</li>
<li>若干杂七杂八的技术书籍</li>
</ol>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2014/05/01/about_random/">
                关于自由
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-05-01
          
        </span>

        
          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <a href="../../categories/生活感悟/">生活感悟</a>

                
                

              
            </span>
          
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/05/01/about_random/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/05/01/about_random/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <p><strong>当Youtube被封的时候，我淡定，因为我们有优酷，而且Youtube的英文视频我也看不懂；</strong></p>
<p><strong>当Facebook被封的时候，我淡定，因为我们有人人，而且我也没有多少国外朋友；</strong></p>
<p><strong>当Google被封的时候，我淡定，因为我们有百度，而且百度更懂中文；</strong></p>
<p><strong>当Twiiter被封的时候，我淡定，因为我们有微博，而且Twitter远没有微博功能强大；</strong></p>
<p><strong>当Dropbox被封的时候，我有点不淡定了，因为国内同类服务做的像坨屎；</strong></p>
<p><strong>当Gmail被封的时候，我有点不淡定了，因为Gmail几乎没有垃圾广告；</strong></p>
<p><strong>当Google Docs被封的时候，我有点不淡定了，因为国内没有在线协作平台；</strong></p>
<p><strong>当Google Reader被封的时候，我有点不淡定了，因为国内RSS订阅整合和分享功能远没有Reader优秀；</strong></p>
<p><strong>这时候，我突然想起来Youtube有即时翻译功能，而且里面每天都会产生大量优秀视频；</strong></p>
<p><strong>这时候，我突然想起来Facebook有各种有趣应用，甚至可以整合到Outlook里面；</strong></p>
<p><strong>这时候，我突然想起来Google有scholar search，还有各种个性化的服务；</strong></p>
<p><strong>这时候，我突然想起来Twiiter各种神奇，甚至可以用来估算龙卷风带来的损失；</strong></p>
<p><strong>这时候，我突然想起来Wordpress可以做简易的网站，可以很轻松的定制个性化服务。</strong></p>
<p><strong>于是，我想到墙外看看，却发现——我得不到他们 ，我自由获取信息的权利被默默的剥夺了。</strong></p>
<p><strong>更加恐怖的是： 全世界都用Twitter，Facebook，只有我们用微博。</strong></p>
<p><strong>我们和他们生活在不同的维度，我们使用的永远是劣质的山寨品，甚至还要承担比正品更高的价格。当我们断绝了与外界的联系，当我们只能获得经过别人筛选过的信息，无知者无畏将是我们唯一的宿命。</strong></p>
<p><strong>比起在各种“异端邪说”中艰难寻找真理，对无知的恐惧更让我胆战心惊。</strong></p>
<p><strong>给所有不翻墙的朋友：</strong></p>
<p><strong>你可以说我在墙内得到的信息足够了，翻墙出去完全没有必要，但请记得，终究有一天，你想看看外面的世界，但却发现，由于当初的漠不关心，我们现在已经生活在信息的牢笼中，再也出不去了。</strong></p>
<p><a href="http://weibo.com/p/1001603704341168019296" title="http://weibo.com/p/1001603704341168019296" target="_blank" rel="external">http://weibo.com/p/1001603704341168019296</a></p>
<p><span style="color: #ff6600;">本文非原创,系转载,如侵犯版权,请与我联系,我会迅速删除.</span></p>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2014/04/13/beautiful-ios-app-ios5coins/">
                5coins–轻松记账
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-04-12
          
        </span>

        
          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <a href="../../categories/Android/">Android</a>

                
                

              
            </span>
          
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/04/13/beautiful-ios-app-ios5coins/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/04/13/beautiful-ios-app-ios5coins/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <p><a href="\"><img src="\" alt="\"></a></p>
<p>记账,是个大工程.</p>
<p>知乎出过一个周刊,叫从存钱罐到财务自由,很多人提到理财的时候,都提到了要记账.可见记账的重要性. 我也前前后后用过好几个记账软件,手机和电脑客户端都有过尝试,不过最终还是没有坚持下来.说来惭愧……毅力是一方面,记账软件的易用性也是一方面,前几次记账觉得这么多功能,狂拽酷炫屌炸天啊.用久了就觉得,老子记个帐而已,何必搞得这么麻烦,花了多少钱,再加个备注,就完事了. 什么地点啊,人啊,消费类型啊,其实没啥必要啊!</p>
<p>今天给大家介绍的这个软件,就是一款很简洁的记账软件(ios) : 5coins - 轻松记账(<a href="\">https://itunes.apple.com/cn/app/5coins-spend-everyday/id572886919?mt=8</a>).现在这款软件已经占据我手机Dock栏一席之地.</p>
<p>下面来看看截图:</p>
<p>1.加载界面:</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>2.主界面:应用一进去后,就可以看到这个界面,这个界面主要显示了今天的消费情况.上面两个按钮:左边那个点击可以查看消费统计,右边那个点击是增加一笔支出. 下面的三个按钮分别是:年度支出百分比,今天消费详单,云备份.</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>3.记账界面:记账界面突出一个简单,没有复杂的条条框框,输入消费金额即可,备注是可选的,我一般简单描述一下消费项目.</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>4.消费统计界面:可以查看 天,周,月的消费情况.</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>5.消费详单</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>&nbsp;</p>
<p>6.云同步界面,使用icloud同步,简单方便.</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>隐藏功能:左右摇晃手机可以跳转到当前日.</p>
<p>应用很简单,用起来也很舒畅,最重要的是,它让记账不再那么麻烦,这样记账的抵触心理也会小很多.那些想记账缺坚持不下来的同学们可以试试这款软件(PS:收费软件,12大洋,但是绝对值得)</p>
<p>记账归记账,每每看到每天的消费额,你就可以知道你的钱都去哪儿了.也可以针对性地进行分析. 每当你控制不住自己的购物欲或者逛taobao逛得欲罢不能的时候,打开这款应用,看看你最近的消费,绝对能帮你省不少钱. 这也是我介绍这款应用的原因:好用,实用.美.</p>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2014/04/12/analysishashmap/">
                HashMap源码分析
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-04-11
          
        </span>

        
          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <a href="../../categories/Java/">Java</a>

                
                

              
            </span>
          
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/04/12/analysishashmap/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/04/12/analysishashmap/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <div style="text-align: left">          链表和数组可以按照人们意愿排列元素的次序，但是，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，直到找到为止。如果集合中元素很多，将会消耗很多时间。有一种数据结构可以快速查找所需要查找的对象，这个就是哈希表（hash table）。</div><br><div>          HashMap是基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</div><br><div>          1.HashMap的数据结构：</div><br><div><a href="http://www.grackertalk.com/wp-content/uploads/2014/04/hm01.png" target="_blank" rel="external"><img src="http://www.grackertalk.com/wp-content/uploads/2014/04/hm01.png" alt="hm01"></a></div><br><div>           HashMap使用数组和链表来共同组成的。可以看出底层是一个数组，而数组的每个元素都是一个链表头。</div><br><div></div><br><div><br><pre class="theme:eclipse lang:java decode:true">    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {<br>        final K key;<br>        V value;<br>        Entry&lt;K,V&gt; next;<br>        int hash;<br>        …<br>     }</pre><br><div align="left">Entry是HashMap中的一个内部静态类，包级私有，实现了Map中的接口Entey&lt;K,V&gt;。可以看出来它内部含有一个指向下一个元素的指针。</div><br><div align="left"><span style="font-family: Consolas"> </span></div><br><div>          2.构造函数</div><br><div>          HashMap的构造函数有四个：</div><br><div>HashMap()</div><br><div>          构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。</div><br><div>HashMap(int initialCapacity)</div><br><div>          构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</div><br><div>HashMap(int initialCapacity, float loadFactor)</div><br><div>          构造一个带指定初始容量和加载因子的空 HashMap。</div><br><div>HashMap(Map&lt;? extends K,? extends V&gt; m)</div><br><div>          构造一个映射关系与指定 Map 相同的新 HashMap。</div><br><div>实际上就两种，一个是指定初始容量和加载因子，一个是用一个给定的映射关系生成一个新的HashMap。先来说第一个。</div><br><div><br><pre class="theme:eclipse lang:java decode:true">    /<strong><br>     <em> Constructs an empty &lt;tt&gt;HashMap &lt;/tt&gt; with the specified initial
     </em> capacity and load factor.<br>     <em>
     </em> @param  initialCapacity the initial capacity<br>     <em> @param  loadFactor      the load factor
     </em> @throws IllegalArgumentException if the initial capacity is negative<br>     <em>         or the load factor is nonpositive
     </em>/<br>    public HashMap( int initialCapacity, float loadFactor) {<br>        if (initialCapacity &lt; 0)<br>            throw new IllegalArgumentException( “Illegal initial capacity: “ +<br>                                               initialCapacity);<br>        if (initialCapacity &gt; MAXIMUM_CAPACITY)<br>            initialCapacity = MAXIMUM_CAPACITY;<br>        if (loadFactor &lt;= 0 || Float. isNaN(loadFactor))<br>            throw new IllegalArgumentException( “Illegal load factor: “ +<br>                                               loadFactor);<br><br>        // Find a power of 2 &gt;= initialCapacity<br>        int capacity = 1;<br>        while (capacity &lt; initialCapacity)<br>            capacity &lt;&lt;= 1;<br><br>        this.loadFactor = loadFactor;<br>        threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);<br>        table = new Entry[capacity];<br>        useAltHashing = sun.misc.VM. isBooted() &amp;&amp;<br>                (capacity &gt;= Holder. ALTERNATIVE_HASHING_THRESHOLD);<br>        init();<br>    }</strong></pre><br>&nbsp;<br><div><br><div align="left">参数很简单，初始容量，和加载因子。初始容量定义了初识数组的大小，加载因子和初始容量的乘积确定了一个阈值。阈值最大是(1&lt;&lt;30) + 1。初始容量一定是2的N次方，而且刚刚比要设置的值大。默认初始容量是16，默认加载因子是0.75。当表中的元素数量大于等于阈值时，数组的容量会翻倍，并重新插入元素到新的数组中，所以HashMap不保证顺序恒久不变。</div><br><div align="left">当输入的加载因子小于零或者不是浮点数时会抛出异常（IllegalArgumentException）。</div><br><div align="left"></div><br><div align="left"><br><div>3.put操作</div><br><div><br><pre class="theme:eclipse lang:java decode:true ">    /<br>     <em> Associates the specified value with the specified key in this map.
     </em> If the map previously contained a mapping for the key, the old<br>     <em> value is replaced.
     </em><br>     <em> @param key key with which the specified value is to be associated
     </em> @param value value to be associated with the specified key<br>     <em> @return the previous value associated with &lt;tt&gt;key &lt;/tt&gt;, or
     </em>         &lt;tt&gt;null &lt;/tt&gt; if there was no mapping for &lt;tt&gt; key&lt;/tt&gt; .<br>     <em>         (A &lt;tt&gt;null &lt;/tt&gt; return can also indicate that the map
     </em>         previously associated &lt;tt&gt;null &lt;/tt&gt; with &lt;tt&gt; key&lt;/tt&gt; .)<br>     <em>/<br>    public V put(K key, V value) {<br>        if (key == null)<br>            return putForNullKey(value);<br>        int hash = hash(key);<br>        int i = indexFor(hash, table .length );<br>        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e. next) {<br>            Object k;<br>            if (e. hash == hash &amp;&amp; ((k = e. key) == key || key.equals(k))) {<br>                V oldValue = e. value;<br>                e. value = value;<br>                e.recordAccess( this);<br>                return oldValue;<br>            }<br>        }<br><br>        modCount++;<br>        addEntry(hash, key, value, i);<br>        return null;<br>    }</em></pre><br>&nbsp;<br><div>由于HashMap只是key值为null，所以首先要判断key值是不是为null，是则进行特殊处理。</div><br></div><br></div><br></div><br></div><br>&nbsp;<br><pre class="theme:eclipse lang:java decode:true ">    /**
      Offloaded version of put for null keys<br>     <em>/<br>    private V putForNullKey(V value) {<br>        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e. next) {<br>            if (e. key == null) {<br>                V oldValue = e. value;<br>                e. value = value;<br>                e.recordAccess( this);<br>                return oldValue;<br>            }<br>        }<br>        modCount++;<br>        addEntry(0, null, value, 0);<br>        return null;<br>    }</em></pre><br>&nbsp;<br><div><br><div align="left">可以看出key值为null则会插入到数组的第一个位置。如果第一个位置存在，则替代，不存在则添加一个新的。稍后会看到addEntry函数。</div><br><div align="left">PS：考虑一个问题，key值为null会插入到table[0]，那为什么还要遍历整个链表呢？</div><br><div align="left">回到put函数中。在判断key不为null后，会求key的hash值，并通过indexFor函数找出这个key应该存在table中的位置。</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Returns index for hash code h.<br>     <em>/<br>    static int indexFor (int h, int length) {<br>        return h &amp; (length-1);<br>    }</em></pre><br>&nbsp;<br><div><br><div align="left">indexFor函数很简短，但是却实现的很巧妙。一般来说我们把一个数映射到一个固定的长度会用取余（%）运算，也就是h % length，但里巧妙地运用了table.length的特性。还记得前面说了数组的容量都是很特殊的数，是2的N次方。用二进制表示也就是一个1后面N个0，（length-1）就是N个1了。这里直接用与运算，运算速度快，效率高。但是这是是利用了length的特殊性，如果length不是2的N次方的话可能会增加冲突。</div><br><div align="left">前面的问题在这里就有答案了。因为indexFor函数返回值的范围是0到（length-1），所以可能会有key值不是null的Entry存到table[0]中，所以前面还是需要遍历链表的。</div><br><div align="left">得到key值对应在table中的位置，就可以对链表进行遍历，如果存在该key则，替换value，并把旧的value返回，modCount++代表操作数加1。这个属性用于Fail-Fast机制，后面讲到。如果遍历链表后发现key不存在，则要插入一个新的Entry到链表中。这时就会调用addEntry函数。</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Adds a new entry with the specified key, value and hash code to<br>     <em> the specified bucket.  It is the responsibility of this
     </em> method to resize the table if appropriate.<br>     <em>
     </em> Subclass overrides this to alter the behavior of put method.<br>     <em>/<br>    void addEntry (int hash, K key, V value, int bucketIndex) {<br>        if ((size &gt;= threshold) &amp;&amp; ( null != table[bucketIndex])) {<br>            resize(2 </em> table. length);<br>            hash = ( null != key) ? hash(key) : 0;<br>            bucketIndex = indexFor(hash, table.length);<br>        }<br><br>        createEntry(hash, key, value, bucketIndex);<br>    }</pre><br>&nbsp;<br><div>这个函数有四个参数，第一个是key的hash值，第二个第三个分别是key和value，最后一个是这个key在table中的位置，也就是indexFor(hash(key), table.length-1)。首先会判断size（当前表中的元素个数）是不是大于或等于阈值。并且判断数组这个位置是不是空。如果条件满足则要resize(2 <em> table. length)，等下我们来看这个操作。超过阈值要resize是为了减少冲突，提高访问效率。判断当前位置不是空时才resize是为了尽可能减少resize次数，因为这个位置是空，放一个元素在这也没有冲突，所以不影响效率，就先不进行resize了。</em></div><br><div><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Rehashes the contents of this map into a new array with a<br>     <em> larger capacity.  This method is called automatically when the
     </em> number of keys in this map reaches its threshold.<br>     <em>
     </em> If current capacity is MAXIMUM_CAPACITY, this method does not<br>     <em> resize the map, but sets threshold to Integer.MAX_VALUE.
     </em> This has the effect of preventing future calls.<br>     <em>
     </em> @param newCapacity the new capacity, MUST be a power of two;<br>     <em>        must be greater than current capacity unless current
     </em>        capacity is MAXIMUM_CAPACITY (in which case value<br>     <em>        is irrelevant).
     </em>/<br>    void resize(int newCapacity) {<br>        Entry[] oldTable = table;<br>        int oldCapacity = oldTable. length;<br>        if (oldCapacity == MAXIMUM_CAPACITY) {<br>            threshold = Integer. MAX_VALUE;<br>            return;<br>        }<br><br>        Entry[] newTable = new Entry[newCapacity];<br>        boolean oldAltHashing = useAltHashing;<br>        useAltHashing |= sun.misc.VM. isBooted() &amp;&amp;<br>                (newCapacity &gt;= Holder. ALTERNATIVE_HASHING_THRESHOLD);<br>        boolean rehash = oldAltHashing ^ useAltHashing;<br>        transfer(newTable, rehash);<br>        table = newTable;<br>        threshold = (int)Math.min(newCapacity <em> loadFactor , MAXIMUM_CAPACITY + 1);<br>    }</em></pre><br>&nbsp;<br><div><br><div align="left">resize操作先要判断当前table的长度是不是已经等于最大容量（1&lt;&lt;30）了，如果是则把阈值调到整数的最大值（(1&lt;&lt;31) - 1），就没有再拓展table的必要了。如果没有到达最大容量，就要生成一个新的空数组，长度是原来的两倍。这时候可能要问了，如果oldTable. length不等于MAXIMUM_CAPACITY，但是（2  oldTable. length）也就是newCapacity大于MAXIMUM_CAPACITY怎么办？这个是不可能的，因为数组长度是2的N次方，而MAXIMUM_CAPACITY = 1&lt;&lt;30。</div><br><div align="left">生成新的数组后要执行transfer函数。</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true">    /<strong><br>     <em> Transfers all entries from current table to newTable.
     </em>/<br>    void transfer(Entry[] newTable, boolean rehash) {<br>        int newCapacity = newTable. length;<br>        for (Entry&lt;K,V&gt; e : table) {<br>            while( null != e) {<br>                Entry&lt;K,V&gt; next = e. next;<br>                if ( rehash) {<br>                    e. hash = null == e. key ? 0 : hash(e. key);<br>                }<br>                int i = indexFor(e.hash, newCapacity);<br>                e. next = newTable[i];<br>                newTable[i] = e;<br>                e = next;<br>            }<br>        }<br>    }</strong></pre><br>&nbsp;<br><div><br><div align="left">这个函数要做的就是把原来table中的值挨个拿出来插到新数组中，由于数组长度发生了改变，所以元素的位置肯定发生变化，所以HashMap不能保证该顺序恒久不变。回到resize函数，这时新的数组已经生成了，只需要替换原来数组就好了。并且要更新一下阈值。可以看出来resize是个比较消耗资源的函数，所以能减少resize的次数就尽量减少。</div><br><div align="left">回到函数addEntry 中，判断完是不是需要resize后就需要创建一个新的Entry了。</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true ">    /<br>     <em> Like addEntry except that this version is used when creating entries
     </em> as part of Map construction or “pseudo -construction” (cloning,<br>     <em> deserialization).  This version needn’t worry about resizing the table.
     </em><br>     <em> Subclass overrides this to alter the behavior of HashMap(Map),
     </em> clone, and readObject.<br>     <em>/<br>    void createEntry( int hash, K key, V value, int bucketIndex) {<br>        Entry&lt;K,V&gt; e = table[bucketIndex];<br>        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);<br>        size++;<br>    }</em></pre><br>&nbsp;<br><div>调用createEntry函数，参数跟addEntry一样，第一个是key的hash值，第二个第三个分别是key和value，最后一个是这个key在table中的位置。这里的操作与Entry的构造函数有关系。</div><br><div><br><pre class="theme:eclipse lang:java decode:true ">        /**
          Creates new entry.<br>         <em>/<br>        Entry (int h, K k, V v, Entry&lt;K,V&gt; n) {<br>            value = v;<br>            next = n;<br>            key = k;<br>            hash = h;<br>        }</em></pre><br>&nbsp;<br><div>构造函数中传入一个Entry对象，并把它当做这个新生成的Entry的next。所以createEntry函数中的操作相当于把table[bucketIndex]上的链表拿下来，放在新的Entry后面，然后再把新的Entry放到table[bucketIndex]上。</div><br><div><a href="http://www.grackertalk.com/wp-content/uploads/2014/04/hm02.png" target="_blank" rel="external"><img src="http://www.grackertalk.com/wp-content/uploads/2014/04/hm02.png" alt="hm02"></a></div><br><div></div><br><div><br><div><br><div align="left">到这里整个put函数算是结束了。如果新插入的K，V则会返回null。</div><br><div align="left"></div><br><div align="left">4.get操作</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Returns the value to which the specified key is mapped,<br>     <em> or {@code null} if this map contains no mapping for the key.
     </em><br>     <em> &lt;p&gt;More formally, if this map contains a mapping from a key
     </em> {@code k} to a value {@code v} such that {@code (key==null ? k==null :<br>     <em> key.equals(k))}, then this method returns {@code v}; otherwise
     </em> it returns {@code null}.  (There can be at most one such mapping.)<br>     <em>
     </em> &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily &lt;/i&gt;<br>     <em> indicate that the map contains no mapping for the key; it’s also
     </em> possible that the map explicitly maps the key to {@code null}.<br>     <em> The {@link #containsKey containsKey} operation may be used to
     </em> distinguish these two cases.<br>     <em>
     </em> @see #put(Object, Object)<br>     <em>/<br>    public V get(Object key) {<br>        if (key == null)<br>            return getForNullKey();<br>        Entry&lt;K,V&gt; entry = getEntry(key);<br><br>        return null == entry ? null : entry.getValue();<br>    }</em></pre><br>&nbsp;<br><div>也是先判断key是不是null，做特殊处理。直接上代码，不赘述。</div><br><div><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Offloaded version of get() to look up null keys.  Null keys map<br>     <em> to index 0.  This null case is split out into separate methods
     </em> for the sake of performance in the two most commonly used<br>     <em> operations (get and put), but incorporated with conditionals in
     </em> others.<br>     <em>/<br>    private V getForNullKey() {<br>        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e. next) {<br>            if (e. key == null)<br>                return e. value;<br>        }<br>        return null;<br>    }</em></pre><br>&nbsp;<br><div>key不是null则会调用getEntry函数，并返回一个Entry对象，如果不是null，就返回entry的value。</div><br><div><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Returns the entry associated with the specified key in the<br>     <em> HashMap.  Returns null if the HashMap contains no mapping
     </em> for the key.<br>     <em>/<br>    final Entry&lt;K,V&gt; getEntry(Object key) {<br>        int hash = (key == null) ? 0 : hash(key);<br>        for (Entry&lt;K,V&gt; e = table[ indexFor(hash, table.length)];<br>             e != null;<br>             e = e. next) {<br>            Object k;<br>            if (e. hash == hash &amp;&amp;<br>                ((k = e. key) == key || (key != null &amp;&amp; key.equals(k))))<br>                return e;<br>        }<br>        return null;<br>    }</em></pre><br>&nbsp;<br><div><br><div align="left">直接求key值hash值，然后求table中的位置，遍历链表。有返回entry对象，没有返回null。</div><br><div align="left"></div><br><div align="left">5. Fail-Fast机制：</div><br></div><br></div><br></div><br><pre class="theme:eclipse lang:java decode:true ">    /**
      The number of times this HashMap has been structurally modified<br>     <em> Structural modifications are those that change the number of mappings in
     </em> the HashMap or otherwise modify its internal structure (e.g.,<br>     <em> rehash).  This field is used to make iterators on Collection-views of
     </em> the HashMap fail -fast.  (See ConcurrentModificationException).<br>     */<br>    transient int modCount;</pre><br>&nbsp;<br><div><br><div align="left">    我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</div><br><div align="left">    这一策略在源码中的实现是通过modCount域，保证线程之间修改的可见性。，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</div><br><div>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</div><br><div></div><br><div><br><div><br><div>《Core JAVA》</div><br><div>《JDK 中文文档》</div>

<div style="color: #000000;font-family: 微软雅黑"><br>        <table><br>            <tr><br>                <td>Article Name:</td><br>                <td>HashMap源码分析</td><br>            </tr><br>            <tr><br>                <td>Author:</td><br>                <td>刘天昊</td><br>            </tr><br>            <tr><br>                <td>Email:</td><br>                <td>liutianhao.pro@gmail.com</td><br>            </tr><br>        </table><br></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div>
          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="../../2014/04/01/android-service-build-your-own-notification-servers-app/">
                Android Service：开发自己的通知中心(2):辅助性服务实战
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-03-31
          
        </span>

        
          
            <span class="post-category">
              &nbsp; | &nbsp; 分类于
              
                <a href="../../categories/Android/">Android</a>

                
                

              
            </span>
          
        

        
          
            <span class="post-comments-count">
            &nbsp; | &nbsp;
            <a href="/2014/04/01/android-service-build-your-own-notification-servers-app/#comments" >
              <span class="post-comments-count ds-thread-count" data-thread-key="2014/04/01/android-service-build-your-own-notification-servers-app/"></span>
            </a>
          </span>
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="1-辅助性服务实战介绍">1.辅助性服务实战介绍</h2><p>上一篇文章介绍了什么是Accessibility以及简单的使用，这一篇文章就来讲讲如何使用Accessibility服务来创建一个简单的Android通知中心。Android中通知中心是一个系统层面的服务，负责显示应用和系统发来的通知（Notification，比如USB插入、选择输入法、未接来电、截图、天气信息、新闻推送等等）。在android4.3之前，一般的第三方应用是无法获取Notification list的（在Android4.3之后，有了一个新的接口,NotificationListenerService.getActiveNotifications(),可以获取当前的Notification）。但是利用Accessibility服务可以监听到各种事件的特性，可以开发一个第三方的通知中心，实现与系统通知栏类似的功能。</p>
<p>下面就来介绍如何开发自己的通知中心。</p>
<h2 id="2-开发第三方通知中心">2.开发第三方通知中心</h2><h3 id="2-1继承AccessibilitySerivce">2.1继承AccessibilitySerivce</h3><p>按照上一篇辅助性服务的介绍，一个辅助性服务可以被捆绑到一个标准的应用程序上，或者以一个单独的安卓工程被创建，我们这里建立一个服务，继承AccessibilitySerivce</p>
<pre class="\"lang:java" decode:true\"="" title="\"继承AccessibilityService\"">import android.accessibilityservice.AccessibilityService;
import android.accessibilityservice.AccessibilityServiceInfo;
import android.app.Notification;
import android.app.PendingIntent;
import android.content.Intent;
import android.os.Parcelable;
import android.util.Log;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;
import android.view.accessibility.AccessibilityRecord;
import android.widget.Toast;

public class NotificationFetcherService extends AccessibilityService {

    private static final String TAG = \"NotificationFetcherService: \";

    public void onAccessibilityEvent(AccessibilityEvent event) {
        if (!(event.getEventType() == AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED) ){
            return;
        }

        Notification localNotification = (Notification)event.getParcelableData();

        if (localNotification != null) {
            Intent intent=new Intent();
            intent.putExtra(\"NotifyData\", localNotification);
            intent.setAction(\".NotificationFetcherService\");
            sendBroadcast(intent);
        }

    }

    @Override
    protected void onServiceConnected() {

        // Define it in both xml file and here,  for compatibility with pre-ICS devices
        AccessibilityServiceInfo info = new AccessibilityServiceInfo();
        info.eventTypes = AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED |
                AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED | 
                AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED;

        info.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;
        setServiceInfo(info);
    }

    @Override
    public void onInterrupt() {
        System.out.println(\"onInterrupt\");
    }

}</pre>

<p>继承AccessibilitySerivce必须要重写几个重要的方法：</p>
<p>onServiceConnected方法负责在服务和Activity绑定的时候，进行初始化数据，这里新建了一个AccessibilityServiceInfo对象，并将TYPE_NOTIFICATION_STATE_CHANGED、TYPE_WINDOW_STATE_CHANGED、TYPE_WINDOW_CONTENT_CHANGED纳入监听范围，TYPE_NOTIFICATION_STATE_CHANGED表示这个服务可以监听Notification的变化，我们正是使用这个特性来实现第三方的通知中心功能。</p>
<p>onInterrupt是服务断开时调用的函数</p>
<p>onAccessibilityEvent是最重要的，它负责监听所注册的eventTypes（在onServiceConnected中注册的）的事件。从上面的代码中我们可以得到一个Notification对象：</p>
<pre class="\"lang:java" decode:true\"="" title="\"得到Notification对象\"">Notification localNotification = (Notification)event.getParcelableData();</pre>

<p>得到Notification对象之后，就可以进行自己的操作，我这里是通过广播的形式，将收到的Notification发送给Activity进行处理。</p>
<p>这里也会碰到一个小问题：当一个Notification对象太大时（比如截图、未接来电等，Notification.contentView就很大，通过广播传播会出现data过大无法传输的问题），这时可以把Notification.contentView对象暂时保存在Application中，然后再置为null，Activity中接收到数据后，再进行赋值。</p>
<h3 id="2-2在Manifest中注册service">2.2在Manifest中注册service</h3><pre class="\"lang:java" decode:true\"="">&lt;service
            android:name=\".NotificationFetcherService\"
            android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\" &gt;
            &lt;intent-filter&gt;
                &lt;action android:name=\"android.accessibilityservice.AccessibilityService\" /&gt;
            &lt;/intent-filter&gt;

            &lt;meta-data
                android:name=\"android.accessibilityservice\"
                android:resource=\"@xml/accessibilityserviceconfig /&gt;
&lt;/service&gt;</pre>

<p>这里就是普通的service注册，注意 &lt;mate-data&gt;标签中的xml文件：从Android 4.0版本开始，有另外一种方法：使用XML文件来配置这类服务。如果你以XML的形式来定义你的服务，某些像canRetrieveWindowContent可配置的选项就可用了。和service一样的配置，使用XML来定义。如果你要使用XML路径，要在你的mainfest文件中指定它，在你的服务声明中添加&lt;meta-data&gt;标签,并指向这个XML资源文件。比如上面的代码，我们在res/xml/中建立accessibilityaseviceconfig.xml，内容如下：</p>
<pre class="\"lang:java" decode:true\"="">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;
&lt;accessibility-service xmlns:android=\"http://schemas.android.com/apk/res/android\"
    android:accessibilityEventTypes=\"typeWindowStateChanged|typeNotificationStateChanged|typeWindowContentChanged\"
    android:accessibilityFeedbackType=\"feedbackGeneric\"
/&gt;</pre>

<p>服务这里就配置好了。</p>
<h3 id="2-3_接受并处理Notification">2.3 接受并处理Notification</h3><p>下面的Activity中就可以接受这个数据，然后怎么处理就看自己了，这里只是简单地显示出来。</p>
<pre class="\"lang:java" decode:true\"="">import android.app.Activity;
import android.app.Application;
import android.app.Notification;
import android.app.PendingIntent;
import android.app.PendingIntent.CanceledException;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.Parcelable;
import android.os.Process;
import android.text.method.ScrollingMovementMethod;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.RemoteViews;
import android.widget.TextView;

public class NotificaitonActivity extends Activity {
    private static final int NOTIFY_DATA_FLAG = 1;
    private static final String NOTIFY_DATA_ID_STR= \"NotifyData\";

    private NotifyDataReceiver  receiver;
    private TextView textView;
    private LinearLayout rootLayout;
    private Button button;

    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);
        textView = (TextView) findViewById(R.id.notify_test_textview);
        textView.setMovementMethod(ScrollingMovementMethod.getInstance());
        rootLayout = (LinearLayout) findViewById(R.id.root_layout);

        registerBroadcast();

        button = (Button) findViewById(R.id.test_button);
        button.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Button b = new Button(NotificaitonActivity.this);
                b.setText(\"Tthis\");
                rootLayout.addView(b);
            }
        });
    }

    private void registerBroadcast() {
        receiver = new NotifyDataReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(\".NotificationFetcherService\");
        this.registerReceiver(receiver, filter);
        Log.e(\"Dx:\", \"Broadcast registered.........\");
    }

    private void addToUi(RemoteViews remoteView) {
        rootLayout.addView(remoteView);
    }

    private void showNotify(String notiString) {
        textView.setText(textView.getText() + \"n\" + notiString);
    }

    private class NotifyDataReceiver extends BroadcastReceiver{

        @Override
        public void onReceive(Context context, Intent intent) {
            Log.e(\"Dx:\", \"Receiver got msg in onReceive()...\");

            Parcelable notifyParcelable = intent.getParcelableExtra(\"NotifyData\");

            if (notifyParcelable != null) {

                Notification notification = (Notification) notifyParcelable;
                showNotify(\"tickerText: \" + notification.tickerText);
                showNotify(\"toString: \" + (String)(notification.toString()));

                RemoteViews remoteV = notification.contentView;
                if (remoteV==null) {
                    showNotify(\"remoteView is: null\" );
                } else {
                    showNotify(\"remoteView is: not null\" );

                    addToUi(remoteV);
                }

                PendingIntent pendIntent = notification.contentIntent;
                if (pendIntent==null) {
                    showNotify(\"pendIntent is: null\" );
                } else {
                showNotify(\"pendIntent is: not null\" );
                }

                showNotify(\"**************************\" );
                showNotify(\"                    \" );

            }

        }
    }

}</pre>

<p><span style="\"color:" #ff0000;\"="">注：这里有很重要的一点，由于AccessibilityService的特殊性，用户必须手动到设置-辅助功能中，打开对应的服务，我们才可以通过AccessibilityService获得对应的数据，这一点非常重要。</span></p>
<p>上面的Activity只是简单地显示Notification，关于更多Notification的操作，可以参考Notification这个类，其中重要的属性有：contentView，flags。要模拟真正的通知中心，还是要费一番功夫的。这里由于公司项目的保密，暂不提供对应的实现代码（其实得到Notification就已经成功了一半了），有兴趣的同学可以私下和我交流。</p>
<h2 id="3-总结和问题">3.总结和问题</h2><p>AccessibilityService的实战就讲到这里，这一篇博文也是拖了一段时间才写完的，也算是为前一段时间的项目做个了结。</p>
<p>项目中目前还存在的问题：</p>
<ol>
<li>无法获取安装这个应用之前的系统的Notification</li>
<li>得到的Notification对象没法保存在本地，所以这个服务被杀掉之后，所有的数据都会丢失。（试过用db4o这种对象数据库来进行存储，发现行不通）</li>
<li>对Android系统的Notification对象的行为模仿不够（有些系统的事件监听不到，比如usb的插拔、usb调试的开关等）</li>
</ol>
<p>上面的问题，如果你有好的想法，我们私下交流。</p>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  

          </div>

          
            <div class="pagination">
              <a class="extend prev" rel="prev" href="../2/">&laquo;</a><a class="page-number" href="../..//">1</a><a class="page-number" href="../2/">2</a><span class="page-number current">3</span><a class="page-number" href="../4/">4</a><a class="extend next" rel="next" href="../4/">&raquo;</a>
            </div>
          
        </div>

        
<div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>

<div id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    

    <div class="site-overview">
      <div class="site-author motion-element">
        <img class="site-author-image" src="../../images/default_avatar.jpg" alt="Gracker" />
        <p class="site-author-name">Gracker</p>
      </div>
      <p class="site-description motion-element"></p>
      <div class="site-state motion-element">
        <div class="site-state-item site-state-posts">
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </div>
        <div class="site-state-item site-state-tags">
            <span class="site-state-item-count">0</span>
            <span class="site-state-item-name">标签</span>
        </div>
        <div class="site-state-item site-state-pages">
            <span class="site-state-item-count">1</span>
            <span class="site-state-item-name">页面</span>
        </div>
      </div>

      

      <div class="links-of-author motion-element">
        
      </div>

      
      

    </div>

    

  </div>
</div>


      </div>
    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Gracker</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="../../vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="../../vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $(".fancybox").fancybox();
    });
  </script>

  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }
</script>

  

  <script type="text/javascript" src="../../vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="../../vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    LogoAndMenuMotion();
    sidebatToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});

    function LogoAndMenuMotion() {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200 } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    }


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = window.postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebatToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  

  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"grackertalk"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
  
</body>
</html>
