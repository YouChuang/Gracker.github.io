<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Android Perofrmance]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://androidperformance.com/"/>
  <updated>2015-03-27T05:19:16.000Z</updated>
  <id>http://androidperformance.com/</id>
  
  <author>
    <name><![CDATA[Gracker]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(5)]]></title>
    <link href="http://androidperformance.com/2015/03/15/android-tips-round-up-5/"/>
    <id>http://androidperformance.com/2015/03/15/android-tips-round-up-5/</id>
    <published>2015-03-14T16:32:11.000Z</published>
    <updated>2015-03-27T05:19:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第五篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="https://developer.android.com/reference/android/support/v4/widget/ViewDragHelper.html" target="_blank" rel="external">ViewDragHelper</a> ——视图拖动是一个比较复杂的问题。这个类可以帮助解决不少问题。如果你需要一个例子，<a href="https://developer.android.com/reference/android/support/v4/widget/DrawerLayout.html" target="_blank" rel="external">DrawerLayout</a>就是利用它实现扫滑。Flavient Laurent 还写了一些关于这方面的<a href="http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper/" target="_blank" rel="external">优秀文章</a>。</p>
<p><a href="https://developer.android.com/reference/android/widget/PopupWindow.html" target="_blank" rel="external">PopupWindow</a>——Android到处都在使用PopupWindow ，甚至你都没有意识到（标题导航条ActionBar，自动补全AutoComplete，编辑框错误提醒Edittext Errors）。这个类是创建浮层内容的主要方法。</p>
<p><a href="https://developer.android.com/reference/android/app/ActionBar.htmlgetThemedContext%28%29" target="_blank" rel="external">Actionbar.getThemrContext()</a>——导航栏的主题化是很复杂的（不同于Activity其他部分的主题化）。你可以得到一个上下文（Context），用这个上下文创建的自定义组件可以得到正确的主题。</p>
<p><a href="https://developer.android.com/reference/android/media/ThumbnailUtils.html" target="_blank" rel="external">ThumbnailUtils</a>——帮助创建缩略图。通常我都是用现有的图片加载库（比如，Picasso 或者 Volley），不过这个ThumbnaiUtils可以创建视频缩略图。<strong>译者注：</strong>该API从V8才开始支持。</p>
<p><a href="https://developer.android.com/reference/android/content/Context.htmlgetExternalFilesDir%28java.lang.String%29" target="_blank" rel="external">Context.getExternalFilesDir()</a>———— 申请了SD卡写权限后，你可以在SD的任何地方写数据，把你的数据写在设计好的合适位置会更加有礼貌。这样数据可以及时被清理，也会有更好的用户体验。此外，Android 4.0 Kitkat中在这个文件夹下写数据是不需要权限的，每个用户有自己的独立的数据存储路径。<strong>译者注：</strong>该API从V8才开始支持。</p>
<p><a href="https://developer.android.com/reference/android/util/SparseArray.html" target="_blank" rel="external">SparseArray</a>——Map的高效优化版本。推荐了解姐妹类SparseBooleanArray、SparseIntArray和SparseLongArray。</p>
<p><a href="https://developer.android.com/reference/android/content/pm/PackageManager.htmlsetComponentEnabledSetting%28android.content.ComponentName,%20int,%20int%29" target="_blank" rel="external">PackageManager.setComponentEnabledSetting()</a>——可以用来启动或者禁用程序清单中的组件。对于关闭不需要的功能组件是非常赞的，比如关掉一个当前不用的广播接收器。</p>
<a id="more"></a>
<p><a href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.htmlyieldIfContendedSafely%28%29" target="_blank" rel="external">SQLiteDatabase.yieldIfContendedSafely()</a>——让你暂时停止一个数据库事务， 这样你可以就不会占用太多的系统资源。</p>
<p><a href="https://developer.android.com/reference/android/os/Environment.html#getExternalStoragePublicDirectory%28java.lang.String%29" target="_blank" rel="external">Environment.getExternalStoragePublicDirectory()</a>——还是那句话，用户期望在SD卡上得到统一的用户体验。用这个方法可以获得在用户设备上放置指定类型文件（音乐、图片等）的正确目录。</p>
<p><a href="https://developer.android.com/reference/android/view/View.htmlgenerateViewId%28%29" target="_blank" rel="external">View.generateViewId()</a>——每次我都想要推荐动态生成控件的ID。需要注意的是，不要和已经存在的控件ID或者其他已经生成的控件ID重复。</p>
<p><a href="https://developer.android.com/reference/android/app/ActivityManager.htmlclearApplicationUserData%28%29" target="_blank" rel="external">ActivityManager.clearApplicationUserData()</a>—— 一键清理你的app产生的用户数据，可能是做用户退出登录功能，有史以来最简单的方式了。</p>
<p><a href="http://developer.android.com/reference/android/content/Context.htmlcreateConfigurationContext%28android.%E2%80%94%E2%80%94ontent.res.Configuration%29" target="_blank" rel="external">Context.createConfigurationContext()</a> ——自定义你的配置环境信息。我通常会遇到这样的问题：强制让一部分显示在某个特定的环境下（倒不是我一直这样瞎整，说来话长，你很难理解）。用这个实现起来可以稍微简单一点。</p>
<p><a href="http://developer.android.com/reference/android/app/ActivityOptions.html" target="_blank" rel="external">ActivityOptions</a> ——方便的定义两个Activity切换的动画。 使用<a href="http://developer.android.com/reference/android/support/v4/app/ActivityOptionsCompat.html" target="_blank" rel="external">ActivityOptionsCompat</a> 可以很好解决旧版本的兼容问题。</p>
<p><a href="http://developer.android.com/reference/android/widget/AdapterViewFlipper.htmlfyiWillBeAdvancedByHostKThx%28%29" target="_blank" rel="external">AdapterViewFlipper.fyiWillBeAdvancedByHostKThx()</a>——仅仅因为很好玩，没有其他原因。在整个安卓开源项目中（AOSP the Android ——pen Source Project Android开放源代码项目）中还有其他很有意思的东西（比如<br><a href="http://developer.android.com/reference/android/hardware/SensorManager.htmlGRAVITY_DEATH_STAR_I" target="_blank" rel="external">GRAVITY_DEATH_STAR_I</a>）。不过，都不像这个这样，这个确实有用</p>
<p><a href="http://developer.android.com/reference/android/view/ViewParent.htmlrequestDisallowInterceptTouchEvent%28boolean%29" target="_blank" rel="external">ViewParent.requestDisallowInterceptTouchEvent()</a> ——Android系统触摸事件机制大多时候能够默认处理，不过有时候你需要使用这个方法来剥夺父级控件的控制权（顺便说一下，如果你想对Android触摸机制了解更多，<a href="https://www.youtube.com/watch?v=EZAoJU-nUyI" target="_blank" rel="external">这个演讲</a>会令你惊叹不已。）</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-5/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-5/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-5.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第五篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="https://developer.android.com/reference/android/support/v4/widget/ViewDragHelper.html">ViewDragHelper</a> ——视图拖动是一个比较复杂的问题。这个类可以帮助解决不少问题。如果你需要一个例子，<a href="https://developer.android.com/reference/android/support/v4/widget/DrawerLayout.html">DrawerLayout</a>就是利用它实现扫滑。Flavient Laurent 还写了一些关于这方面的<a href="http://flavienlaurent.com/blog/2013/08/28/each-navigation-drawer-hides-a-viewdraghelper/">优秀文章</a>。</p>
<p><a href="https://developer.android.com/reference/android/widget/PopupWindow.html">PopupWindow</a>——Android到处都在使用PopupWindow ，甚至你都没有意识到（标题导航条ActionBar，自动补全AutoComplete，编辑框错误提醒Edittext Errors）。这个类是创建浮层内容的主要方法。</p>
<p><a href="https://developer.android.com/reference/android/app/ActionBar.htmlgetThemedContext%28%29">Actionbar.getThemrContext()</a>——导航栏的主题化是很复杂的（不同于Activity其他部分的主题化）。你可以得到一个上下文（Context），用这个上下文创建的自定义组件可以得到正确的主题。</p>
<p><a href="https://developer.android.com/reference/android/media/ThumbnailUtils.html">ThumbnailUtils</a>——帮助创建缩略图。通常我都是用现有的图片加载库（比如，Picasso 或者 Volley），不过这个ThumbnaiUtils可以创建视频缩略图。<strong>译者注：</strong>该API从V8才开始支持。</p>
<p><a href="https://developer.android.com/reference/android/content/Context.htmlgetExternalFilesDir%28java.lang.String%29">Context.getExternalFilesDir()</a>———— 申请了SD卡写权限后，你可以在SD的任何地方写数据，把你的数据写在设计好的合适位置会更加有礼貌。这样数据可以及时被清理，也会有更好的用户体验。此外，Android 4.0 Kitkat中在这个文件夹下写数据是不需要权限的，每个用户有自己的独立的数据存储路径。<strong>译者注：</strong>该API从V8才开始支持。</p>
<p><a href="https://developer.android.com/reference/android/util/SparseArray.html">SparseArray</a>——Map的高效优化版本。推荐了解姐妹类SparseBooleanArray、SparseIntArray和SparseLongArray。</p>
<p><a href="https://developer.android.com/reference/android/content/pm/PackageManager.htmlsetComponentEnabledSetting%28android.content.ComponentName,%20int,%20int%29">PackageManager.setComponentEnabledSetting()</a>——可以用来启动或者禁用程序清单中的组件。对于关闭不需要的功能组件是非常赞的，比如关掉一个当前不用的广播接收器。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(4)]]></title>
    <link href="http://androidperformance.com/2015/03/15/android-tips-round-up-4/"/>
    <id>http://androidperformance.com/2015/03/15/android-tips-round-up-4/</id>
    <published>2015-03-14T16:31:02.000Z</published>
    <updated>2015-03-27T05:19:07.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第四篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/app/Activity.html#isChangingConfigurations%28%29" target="_blank" rel="external">Activity.isChangingConfigurations ()</a>——如果在 Activity 中 configuration 会经常改变的话，使用这个方法就可以不用手动做保存状态的工作了。</p>
<p><a href="http://developer.android.com/reference/android/content/SearchRecentSuggestionsProvider.html" target="_blank" rel="external">SearchRecentSuggestionsProvider</a>——可以创建最近提示效果的 provider，是一个简单快速的方法。</p>
<p><a href="http://developer.android.com/reference/android/view/ViewTreeObserver.html" target="_blank" rel="external">ViewTreeObserver</a>——这是一个很棒的工具。可以进入到 VIew 里面，并监控 View 结构的各种状态，通常我都用来做 View 的测量操作（自定义视图中经常用到）。</p>
<p><a href="https://www.timroes.de/2013/09/12/speed-up-gradle/" target="_blank" rel="external">org.gradle.daemon=true</a>——这句话可以帮助减少 Gradle 构建的时间，仅在命令行编译的时候用到，因为 Android Studio 已经这样使用了。</p>
<p><a href="http://developer.android.com/reference/android/database/DatabaseUtils.html" target="_blank" rel="external">DatabaseUtils</a>——一个包含各种数据库操作的使用工具。</p>
<p><a href="http://developer.android.com/reference/android/widget/LinearLayout.html#attr_android:weightSum" target="_blank" rel="external">android:weightSum (LinearLayout)</a>——如果想使用 layout weights，但是却不想填充整个 LinearLayout 的话，就可以用 weightSum 来定义总的 weight 大小。</p>
<p><a href="http://developer.android.com/reference/android/view/View.html#attr_android:duplicateParentState" target="_blank" rel="external">android:duplicateParentState (View)</a>——此方法可以使得子 View 可以复制父 View 的状态。比如如果一个 ViewGroup 是可点击的，那么可以用这个方法在它被点击的时候让它的子 View 都改变状态。</p>
<a id="more"></a>
<p><a href="http://developer.android.com/reference/android/view/ViewGroup.html#attr_android:clipChildren" target="_blank" rel="external">android:clipChildren (ViewGroup)</a>——如果此属性设置为不可用，那么 ViewGroup 的子 View 在绘制的时候会超出它的范围，在做动画的时候需要用到。</p>
<p><a href="http://developer.android.com/reference/android/widget/ScrollView.html#attr_android:fillViewport" target="_blank" rel="external">android:fillViewport (ScrollView)</a>——在这片文章中有详细介绍<a href="http://www.curious-creature.org/2010/08/15/scrollviews-handy-trick/" target="_blank" rel="external">文章链接</a>，可以解决在 ScrollView 中当内容不足的时候填不满屏幕的问题。</p>
<p><a href="http://developer.android.com/guide/topics/resources/drawable-resource.html#Bitmap" target="_blank" rel="external">android:tileMode (BitmapDrawable)</a>——可以指定图片使用重复填充的模式。</p>
<p><a href="http://developer.android.com/reference/android/R.attr.html#exitFadeDuration" target="_blank" rel="external">android:enterFadeDuration/android:exitFadeDuration (Drawables)</a>——此属性在 Drawable 具有多种状态的时候，可以定义它展示前的淡入淡出效果。</p>
<p><a href="http://developer.android.com/reference/android/widget/ImageView.html#attr_android:scaleType" target="_blank" rel="external">android:scaleType (ImageView)</a>——定义在 ImageView 中怎么缩放/剪裁图片，一般用的比较多的是“centerCrop”和“centerInside”。</p>
<p><a href="http://developer.android.com/training/improving-layouts/reusing-layouts.html#Merge" target="_blank" rel="external">Merge</a>——此标签可以在另一个布局文件中包含别的布局文件，而不用再新建一个 ViewGroup，对于自定义 ViewGroup 的时候也需要用到；可以通过载入一个带有标签的布局文件来自动定义它的子部件。</p>
<p><a href="http://developer.android.com/reference/android/util/AtomicFile.html" target="_blank" rel="external">AtomicFile</a>——通过使用备份文件进行文件的原子化操作。这个知识点之前我也写过，不过最好还是有出一个官方的版本比较好。</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-4/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-4/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-4.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第四篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/app/Activity.html#isChangingConfigurations%28%29">Activity.isChangingConfigurations ()</a>——如果在 Activity 中 configuration 会经常改变的话，使用这个方法就可以不用手动做保存状态的工作了。</p>
<p><a href="http://developer.android.com/reference/android/content/SearchRecentSuggestionsProvider.html">SearchRecentSuggestionsProvider</a>——可以创建最近提示效果的 provider，是一个简单快速的方法。</p>
<p><a href="http://developer.android.com/reference/android/view/ViewTreeObserver.html">ViewTreeObserver</a>——这是一个很棒的工具。可以进入到 VIew 里面，并监控 View 结构的各种状态，通常我都用来做 View 的测量操作（自定义视图中经常用到）。</p>
<p><a href="https://www.timroes.de/2013/09/12/speed-up-gradle/">org.gradle.daemon=true</a>——这句话可以帮助减少 Gradle 构建的时间，仅在命令行编译的时候用到，因为 Android Studio 已经这样使用了。</p>
<p><a href="http://developer.android.com/reference/android/database/DatabaseUtils.html">DatabaseUtils</a>——一个包含各种数据库操作的使用工具。</p>
<p><a href="http://developer.android.com/reference/android/widget/LinearLayout.html#attr_android:weightSum">android:weightSum (LinearLayout)</a>——如果想使用 layout weights，但是却不想填充整个 LinearLayout 的话，就可以用 weightSum 来定义总的 weight 大小。</p>
<p><a href="http://developer.android.com/reference/android/view/View.html#attr_android:duplicateParentState">android:duplicateParentState (View)</a>——此方法可以使得子 View 可以复制父 View 的状态。比如如果一个 ViewGroup 是可点击的，那么可以用这个方法在它被点击的时候让它的子 View 都改变状态。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(3)]]></title>
    <link href="http://androidperformance.com/2015/03/15/android-tips-round-up-3/"/>
    <id>http://androidperformance.com/2015/03/15/android-tips-round-up-3/</id>
    <published>2015-03-14T16:29:57.000Z</published>
    <updated>2015-03-27T05:19:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第三篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/net/UrlQuerySanitizer.html" target="_blank" rel="external">UrlQuerySanitizer</a>——使用这个工具可以方便对 URL 进行检查。</p>
<p><a href="http://developer.android.com/reference/android/app/Fragment.html#setArguments%28android.os.Bundle%29" target="_blank" rel="external">Fragment.setArguments</a>——因为在构建 Fragment 的时候不能加参数，所以这是个很好的东西，可以在创建 Fragment 之前设置参数（即使在 configuration 改变的时候仍然会导致销毁/重建）。</p>
<p><a href="http://developer.android.com/reference/android/app/DialogFragment.html#setShowsDialog%28boolean%29" target="_blank" rel="external">DialogFragment.setShowsDialog ()</a>—— 这是一个很巧妙的方式，DialogFragment 可以作为正常的 Fragment 显示！这里可以让 Fragment 承担双重任务。我通常在创建 Fragment 的时候把 onCreateView ()和 onCreateDialog ()都加上，就可以创建一个具有双重目的的 Fragment。</p>
<p><a href="http://developer.android.com/reference/android/app/FragmentManager.html#enableDebugLogging%28boolean%29" target="_blank" rel="external">FragmentManager.enableDebugLogging ()</a>——在需要观察 Fragment 状态的时候会有帮助。</p>
<p><a href="http://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html" target="_blank" rel="external">LocalBroadcastManager</a>——这个会比全局的 broadcast 更加安全，简单，快速。像 <a href="http://square.github.io/otto/" target="_blank" rel="external">otto</a> 这样的 Event buses 机制对你的应用场景更加有用。</p>
<p><a href="http://developer.android.com/reference/android/telephony/PhoneNumberUtils.html#formatNumber%28java.lang.String%29" target="_blank" rel="external">PhoneNumberUtils.formatNumber ()</a>——顾名思义，这是对数字进行格式化操作的时候用的。</p>
<p><a href="http://developer.android.com/reference/android/graphics/Region.html#op%28android.graphics.Region,%20android.graphics.Region,%20android.graphics.Region.Op%29" target="_blank" rel="external">Region.op()</a>——我发现在对比两个渲染之前的区域的时候很实用，如果你有两条路径，那么怎么知道它们是不是会重叠呢？使用这个方法就可以做到。</p>
<a id="more"></a>
<p><a href="http://developer.android.com/reference/android/app/Application.html#registerActivityLifecycleCallbacks%28android.app.Application.ActivityLifecycleCallbacks%29" target="_blank" rel="external">Application.registerActivityLifecycleCallbacks</a>——虽然缺少官方文档解释，不过我想它就是注册 Activity 的生命周期的一些回调方法（顾名思义），就是一个方便的工具。</p>
<p><a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Build-Types" target="_blank" rel="external">versionNameSuffix</a>——这个 gradle 设置可以让你在基于不同构建类型的 manifest 中修改版本名这个属性，例如，如果需要在在 debug 版本中以”-SNAPSHOT”结尾，那么就可以轻松的看出当前是 debug 版还是 release 版。</p>
<p><a href="http://developer.android.com/reference/android/database/CursorJoiner.html" target="_blank" rel="external">CursorJoiner</a>——如果你是只使用一个数据库的话，使用 SQL 中的 join 就可以了，但是如果收到的数据是来自两个独立的 ContentProvider，那么 CursorJoiner 就很实用了。</p>
<p><a href="http://www.genymotion.com/" target="_blank" rel="external">Genymotion</a>——一个非常快的 Android 模拟器，本人一直在用。</p>
<p><a href="http://developer.android.com/guide/practices/screens_support.html#qualifiers" target="_blank" rel="external">-nodpi</a>——在没有特别定义的情况下，很多修饰符(-mdpi,-hdpi,-xdpi等等)都会默认自动缩放 assets/dimensions，有时候我们需要保持显示一致，这种情况下就可以使用 -nodpi。</p>
<p><a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#setDebugUnregister%28boolean%29" target="_blank" rel="external">BroadcastRecevier.setDebugUnregister ()</a>——又一个方便的调试工具。</p>
<p><a href="http://developer.android.com/reference/android/app/Activity.html#recreate%28%29" target="_blank" rel="external">Activity.recreate ()</a>——强制让 Activity 重建。</p>
<p><a href="http://developer.android.com/reference/android/content/pm/PackageManager.html#checkSignatures%28java.lang.String,%20java.lang.String%29" target="_blank" rel="external">PackageManager.checkSignatures ()</a>——如果同时安装了两个 app 的话，可以用这个方法检查。如果不进行签名检查的话，其他人可以轻易通过使用一样的包名来模仿你的 app。</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-3/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-3/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-3.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第三篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/net/UrlQuerySanitizer.html">UrlQuerySanitizer</a>——使用这个工具可以方便对 URL 进行检查。</p>
<p><a href="http://developer.android.com/reference/android/app/Fragment.html#setArguments%28android.os.Bundle%29">Fragment.setArguments</a>——因为在构建 Fragment 的时候不能加参数，所以这是个很好的东西，可以在创建 Fragment 之前设置参数（即使在 configuration 改变的时候仍然会导致销毁/重建）。</p>
<p><a href="http://developer.android.com/reference/android/app/DialogFragment.html#setShowsDialog%28boolean%29">DialogFragment.setShowsDialog ()</a>—— 这是一个很巧妙的方式，DialogFragment 可以作为正常的 Fragment 显示！这里可以让 Fragment 承担双重任务。我通常在创建 Fragment 的时候把 onCreateView ()和 onCreateDialog ()都加上，就可以创建一个具有双重目的的 Fragment。</p>
<p><a href="http://developer.android.com/reference/android/app/FragmentManager.html#enableDebugLogging%28boolean%29">FragmentManager.enableDebugLogging ()</a>——在需要观察 Fragment 状态的时候会有帮助。</p>
<p><a href="http://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html">LocalBroadcastManager</a>——这个会比全局的 broadcast 更加安全，简单，快速。像 <a href="http://square.github.io/otto/">otto</a> 这样的 Event buses 机制对你的应用场景更加有用。</p>
<p><a href="http://developer.android.com/reference/android/telephony/PhoneNumberUtils.html#formatNumber%28java.lang.String%29">PhoneNumberUtils.formatNumber ()</a>——顾名思义，这是对数字进行格式化操作的时候用的。</p>
<p><a href="http://developer.android.com/reference/android/graphics/Region.html#op%28android.graphics.Region,%20android.graphics.Region,%20android.graphics.Region.Op%29">Region.op()</a>——我发现在对比两个渲染之前的区域的时候很实用，如果你有两条路径，那么怎么知道它们是不是会重叠呢？使用这个方法就可以做到。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为Nexus5编译AndroidL固件]]></title>
    <link href="http://androidperformance.com/2015/02/04/build-rom-for-nexus5/"/>
    <id>http://androidperformance.com/2015/02/04/build-rom-for-nexus5/</id>
    <published>2015-02-04T12:51:19.000Z</published>
    <updated>2015-03-27T05:20:44.000Z</updated>
    <content type="html"><![CDATA[<p>接前一篇文章<a href="http://www.androidperformance.com/view-android-source-code-with-androidstudio.html" target="_blank" rel="external">使用Android Studio查看Android Lollipop源码</a>, 我们知道,仅仅看代码,提高是比较有限的,而且理解起来也比较肤浅,往往过目就忘. 而自己写过的代码,往往会印象比较深刻,在写的时候也会比较容易理解流程. 所以我们在看代码的同时, 如果能修改代码, 在手机上跑起来并看到修改的效果,这无疑会加快看代码的效率和积极性. 所以这篇文章,就讲解一下如何自己编译AndroidL的源码,并且在Nexus5上跑起来. 至于为何需要自己编译固件,而不是直接安装Google给出的工厂固件?原因是Google给出的工厂固件是User版本,是没法随心所欲Push东西进去的. 所以我们需要编译自己的Userdebug版本.</p>
<p>本文假设你已经下载了AndroidL的源码,并且有一台Nexus5手机(手机系统开发人员必备), 如果你还没有AndroidL的源码,或者你有源码但是没有配置编译的环境,那么 <a href="https://source.android.com/source/initializing.html" target="_blank" rel="external">Initializing a Build Environment</a> 和<a href="https://source.android.com/source/downloading.html" target="_blank" rel="external">Downloading the Source</a>这两篇文章你应该先去看一下(我又一次假设你会翻墙,如果你不会翻墙,那么下代码也是一个痛苦的事情). 这后面的教程Google官网也有教程.所以我只针对Nexus5进行讲解.</p>
<p>另外你需要知道AOSP,AOSP即Android Open Source Project 汉语意思是：谷歌开放源代码项目.我们通过Google官方下载的源代码,就是AOSP的代码, 其中是不包含Google开发的那些个应用的,各个厂商拿到的也是这个版本,在这个版本的基础上进行修改. 而Google发布的工厂固件则是包含全套Google服务的. 厂商如果想安装Google服务,就需要过Google的那一套认证,比较麻烦,而且价格不菲,鉴于Google在国内的尴尬地位,国内很多厂商都没有过这个认证.</p>
<a id="more"></a>
<h3 id="1-_初始化编译环境">1. 初始化编译环境</h3><pre class="lang:java decode:true "> . build/envsetup.sh</pre>

<h3 id="2-_加载机型">2. 加载机型</h3><pre class="lang:java decode:true ">lunch</pre>

<h3 id="3-_选择要编译的机器">3. 选择要编译的机器</h3><pre class="lang:java decode:true">You're building on Linux

Lunch menu... pick a combo:
     1\. aosp_arm-eng
     2\. aosp_arm64-eng
     3\. aosp_mips-eng
     4\. aosp_mips64-eng
     5\. aosp_x86-eng
     6\. aosp_x86_64-eng
     7\. aosp_shamu-userdebug
     8\. aosp_manta-userdebug
     9\. full_fugu-userdebug
     10\. aosp_fugu-userdebug
     11\. aosp_grouper-userdebug
     12\. aosp_tilapia-userdebug
     13\. aosp_deb-userdebug
     14\. aosp_flo-userdebug
     15\. aosp_mako-userdebug
     16\. aosp_hammerhead-userdebug
     17\. aosp_flounder-userdebug
     18\. mini_emulator_x86_64-userdebug
     19\. mini_emulator_arm-userdebug
     20\. mini_emulator_x86-userdebug
     21\. mini_emulator_mips-userdebug
     22\. mini_emulator_arm64-userdebug</pre>

<h4 id="3-1_机型对照表">3.1 机型对照表</h4><table>
<thead>
<tr>
<th>DEVICE</th>
<th>CODE NAME</th>
<th>BUILD CONFIGURATION</th>
</tr>
</thead>
<tbody>
<tr>
<td>Nexus 6</td>
<td>shamu</td>
<td>aosp_shamu-userdebug</td>
</tr>
<tr>
<td>Nexus Player</td>
<td>fugu</td>
<td>aosp_fugu-userdebug</td>
</tr>
<tr>
<td>Nexus 9</td>
<td>volantis (flounder)</td>
<td>aosp_flounder-userdebug</td>
</tr>
<tr>
<td>Nexus 5 (GSM/LTE)</td>
<td>hammerhead</td>
<td>aosp_hammerhead-userdebug</td>
</tr>
<tr>
<td>Nexus 7 (Wi-Fi)</td>
<td>razor (flo)</td>
<td>aosp_flo-userdebug</td>
</tr>
<tr>
<td>Nexus 7 (Mobile)</td>
<td>razorg (deb)</td>
<td>aosp_deb-userdebug</td>
</tr>
<tr>
<td>Nexus 10</td>
<td>mantaray (manta)</td>
<td>full_manta-userdebug</td>
</tr>
<tr>
<td>Nexus 4</td>
<td>occam (mako)</td>
<td>full_mako-userdebug</td>
</tr>
<tr>
<td>Nexus 7 (Wi-Fi)</td>
<td>nakasi (grouper)</td>
<td>full_grouper-userdebug</td>
</tr>
<tr>
<td>Nexus 7 (Mobile)</td>
<td>nakasig (tilapia)</td>
<td>full_tilapia-userdebug</td>
</tr>
<tr>
<td>Galaxy Nexus (GSM/HSPA+)</td>
<td>yakju (maguro)</td>
<td>full_maguro-userdebug</td>
</tr>
<tr>
<td>Galaxy Nexus (Verizon)</td>
<td>mysid (toro)</td>
<td>aosp_toro-userdebug</td>
</tr>
<tr>
<td>Galaxy Nexus (Experimental)</td>
<td>mysidspr (toroplus)</td>
<td>aosp_toroplus-userdebug</td>
</tr>
<tr>
<td>PandaBoard (Archived)</td>
<td>panda</td>
<td>aosp_panda-userdebug</td>
</tr>
<tr>
<td>Motorola Xoom (U.S. Wi-Fi)</td>
<td>wingray</td>
<td>full_wingray-userdebug</td>
</tr>
<tr>
<td>Nexus S</td>
<td>soju (crespo)</td>
<td>full_crespo-userdebug</td>
</tr>
<tr>
<td>Nexus S 4G</td>
<td>sojus (crespo4g)</td>
<td>full_crespo4g-userdebug3.2</td>
</tr>
</tbody>
</table>
<h4 id="3-2_三个版本说明版本">3.2 三个版本说明版本</h4><table>
<thead>
<tr>
<th>BUILDTYPE</th>
<th>USE</th>
</tr>
</thead>
<tbody>
<tr>
<td>user</td>
<td>limited access; suited for production</td>
</tr>
<tr>
<td>userdebug</td>
<td>like “user” but with root access and debuggability; preferred for debugging</td>
</tr>
<tr>
<td>eng</td>
<td>development configuration with additional debugging tools</td>
</tr>
</tbody>
</table>
<p>选择aosp_hammerhead-userdebug之后,会有下面的确认信息:</p>
<pre class="lang:java decode:true ">============================================
PLATFORM_VERSION_CODENAME=REL
PLATFORM_VERSION=5.0.50.50.50.50
TARGET_PRODUCT=aosp_hammerhead
TARGET_BUILD_VARIANT=userdebug
TARGET_BUILD_TYPE=release
TARGET_BUILD_APPS=
TARGET_ARCH=arm
TARGET_ARCH_VARIANT=armv7-a-neon
TARGET_CPU_VARIANT=krait
TARGET_2ND_ARCH=
TARGET_2ND_ARCH_VARIANT=
TARGET_2ND_CPU_VARIANT=
HOST_ARCH=x86_64
HOST_OS=linux
HOST_OS_EXTRA=Linux-3.13.0-37-generic-x86_64-with-Ubuntu-14.10-utopic
HOST_BUILD_TYPE=release
BUILD_ID=AOSP
OUT_DIR=out
============================================</pre>

<h3 id="4-_生成驱动目录">4. 生成驱动目录</h3><p>接下来需要在<a href="https://developers.google.com/android/nexus/drivers#hammerheadlrx22c" target="_blank" rel="external">Android官网</a>下载 Nexus5所需要的驱动:</p>
<table>
<thead>
<tr>
<th>HARDWARE COMPONENT</th>
<th>COMPANY</th>
<th>DOWNLOAD</th>
<th>MD5 CHECKSUM</th>
<th>SHA-1 CHECKSUM</th>
</tr>
</thead>
<tbody>
<tr>
<td>NFC, Bluetooth, Wi-Fi</td>
<td>Broadcom</td>
<td><a href="https://dl.google.com/dl/android/aosp/broadcom-hammerhead-lrx22c-964d941e.tgz" target="_blank" rel="external">Link</a></td>
<td>2c398994e37093df51b105d63f0eb611</td>
<td>991346159c95ae75f760014a6822b8b3e8667700</td>
</tr>
<tr>
<td>Camera, Sensors, Audio</td>
<td>LG</td>
<td><a href="https://dl.google.com/dl/android/aosp/lge-hammerhead-lrx22c-95a9d465.tgz" target="_blank" rel="external">Link</a></td>
<td>74cf8235e6bb04da28b2ff738b13eee9</td>
<td>175dd5bae81bb54030d072cb0f0b4ec81eb3f71f</td>
</tr>
<tr>
<td>Graphics, GSM, Camera, GPS, Sensors, Media, DSP, USB</td>
<td>Qualcomm</td>
<td><a href="https://dl.google.com/dl/android/aosp/lge-hammerhead-lrx22c-95a9d465.tgz" target="_blank" rel="external">Link</a></td>
<td>0a43395e175d3de3dc312d8abdcb4f20</td>
<td>007cf9d49f0409d5c703e7f2811fd153fee22353</td>
</tr>
</tbody>
</table>
<p>下载完成后,解压出来是三个.sh文件,放到Android源码目录下面,然后执行.会将相关驱动放到vender目录下面.</p>
<h3 id="5-_执行编译命令">5. 执行编译命令</h3><pre class="lang:java decode:true">make -j8</pre>
如果没有出错的话,在经过漫长的时间之后,编译成功:
<pre class="lang:java decode:true " title="编译成功">Installed file list: out/target/product/hammerhead/installed-files.txt
Target system fs image: out/target/product/hammerhead/obj/PACKAGING/systemimage_intermediates/system.img
Running:  mkuserimg.sh -s out/target/product/hammerhead/system out/target/product/hammerhead/obj/PACKAGING/systemimage_intermediates/system.img ext4 system 1073741824 -L system out/target/product/hammerhead/root/file_contexts
make_ext4fs -s -T -1 -S out/target/product/hammerhead/root/file_contexts -L system -l 1073741824 -a system out/target/product/hammerhead/obj/PACKAGING/systemimage_intermediates/system.img out/target/product/hammerhead/system
Creating filesystem with parameters:
    Size: 1073741824
    Block size: 4096
    Blocks per group: 32768
    Inodes per group: 8192
    Inode size: 256
    Journal blocks: 4096
    Label: system
    Blocks: 262144
    Block groups: 8
    Reserved block group size: 63
Created filesystem with 1445/65536 inodes and 85879/262144 blocks
Install system fs image: out/target/product/hammerhead/system.img
out/target/product/hammerhead/system.img+out/target/product/hammerhead/obj/PACKAGING/recovery_patch_intermediates/recovery_from_boot.p maxsize=1096212480 blocksize=135168 total=336629666 reserve=11083776
</pre>

<h3 id="6-_刷机命令">6. 刷机命令</h3><p>Nexus5关机状态下,长按音量下+电源,即可进入recovery模式, 然后在源码根目录下执行下面命令:</p>
<pre class="lang:java decode:true">fastboot -w flashall</pre>
刷机成功后会自动重启
<pre class="lang:java decode:true">~/Android-SourceCode fastboot -w flashall
target reported max download size of 1073741824 bytes
Creating filesystem with parameters:
    Size: 13725835264
    Block size: 4096
    Blocks per group: 32768
    Inodes per group: 8144
    Inode size: 256
    Journal blocks: 32768
    Label: 
    Blocks: 3351034
    Block groups: 103
    Reserved block group size: 823
Created filesystem with 11/838832 inodes and 93654/3351034 blocks
Creating filesystem with parameters:
    Size: 734003200
    Block size: 4096
    Blocks per group: 32768
    Inodes per group: 7472
    Inode size: 256
    Journal blocks: 2800
    Label: 
    Blocks: 179200
    Block groups: 6
    Reserved block group size: 47
Created filesystem with 11/44832 inodes and 5813/179200 blocks
--------------------------------------------
Bootloader Version...: HHZ12d
Baseband Version.....: M8974A-2.0.50.2.22
Serial Number........: 08ade1a513dc087b
--------------------------------------------
checking product...
OKAY [  0.100s]
sending 'boot' (8950 KB)...
OKAY [  0.500s]
writing 'boot'...
OKAY [  0.784s]
sending 'recovery' (9672 KB)...
OKAY [  0.556s]
writing 'recovery'...
OKAY [  0.814s]
erasing 'system'...
OKAY [  1.166s]
sending 'system' (328187 KB)...
OKAY [ 10.501s]
writing 'system'...
OKAY [ 23.623s]
erasing 'userdata'...
OKAY [ 14.657s]
sending 'userdata' (137318 KB)...
OKAY [  4.520s]
writing 'userdata'...
OKAY [  9.776s]
erasing 'cache'...
OKAY [  0.618s]
sending 'cache' (13348 KB)...
OKAY [  0.630s]
writing 'cache'...
OKAY [  1.070s]
rebooting...

finished. total time: 70.095s
</pre>

<h3 id="7-_秀桌面">7. 秀桌面</h3><h3 id=""><img src="http://www.androidperformance.com/wp-content/uploads/2015/02/Nexus5.png" alt="image"></h3>]]></content>
    <summary type="html">
    <![CDATA[<p>接前一篇文章<a href="http://www.androidperformance.com/view-android-source-code-with-androidstudio.html">使用Android Studio查看Android Lollipop源码</a>, 我们知道,仅仅看代码,提高是比较有限的,而且理解起来也比较肤浅,往往过目就忘. 而自己写过的代码,往往会印象比较深刻,在写的时候也会比较容易理解流程. 所以我们在看代码的同时, 如果能修改代码, 在手机上跑起来并看到修改的效果,这无疑会加快看代码的效率和积极性. 所以这篇文章,就讲解一下如何自己编译AndroidL的源码,并且在Nexus5上跑起来. 至于为何需要自己编译固件,而不是直接安装Google给出的工厂固件?原因是Google给出的工厂固件是User版本,是没法随心所欲Push东西进去的. 所以我们需要编译自己的Userdebug版本.</p>
<p>本文假设你已经下载了AndroidL的源码,并且有一台Nexus5手机(手机系统开发人员必备), 如果你还没有AndroidL的源码,或者你有源码但是没有配置编译的环境,那么 <a href="https://source.android.com/source/initializing.html">Initializing a Build Environment</a> 和<a href="https://source.android.com/source/downloading.html">Downloading the Source</a>这两篇文章你应该先去看一下(我又一次假设你会翻墙,如果你不会翻墙,那么下代码也是一个痛苦的事情). 这后面的教程Google官网也有教程.所以我只针对Nexus5进行讲解.</p>
<p>另外你需要知道AOSP,AOSP即Android Open Source Project 汉语意思是：谷歌开放源代码项目.我们通过Google官方下载的源代码,就是AOSP的代码, 其中是不包含Google开发的那些个应用的,各个厂商拿到的也是这个版本,在这个版本的基础上进行修改. 而Google发布的工厂固件则是包含全套Google服务的. 厂商如果想安装Google服务,就需要过Google的那一套认证,比较麻烦,而且价格不菲,鉴于Google在国内的尴尬地位,国内很多厂商都没有过这个认证.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之Systrace工具介绍(一)]]></title>
    <link href="http://androidperformance.com/2015/01/30/android-performance-tools-systrace-1/"/>
    <id>http://androidperformance.com/2015/01/30/android-performance-tools-systrace-1/</id>
    <published>2015-01-30T12:24:31.000Z</published>
    <updated>2015-03-27T05:27:06.000Z</updated>
    <content type="html"><![CDATA[<p> 本文是Android性能优化工具系列的第一篇，这个系列主要介绍Android性能优化过程中会使用到的一些工具，以及如何用这些工具来发现问题和解决问题。在性能优化方面，Android有不少性能工具供大家来使用，按照我们一贯地 “发现问题-解决问题”的思路来看，发现问题才是最主要的，一上来就想着如何去解决问题，反而会事倍功半。</p>
<p>这一篇先来简单介绍一下Systrace这个工具。</p>
<h2 id="0-Systrace简单介绍">0.Systrace简单介绍</h2><p>Systrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务，View系统等）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。</p>
<p>Systrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。在Android平台中，它主要由3部分组成：</p>
<ul>
<li>内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</li>
<li>数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。</li>
<li>数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录/tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。 从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用Android提供的Trace类来使用Systrace.<br>关于Systrace的官方介绍和使用可以看这里：<a href="http://developer.android.com/tools/help/systrace.html" title="SysTrace官方介绍" target="_blank" rel="external">Systrace</a></li>
</ul>
<a id="more"></a>
<h2 id="1-Systrace简单使用">1.Systrace简单使用</h2><p>使用Systrace前，要先了解一下Systrace在各个平台上的使用方法，鉴于大家使用Eclipse和Android Studio的居多，所以直接摘抄官网关于这个的使用方法，不过不管是什么工具，流程是一样的：</p>
<ul>
<li>手机准备好你要进行抓取的界面</li>
<li>点击开始抓取（命令行的话就是开始执行命令）</li>
<li>手机上开始操作</li>
<li>设定好的时间到了之后，会将生成Trace文件，使用Chrome将这个文件打开进行分析</li>
</ul>
<h3 id="Using_Eclipse">Using <strong>Eclipse</strong></h3><ol>
<li><p>In Eclipse, open an Android application project.</p>
<ol>
<li>Switch to the DDMS perspective, by selecting Window &gt; Perspectives &gt; DDMS.</li>
<li>In the Devices tab, select the device on which to run a trace. If no devices are listed, make sure your device is connected via USB cable and that debugging is enabled on the device.</li>
<li>Click the Systrace icon at the top of the Devices panel to configure tracing.</li>
<li>Set the tracing options and click OK to start the trace.</li>
</ol>
</li>
</ol>
<h3 id="Using_Android_Studio">Using <strong> Android Studio</strong></h3><ol>
<li><p>In Android Studio, open an Android application project.</p>
<ol>
<li>Open the Device Monitor by selecting Tools &gt; Android &gt; Monitor.</li>
<li>In the Devices tab, select the device on which to run a trace. If no devices are listed, make sure your device is connected via USB cable and that debugging is enabled on the device.</li>
<li>Click the Systrace icon at the top of the Devices panel to configure tracing.</li>
<li>Set the tracing options and click OK to start the trace.</li>
</ol>
</li>
</ol>
<h3 id="Using_Device_Monitor">Using <strong>Device Monitor</strong></h3><ol>
<li><p>Navigate to your SDK tools/ directory.</p>
<ol>
<li>Run the monitor program.</li>
<li>In the Devices tab, select the device on which to run a trace. If no devices are listed, make sure your device is connected via USB cable and that debugging is enabled on the device.</li>
<li>Click the Systrace icon at the top of the Devices panel to configure tracing.</li>
<li>Set the tracing options and click OK to start the trace.</li>
</ol>
</li>
</ol>
<h3 id="Command_Line_Usage">Command Line Usage</h3><p>命令行形式比较灵活，速度也比较快，一次性配置好之后，以后再使用的时候就会很快就出结果（<strong>强烈推荐</strong>）</p>
<p><pre class="lang:java decode:true ">$ cd android-sdk/platform-tools/systrace<br>$ python systrace.py —time=10 -o mynewtrace.html sched gfx view wm</pre><br>从上面的命令可以看到Systrace工具的位置，只需要在Bash中配置好对应的路径和Alias，使用起来还是很快速的。另外User版本是不可以抓Trace的，只有ENG版本或者Userdebug版本才可以。</p>
<p>抓取结束后，会生成对应的Trace文件，注意这个文件只能被Chrome打开。关于如何分析Trace文件，我们下面的章节会讲。不论使用那种工具，在抓取之前都会让选择参数，下面说一下这些参数的意思：</p>
<ul>
<li>-h, —help Show the help message.（帮助）</li>
<li>-o  Write the HTML trace report to the specified file.（即输出文件名，）</li>
<li>-t N, —time=N Trace activity for N seconds. The default value is 5 seconds. （Trace抓取的时间，一般是 ： -t 8）</li>
<li>-b N, —buf-size=N Use a trace buffer size of N kilobytes. This option lets you limit the total size of the data collected during a trace.</li>
<li>-k</li>
<li>—ktrace= Trace the activity of specific kernel functions, specified in a comma-separated list.</li>
<li><p>-l, —list-categories List the available tracing category tags. The available tags are(下面的参数不用翻译了估计大家也看得懂，贴官方的解释也会比较权威，后面分析的时候我们会看到这些参数的作业的):</p>
<ul>
<li><strong>gfx</strong> - Graphics</li>
<li><strong>input</strong> - Input</li>
<li><strong>view</strong> - View</li>
<li>webview - WebView</li>
<li><strong>wm</strong> - Window Manager</li>
<li><strong>am</strong> - Activity Manager</li>
<li>audio - Audio</li>
<li>video - Video</li>
<li>camera - Camera</li>
<li>hal - Hardware Modules</li>
<li>res - Resource Loading</li>
<li><strong>dalvik</strong> - Dalvik VM</li>
<li>rs - RenderScript</li>
<li><strong>sched</strong> - CPU Scheduling</li>
<li><strong>freq</strong> - CPU Frequency</li>
<li><strong>membus</strong> - Memory Bus Utilization</li>
<li><strong>idle</strong> - CPU Idle</li>
<li><strong>disk</strong> - Disk input and output</li>
<li><strong>load</strong> - CPU Load</li>
<li><strong>sync</strong> - Synchronization Manager</li>
<li><strong>workq</strong> - Kernel Workqueues Note: Some trace categories are not supported on all devices. Tip: If you want to see the names of tasks in the trace output, you must include the sched category in your command parameters.</li>
</ul>
</li>
<li><p>-a</p>
</li>
<li>—app= Enable tracing for applications, specified as a comma-separated list of package names. The apps must contain tracing instrumentation calls from the Trace class. For more information, see Analyzing Display and Performance.</li>
<li>—link-assets Link to the original CSS or JavaScript resources instead of embedding them in the HTML trace report.</li>
<li>—from-file= Create the interactive Systrace report from a file, instead of running a live trace.</li>
<li>—asset-dir= Specify a directory for the trace report assets. This option is useful for maintaining a single set of assets for multiple Systrace reports.</li>
<li>-e</li>
<li>—serial= Conduct the trace on a specific connected device, identified by its device serial number.<br>上面的参数虽然比较多，但使用工具的时候不需考虑这么多，在对应的项目前打钩即可，命令行的时候才会去手动加参数：</li>
</ul>
<p>我们一般会把这个命令配置成Alias，配置如下：</p>
<p><pre class="lang:java decode:true">alias st-start=’python /home/gaojianwu/Software/android-studio/sdk/platform-tools/systrace/systrace.py’<br>alias st-start-gfx-mx4 = ‘st-start -t 8 gfx input view sched freq wm am hwui workq res dalvik sync disk load perf hal rs idle mmc’</pre><br>&nbsp;</p>
<p><div class="highlighted-data monokai"></div><br>这样在使用的时候，可以直接敲 <strong>st-start-gfx-mx4</strong> 即可，当然为了区分和保持各个文件，还需要加上 <strong>-o xxx.Trace</strong> .上面的命令和参数不必一次就理解，只需要记住如何简单使用即可，在分析的过程中，这些东西都会慢慢熟悉的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p> 本文是Android性能优化工具系列的第一篇，这个系列主要介绍Android性能优化过程中会使用到的一些工具，以及如何用这些工具来发现问题和解决问题。在性能优化方面，Android有不少性能工具供大家来使用，按照我们一贯地 “发现问题-解决问题”的思路来看，发现问题才是最主要的，一上来就想着如何去解决问题，反而会事倍功半。</p>
<p>这一篇先来简单介绍一下Systrace这个工具。</p>
<h2 id="0-Systrace简单介绍">0.Systrace简单介绍</h2><p>Systrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务，View系统等）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。</p>
<p>Systrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。在Android平台中，它主要由3部分组成：</p>
<ul>
<li>内核部分：Systrace利用了Linux Kernel中的ftrace功能。所以，如果要使用Systrace的话，必须开启kernel中和ftrace相关的模块。</li>
<li>数据采集部分：Android定义了一个Trace类。应用程序可利用该类把统计信息输出给ftrace。同时，Android还有一个atrace程序，它可以从ftrace中读取统计信息然后交给数据分析工具来处理。</li>
<li>数据分析工具：Android提供一个systrace.py（python脚本文件，位于Android SDK目录/tools/systrace中，其内部将调用atrace程序）用来配置数据采集的方式（如采集数据的标签、输出文件名等）和收集ftrace统计数据并生成一个结果网页文件供用户查看。 从本质上说，Systrace是对Linux Kernel中ftrace的封装。应用进程需要利用Android提供的Trace类来使用Systrace.<br>关于Systrace的官方介绍和使用可以看这里：<a href="http://developer.android.com/tools/help/systrace.html" title="SysTrace官方介绍">Systrace</a></li>
</ul>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Android Studio查看Android Lollipop源码]]></title>
    <link href="http://androidperformance.com/2015/01/16/view-android-source-code-with-androidstudio/"/>
    <id>http://androidperformance.com/2015/01/16/view-android-source-code-with-androidstudio/</id>
    <published>2015-01-16T13:54:32.000Z</published>
    <updated>2015-03-27T05:25:47.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Android_Studio">Android Studio</h2><p>作为Google的亲儿子,Nexus手机系列所收到的待遇大家有目共睹.Android5.0出来之后,Nexus5第一时间就升级到了最新的系统.那么作为Google亲儿子的Android Studio同样备受Google的重视,我也是第一时间从Eclipse转投到了Android Studio的怀抱中,从最初的测试版本一路升级到现在的1.0正式版本(今天发布了1.1,果断已经升级了),关于Android Studio的好处我就不用说了,下面两点就足矣让你转投Android Studio了:</p>
<ul>
<li>Android Studio是Google官方指定的,目前官网已经去掉了ADT, 大家可以在<a href="\&quot;http://developer.android.com/sdk/installing/index.html\&quot;">Android开发者官网</a> 中进行查看,目前只有Android Studio提供下载了.</li>
<li>Google也表示ADT不再进行维护了.<br>转投Android Studio时大势所趋,网上关于如何使用Android Studio的帖子也是满天飞,所以我就不再啰嗦夸奖Android Studio了.看一下下面的图,估计你就会很有欲望了.想查看详细的内容,可以查看<a href="\&quot;http://developer.android.com/tools/studio/index.html\&quot;">Android Studio官方文档</a><div class="\&quot;image-package"><a href="http://www.androidperformance.com/wp-content/uploads/2015/01/androidstudio.png" target="_blank" rel="external"><img src="http://www.androidperformance.com/wp-content/uploads/2015/01/androidstudio.png" alt="androidstudio"></a><br><div class="\&quot;image-caption\&quot;">Android Studio Preview</div><br></div>

</li>
</ul>
<a id="more"></a>
<h2 id="Android_5-0_:_Lollipop">Android 5.0 : Lollipop</h2><p>Android Lollipop是Google在今年推出的,关于Lollipop的详细介绍可以查看<a href="\&quot;http://developer.android.com/about/versions/lollipop.html\&quot;">Lollipop官方介绍</a> ,我也就不多说了.作为一个开发者,我们不应该停留在表面(即Lollipop的绚丽的界面,和新奇的设计语言<a href="\&quot;http://developer.android.com/about/versions/lollipop.html#Material\&quot;">Material design</a>),我们更要了解其中的原理.</p>
<h2 id="准备工作">准备工作</h2><p>在使用Android Studio查看源码之前,你需要做下面几件事:</p>
<ul>
<li>下载Android Lollipop源码(当然不一定非要是Lollipop源码,其他的版本也是可以的)</li>
<li>进行过一次完整编译(不编译是无法进行源码导入工作的)<br>以上操作可以参考<a href="\&quot;https://source.android.com/source/initializing.html\&quot;">Google 官方教程</a> 以确保万无一失(呵呵).上面的几个链接需要翻墙才可以访问,不过有兴趣看这篇文章的人,大部分应该都是知道VPN的.或者没有VPN不会翻墙的,速度去卖一个VPN,能花钱解决的事情,就不要花时间.</li>
</ul>
<h2 id="开始">开始</h2><ul>
<li>进入Android 源码根目录</li>
<li>执行<br><code>mmm development/tools/idegen/</code><br>这行命令的意思是编译idegen这个项目,生成idegen.jar文件.生成成功后,会显示这个jar包的位置,并显示 <code>#### make completed successfully (43 seconds) ####</code> ,如果编译失败了,后面会讲到这种情况(比较少见)</li>
<li>执行<br><code>sh ./development/tools/idegen/idegen.sh</code><br>这行命令的意思是生成对应的文件:android.iws, android.ipr, android.iml .如果生成失败,后面也会讲到这种情况.</li>
<li>生成对应的文件后,打开Android Studio,选择打开一个现有的Android Studio项目,选择Android源码的根目录,导入即可(起作用的是android.irp文件).在配置sdk版本之后就可以查看Android 源码了.</li>
<li>已经完成了,没有下一步了.</li>
</ul>
<h2 id="问题">问题</h2><ul>
<li><p>执行第一个命令的时候编译不过,出现这种情况的原因有好几种:</p>
<ul>
<li>Android 源码没有下载完全</li>
<li>没有进行全部编译</li>
<li>环境变量配置有问题解决方法依问题而定,网上对应的帖子很多,可以自己去找. 推荐这种问题还是去<a href="\&quot;http://www.jianshu.com/p/www.google.com\&quot;">Google</a> 和<a href="\&quot;http://www.jianshu.com/p/www.stackoverflow.com\&quot;">StackOverFlow</a> 上去问.</li>
</ul>
</li>
<li><p>执行第二个命令的时候,碰到下面的问题:</p>
<p>Exception in thread \”main\” java.io.FileNotFoundException: ./out/target/product/hammerhead/obj/GYP/shared_intermediates/res.java (Is a directory)<br>at java.io.FileInputStream.open(Native Method)<br>at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:138)<br>at java.io.FileReader.&lt;init&gt;(FileReader.java:72)<br>at Configuration.parsePackageName(Configuration.java:204)<br>at Configuration.rootOf(Configuration.java:180)<br>at Configuration.traverse(Configuration.java:140)<br>at Configuration.traverse(Configuration.java:167)<br>at Configuration.traverse(Configuration.java:167)<br>at Configuration.traverse(Configuration.java:167)<br>at Configuration.traverse(Configuration.java:167)<br>at Configuration.traverse(Configuration.java:167)<br>at Configuration.traverse(Configuration.java:167)<br>at Configuration.traverse(Configuration.java:167)<br>at Configuration.&lt;init&gt;(Configuration.java:72)<br>at Main.main(Main.java:37)</p>
</li>
</ul>
<p>解决办法是将<br><code>./out/target/product/hammerhead/obj/GYP/shared_intermediates/res.java</code><br>修改为:<br><code>./out/target/product/hammerhead/obj/GYP/shared_intermediates/res.j</code><br>即可.</p>
<h2 id="后记">后记</h2><p>使用Android Studio看Android源码很爽，下面是他们的优缺点：</p>
<h4 id="优点">优点</h4><ul>
<li>和Android 完美结合</li>
<li>代码提示很全</li>
<li>代码跳转很强</li>
<li>IDE比Eclipse好看(我说的是黑色主题)</li>
<li>插件很强大(底层是IDEA你懂得)</li>
<li>免费(SourceInsight负分,啥?你用的破解版? 当我没说)</li>
</ul>
<h4 id="缺点">缺点</h4><ul>
<li>对C＋＋代码的支持不是很好</li>
<li>有一定的上手难度<br>本文简书地址：<a href="\&quot;http://www.jianshu.com/p/c85984cf99e2\&quot;">http://www.jianshu.com/p/c85984cf99e2 </a>欢迎大家点喜欢<blockquote>
<p>作者：<a href="\&quot;http://weibo.com/1315612820/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo\&quot;" title="\&quot;个人微博\&quot;">Gracker</a></p>
<p>出处：<a href="\&quot;http://www.androidperformance.com/\&quot;" title="\&quot;网站主页\&quot;">androidperformance.com</a></p>
<p>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
<p>打赏一下： <a href="\&quot;http://weibo.com/p/1001603801588257955883?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod\&quot;">微博打赏</a></p>
</blockquote>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Android_Studio">Android Studio</h2><p>作为Google的亲儿子,Nexus手机系列所收到的待遇大家有目共睹.Android5.0出来之后,Nexus5第一时间就升级到了最新的系统.那么作为Google亲儿子的Android Studio同样备受Google的重视,我也是第一时间从Eclipse转投到了Android Studio的怀抱中,从最初的测试版本一路升级到现在的1.0正式版本(今天发布了1.1,果断已经升级了),关于Android Studio的好处我就不用说了,下面两点就足矣让你转投Android Studio了:</p>
<ul>
<li>Android Studio是Google官方指定的,目前官网已经去掉了ADT, 大家可以在<a href="\&quot;http://developer.android.com/sdk/installing/index.html\&quot;">Android开发者官网</a> 中进行查看,目前只有Android Studio提供下载了.</li>
<li>Google也表示ADT不再进行维护了.<br>转投Android Studio时大势所趋,网上关于如何使用Android Studio的帖子也是满天飞,所以我就不再啰嗦夸奖Android Studio了.看一下下面的图,估计你就会很有欲望了.想查看详细的内容,可以查看<a href="\&quot;http://developer.android.com/tools/studio/index.html\&quot;">Android Studio官方文档</a><div class="\&quot;image-package"><a href="http://www.androidperformance.com/wp-content/uploads/2015/01/androidstudio.png"><img src="http://www.androidperformance.com/wp-content/uploads/2015/01/androidstudio.png" alt="androidstudio"></a><br><div class="\&quot;image-caption\&quot;">Android Studio Preview</div><br></div>

</li>
</ul>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之过渡绘制( 二)]]></title>
    <link href="http://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2/"/>
    <id>http://androidperformance.com/2015/01/13/android-performance-optimization-overdraw-2/</id>
    <published>2015-01-13T11:38:53.000Z</published>
    <updated>2015-03-27T05:26:55.000Z</updated>
    <content type="html"><![CDATA[<p>上一篇<a href="\&quot;http://www.androidperformance.com/android-performance-optimization-overdraw-1.html\&quot;">文章</a>从理论的角度讲解了一下什么是过渡绘制，以及可以用来查看和确认过渡绘制的工具，还提供了一些优化过渡绘制的方法。对代码和布局比较熟悉的人，看完上一篇其实就已经可以对自己的应用进行优化了。我记得有人说过，用iphone你只需要保证苹果有节操即可，用Android你就得保证所有的Android开发者都有节操。但现实是残酷的，现在Android市场上，有很多粗制滥造的应用，其中不乏大厂之作，各位打开过渡绘制按钮，就知道我所言非虚。作为一个Android开发人员，我肯定是更希望Android能一步一步好起来，超越iphone。</p>
<p>这篇文章从实战的角度，讲解了一个过渡绘制的优化过程。当然这里用到的只是很少的一部分，毕竟每个应用差别很大，优化方式也各不一样。所以这篇文章仅供参考，想把这块做好还是要下功夫的。不过令我比较欣慰的是，在公司内推行这个优化之后，我们Flyme内部的自带应用已经做得很好了，当然还是有不少界面有优化的空间，但总体还是比较满意的。</p>
<p>如果没有看过前一篇，可以点这里：<a href="\&quot;http://www.androidperformance.com/android-performance-optimization-overdraw-1.html\&quot;" title="\&quot;Android性能优化之过渡绘制(一)\&quot;">Android性能优化之过渡绘制(一)</a></p>
<a id="more"></a>
<p>话不多说，来看正文吧：</p>
<h3 id="1-测试用例说明">1.测试用例说明</h3><h4 id="1-测试机器:">1.测试机器:</h4><ol>
<li>测试机器:MX3(M351)</li>
<li>固件:meizu_mx3-eng 4.4.4 KTU84P m35x.Flyme_OS_3.6.1 20140717113944 test-keys</li>
</ol>
<h4 id="2-测试应用:">2.测试应用:</h4><ol>
<li>设置</li>
<li>文件管理器</li>
</ol>
<h4 id="3-检测和消除过渡绘制的一般步骤:">3.检测和消除过渡绘制的一般步骤:</h4><ol>
<li>定位过渡绘制区域</li>
<li><p>利用Android提供的工具进行位置确认以及修改(HierarchyView , Tracer for OpenGL ES)</p>
<ol>
<li>定位到具体的视图(xml文件或者View)</li>
<li>通过代码和xml文件分析过渡绘制的原因</li>
<li>结合具体情况进行优化</li>
</ol>
</li>
<li><p>使用Lint工具进一步优化</p>
</li>
</ol>
<h4 id="4-面向人群:">4.面向人群:</h4><ol>
<li>开发人员:定位到自己负责的app之后,查看过渡绘制情况,然后针对性地进行优化(涉及到xml布局修改和Java代码的修改)</li>
<li>测试人员:打开gpu过渡绘制之后,就可以查看各个应用是否优化完成.</li>
</ol>
<h4 id="5-备注:">5.备注:</h4><ol>
<li>本教程以MX3为模板,可能有的应用在MX4上换了UI或者公共控件,所以看到的和下面的例子中呈现的不一样. 但是大概的流程的一样的,悉知.</li>
<li>如有说的不清楚的地方或者说的不对的地方,请及时与我联系,我会及时更正.谢谢.</li>
</ol>
<h3 id="2-具体步骤">2.具体步骤</h3><h5 id="2-1-定位过渡绘制区域">2.1.定位过渡绘制区域</h5><ol>
<li>打开GPU过渡绘制选项:<br>设置—辅助功能—开发人员工具—硬件加速渲染—调试GPU过渡绘制— 显示过渡绘制区域. (打开开发者模式需要在电话界面输入: <em>#</em>#6961#<em>#</em> :注：仅魅族，其余手机方法各异，点击版本号5次也比较常见))</li>
<li>Kill掉(即清后台)要测试的应用,重新打开就可以看到效果.下面以魅族Flyme3文件管理器和设置为例子,如下图<br><a href="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/S40723-094617.jpg\&quot;"><img src="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/S40723-094617.jpg\&quot;" alt="\&quot;S40723-094617\&quot;"></a>  <a href="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/S40723-110629.jpg\&quot;"><img src="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/S40723-110629.jpg\&quot;" alt="\&quot;S40723-110629\&quot;"></a><br>从图上可以看出,按照过渡绘制从好到坏(蓝-绿-粉红-红)来看,文件管理器的过渡绘制是非常严重的,而设置界面的过渡绘制则在可以接受的范围内.下面就以文件管理器为主要分析对象,来看看如何对文件管理器的过渡绘制进行优化.</li>
<li><p>从文件管理器的图,分析出过渡绘制区域:.</p>
<ol>
<li>首先看最上面的ActionBar和最下面的SmartBar,对比设置界面的ActionBar就可以知道,整个文件管理器存在一个不透明的背景,导致每次绘制时,都要先绘制这个看不见且不透明的背景.这个背景一般是应用的主题自带的背景,所以GPU过渡绘制显示其位蓝色,这个背景是可以进行优化的.</li>
<li>中间的内容部分,最底层是绿色,说明进行了2x的过渡绘制,去掉第一条我们提的那个全局背景,还有一层背景,也就是1x的过渡绘制,对比setting可知,这个背景色也是可以去掉的.</li>
<li>最容易看出的是这两条,我们先分析和优化这两条,然后再进行其他的优化.</li>
</ol>
</li>
</ol>
<h5 id="2-2-_使用工具进行位置确认:大概确定了过渡绘制的区域后,让我们来使用工具来进行验证和View确认-">2.2. 使用工具进行位置确认:大概确定了过渡绘制的区域后,让我们来使用工具来进行验证和View确认.</h5><ol>
<li>打开Monitor(Eclipse和Android Studio中都有快捷打开按钮,即DDMS,)</li>
<li>右上角选择 Hierarchy View,大概使用如图<br><a href="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/Image.png\&quot;"><img src="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/Image.png\&quot;" alt="\&quot;Image\&quot;"></a><br>根节点:PhoneWindos$DecorView是整个视图的根节点,唯一的子节点是ActionBarOverlayLayout,这个Layout包含了ActionBar,应用程序,以及SmartBar.</li>
<li><p>从Hierarchy View结合代码分析出需要进行修改的区域</p>
<ol>
<li><p>上面分析过渡绘制区域的第一条,整个window存在一个背景,所以进行了一次重绘,这个背景的重绘是系统级别的,和主题有关,即这个背景是属于ActionBarOverlayLayout的.这种类型的过渡绘制解决也比较方便,在文件管理器的主Activity的onCreate方法中,加入<br><div class="\&quot;highlighted-data"></div></p>
<div class="\&quot;highlight\&quot;">

<p><span id="\&quot;LC1\&quot;" class="\&quot;line\&quot;"><span class="\&quot;hljs-keyword\&quot;">this</span>.getWindow().setBackgroundDrawableResource(android.R.color.transparent);</span><br><span id="\&quot;LC2\&quot;" class="\&quot;line\&quot;"></span></p>
</div></li>
</ol>
</li>
</ol>
<p><br><br>就可以将这个看不见的主题背景去掉.下面是去掉主题背景后的效果图(一张是划开,一张是没有划开):<br><a href="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/S40723-094435.jpg\&quot;"><img src="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/S40723-094435.jpg\&quot;" alt="\&quot;S40723-094435\&quot;"></a>     <a href="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/S40723-094445.jpg\&quot;"><img src="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/S40723-094445.jpg\&quot;" alt="\&quot;S40723-094445\&quot;"></a><br>对比优化前的图可以发现,背景被去掉之后,少了一层过渡绘制. ActionBar上的蓝色已经消失了.中间的内容由绿色变为蓝色,SmartBar也少了层(SmartBar在只显示返回和menu的时候,过渡绘制不是很严重,一旦增加了其他的icon,就会出现很严重的过渡绘制,这个需要注意,后续也会针对SmartBar进行优化)</p>
<pre><code>2.  上面分析的第二条说”<span class="keyword">*</span><span class="keyword">*</span>中间的内容部分,最底层是绿色,说明进行了2x的过渡绘制<span class="keyword">*</span><span class="keyword">*</span>”,现在中间部分变成了蓝色,但是这是一个全局的背景,导致右边的view拉过来之后,还是存在大量的红色和绿色. 继续分析Hierarchy View,找到中间view对应的视图:DragRelativeLayout,查看源码可知,DragRelativeLayout继承自公共控件:SlidingMenu ，SlidingMenu 由CustomViewAbove和CustomViewBehind组成,前者是上面可以左右拉动的那部分,后者是底部不能拉动的那部分(这个从HierarchyView中也可以看出来:如下图所示:
</code></pre><p><a href="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/Image1.png\&quot;"><img src="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/Image1.png\&quot;" alt="\&quot;Image\&quot;"></a><br>点击CustomViewBehind,查看其所占的区域,就可以发现背景是这个View进行绘制的,打开CustomViewBehind的代码可以发现其构造函数中包含下面的代码:setBackgroundColor(getResources().getColor(R.color.mz_slidingmenu_background_light));这个背景是不需要的,查看源码可知,这个view会在SlidingMenu.setMenu的时候,被覆盖掉,还是看不到的.所以这一层view是可以去掉的.下面是去掉一层背景之后的预览图:<br><a href="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/S40723-105228.jpg\&quot;"><img src="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/S40723-105228.jpg\&quot;" alt="\&quot;S40723-105228\&quot;"></a>  <img src="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/S40723-105302.jpg\&quot;" alt="\&quot;S40723-105302\&quot;"><br>可以看到这一层背景去掉之后,过渡绘制减轻了很多.</p>
<pre><code><span class="number">3</span>.  接着进行分析,可以看到CustomViewAbove也是存在一个过渡绘制的背景的,查看Hierarchy View的CustomViewAbove的子节点,可以看到过渡绘制是由ListView导致的.其id为:FilesList,在代码中找到它,并对他进行分析.在我将PartitionItemLayout中<span class="function"><span class="title">onDraw</span><span class="params">()</span></span>函数的setBounds去掉之后,过渡绘制进一步改善了(但是ListItem的View的颜色也比之前要浅了,这一步优化需要根据具体情况进行) 下面是优化后的效果图:
</code></pre><p><a href="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/S40723-152357.jpg\&quot;"><img src="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/S40723-152357.jpg\&quot;" alt="\&quot;S40723-152357\&quot;"></a>   <a href="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/S40723-152404.jpg\&quot;"><img src="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/S40723-152404.jpg\&quot;" alt="\&quot;S40723-152404\&quot;"></a><br>可以看到图中的过渡绘制已经非常少了.!点个赞!</p>
<h4 id="2-3_使用Lint工具进行进一步优化">2.3 使用Lint工具进行进一步优化</h4><ol>
<li>Lint工具的使用比较简单,根据给出的提示做对应的修改即可.有时候需要工具具体情况来确定是否需要修改. 下图是一个简单地例子.箭头处提示这个Layout或者它的父Layout是不必须的.具体修改方法即去掉FrameLayout,将RelativeLayout提升为根VIew即可.<br><a href="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/Image2.png\&quot;"><img src="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/Image2.png\&quot;" alt="\&quot;Image\&quot;"></a></li>
<li><p>Lint工具还会针对代码中潜在的不合理或者Bed Code做出修改意见.比较重要的提示包括</p>
<ol>
<li>声明但是没有使用的变量</li>
<li>可能会产生的空指针</li>
<li>没必要书写的return,continue</li>
<li>复杂代码的简化写法</li>
<li>for循环的简化写法:foreach</li>
<li>无效的判空</li>
<li>空if</li>
<li>无效或者未使用的import</li>
</ol>
</li>
</ol>
<h4 id="2-4_使用Tracer_For_OpenGL_ES工具查看每一帧的draw情况-">2.4 使用Tracer For OpenGL ES工具查看每一帧的draw情况.</h4><ol>
<li>Tracer工具也在Android Device Monitor中.点击右上角的Tracer for OpenGL ES按钮就可以进入(如果没有这个按钮,点击旁边的Open Perspective按钮,从选项中选择Tracer for OpenGL ES即可).</li>
<li>初次打开Tracer工具,里面是没有内容的,点击右上角的两个按钮(一个是打开现有的GLTrace文件,另一个是新建GLTrace文件)<br>点击Trace按钮, 手机会自动启动应用程序并启动对应的Activity,当手机上的内容完全绘制出来之后,就可以点击Stop按钮,生成GlTrace文件.文件会自动打开.<br><a href="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/Image3.png\&quot;"><img src="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/Image3.png\&quot;" alt="\&quot;Image\&quot;"></a></li>
<li>分析GLTrace文件<br>这张图是优化过后的图,对比优化前的图可以发现,优化后不会去绘制默认的背景图和CustomViewBehind的背景图.<br><a href="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/Image4.png\&quot;"><img src="\&quot;http://www.androidperformance.com/wp-content/uploads/2015/01/Image4.png\&quot;" alt="\&quot;Image\&quot;"></a><br>这只是一帧的绘制,如果多操作几下生成多个帧的绘制trace文件,会发现这两个背景会被多次的重绘,去掉后不仅会减轻过渡绘制,也会加快GUP的绘制速度.</li>
</ol>
<h3 id="3-优化建议">3.优化建议</h3><ol>
<li>ActionBar上有蓝色(紫色)说明appWindow绘制了一层背景,这层背景是可以去掉的.参考上面的教程.</li>
<li>公共控件的背景重绘请公共控件的负责人关注一下.(SmartBar在只有两个图标(back,menu)时,不存在过渡绘制,一旦加上其他的按钮,就会出现比较严重的过渡绘制,这个需要注意一下.)</li>
</ol>
<h3 id="4-其他参考资料">4.其他参考资料</h3><ol>
<li><a href="\&quot;http://blog.chengyunfeng.com/?p=458#\&quot;">http://blog.chengyunfeng.com/?p=458#</a> 翻译的一个老外的优化过程 (原链接<a href="\&quot;http://www.curious-creature.org/2012/12/01/android-performance-case-study/\&quot;">http://www.curious-creature.org/2012/12/01/android-performance-case-study/</a>)</li>
<li><a href="\&quot;http://blog.csdn.net/yihongyuelan/article/details/12169647\&quot;">http://blog.csdn.net/yihongyuelan/article/details/12169647</a> 反编译并添加gpu显示</li>
<li><a href="\&quot;http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect\&quot;">http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect</a> 官网资料</li>
<li><a href="\&quot;http://developer.android.com/training/improving-layouts/reusing-layouts.html\&quot;">http://developer.android.com/training/improving-layouts/reusing-layouts.html</a> 官网资料</li>
<li><a href="\&quot;http://developer.android.com/training/improving-layouts/loading-ondemand.html\&quot;">http://developer.android.com/training/improving-layouts/loading-ondemand.html</a> 官网资料</li>
<li><a href="\&quot;http://developer.android.com/training/improving-layouts/smooth-scrolling.html\&quot;">http://developer.android.com/training/improving-layouts/smooth-scrolling.html</a> 官网资料</li>
<li><a href="\&quot;http://developer.android.com/tools/help/hierarchy-viewer.html\&quot;">http://developer.android.com/tools/help/hierarchy-viewer.html</a> 官网关于hierarchy view的介绍</li>
<li><a href="\&quot;http://tools.android.com/tips/lint\&quot;">http://tools.android.com/tips/lint</a> lint工具介绍<blockquote>
<p>作者：<a href="\&quot;http://weibo.com/1315612820/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo\&quot;" title="\&quot;个人微博\&quot;">Gracker</a></p>
<p>出处：<a href="\&quot;http://www.androidperformance.com/\&quot;" title="\&quot;网站主页\&quot;">androidperformance.com</a></p>
<p>本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</p>
<p>打赏一下： <a href="\&quot;http://weibo.com/p/1001603801588257955883?from=page_100505_profile&amp;wvr=6&amp;mod=wenzhangmod\&quot;">微博打赏</a></p>
</blockquote>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>上一篇<a href="\&quot;http://www.androidperformance.com/android-performance-optimization-overdraw-1.html\&quot;">文章</a>从理论的角度讲解了一下什么是过渡绘制，以及可以用来查看和确认过渡绘制的工具，还提供了一些优化过渡绘制的方法。对代码和布局比较熟悉的人，看完上一篇其实就已经可以对自己的应用进行优化了。我记得有人说过，用iphone你只需要保证苹果有节操即可，用Android你就得保证所有的Android开发者都有节操。但现实是残酷的，现在Android市场上，有很多粗制滥造的应用，其中不乏大厂之作，各位打开过渡绘制按钮，就知道我所言非虚。作为一个Android开发人员，我肯定是更希望Android能一步一步好起来，超越iphone。</p>
<p>这篇文章从实战的角度，讲解了一个过渡绘制的优化过程。当然这里用到的只是很少的一部分，毕竟每个应用差别很大，优化方式也各不一样。所以这篇文章仅供参考，想把这块做好还是要下功夫的。不过令我比较欣慰的是，在公司内推行这个优化之后，我们Flyme内部的自带应用已经做得很好了，当然还是有不少界面有优化的空间，但总体还是比较满意的。</p>
<p>如果没有看过前一篇，可以点这里：<a href="\&quot;http://www.androidperformance.com/android-performance-optimization-overdraw-1.html\&quot;" title="\&quot;Android性能优化之过渡绘制(一)\&quot;">Android性能优化之过渡绘制(一)</a></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android性能优化之过渡绘制(一)]]></title>
    <link href="http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/"/>
    <id>http://androidperformance.com/2014/10/20/android-performance-optimization-overdraw-1/</id>
    <published>2014-10-20T15:19:23.000Z</published>
    <updated>2015-03-27T05:26:48.000Z</updated>
    <content type="html"><![CDATA[<p>博客有一段时间没有更新了，到了新公司后，一直比较忙，博客也更新地不那么频繁了，倒是利用这个VPS搭建的VPN每天都在用，速度也蛮不错的。最近一直在看Android上和性能相关的部分，也就是所谓的Android性能优化，才发现Android性能这一块，自己懂得还是太少了，所以从上层开始看，也算是一点一点入门吧。这个系列将讲解学习过程中总结的和性能相关的内容。</p>
<p>首先将讲解一下GPU过渡绘制，也是开发者最直接接触的部分吧，这个内容将分为两个部分来将讲，第一部分初步讲解一下gpu过渡绘制的原理，和一些优化建议，第二部分将用实际例子来讲解优化GPU过渡绘制的一般步骤。</p>
<p><strong>1. 过渡绘制概念:</strong></p>
<p>GPU过渡绘制的概念：GPU过度绘制指的是在屏幕一个像素上绘制多次(超过一次),比如一个TextView后有背景，那么显示文本的像素至少绘了两次，一次是背景，一次是文本。GPU过度绘制或多或少对性能有些影响,设备的内存带宽是有限的，当过度绘制导致应用需要更多的带宽(超过了可用带宽)的时候性能就会降低。带宽的限制每个设备都可能是不一样的。</p>
<a id="more"></a>
<p><strong>2. 过渡绘制的原因:</strong></p>
<p>1. 太多的View叠加</p>
<p>2. 复杂的层级叠加</p>
<p>3. 更长的inflation时间</p>
<p><strong>3. 过渡绘制和不合理的xml布局的影响:</strong></p>
<p>1. 布局文件是一个xml文件，inflate布局文件其实就是解析xml，根据标签信息创建相应的布局对象并做关联。xml中的标签和属性设置越多，节点树的深度越深，在解析时要执行的判断逻辑、函数的嵌套和递归就越多，所以时间消耗越多；</p>
<p>2. inflate操作只是布局影响的第一个环节，一个界面要显示出来，在requestLayout后还要执行一系列的measure、layout、draw的操作，每一步的执行时间都会受到布局本身的影响。而界面的最终显示是所有这些操作完成后才实现的，所以如果布局质量差，会增加每一步操作的时间成本，最终显示时间就会比较长。</p>
<p><strong>4. 优化工具介绍:Android提供了三个工具来帮助辨别和解决重绘问题：Hierachy Viewer，Tracer for OpenGL和Show GPU overdraw。前两个可以在ADT工具或者独立的monitor工具中找到，最后一个是在开发者选项的一部分。</strong></p>
<p>1. GPU过渡绘制:对于过度绘制的测试主要通过人工进行测试，也是发现应用过渡绘制的首选途径 .通过打开开发者选项中的 显示GPU过度绘制(魅族手机:设置—辅助功能—开发人员工具—硬件加速渲染—调试GPU过渡绘制— 显示过渡绘制区域. (魅族手机需要打开开发者模式：需要在电话界面输入: <em>#</em>#6961#<em>#</em> )) 来进行测试（PS：只有android4.2及以上的版本才具备此功能)</p>
<p>1. 颜色标识: 从好到差:蓝-绿-淡红-红</p>
<p>1. 蓝色1x过度绘制<br>2. 绿色2x过度绘制<br>3. 淡红色3x过度绘制<br>4. 红色超过4x过度绘制</p>
<p>2. 验收标准:</p>
<p>1. 控制过度绘制为2x<br>2. 不允许存在4x过度绘制<br>3. 不允许存在面积超过屏幕1/4区域的3x过度绘制（淡红色区域）</p>
<p>3. Lint工具:</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>1. Eclipse中,点击即可,下面的窗口中会出现提示,根据提示和具体解决办法消除.<br>2. Android Studio自带Lint工具,不合理或者需要优化和注意的地方,会用黄色标记出来.<br>3. Lint工具不仅对布局有很好的优化建议,对代码中不合理的活着存在潜在风险的模块也会提出优化建议,所以一个好的建议是:多使用Lint工具检查自己的应用,尽量消除所有的建议.<br>4. Lint工具可以用命令行来运行,具体使用可以参考:tools.android.com<br>5. Lint工具的提升例子(摘自官方文档):</p>
<p>1. Use compound drawables(使用compound drawables) - A LinearLayout which contains an ImageView and a TextView can be more efficiently handled as a compound drawable.<br>2. Merge root frame(使用Merge根框架) - If a FrameLayout is the root of a layout and does not provide background or padding etc, it can be replaced with a merge tag which is slightly more efficient.<br>3. Useless leaf(去除无用的分支) - A layout that has no children or no background can often be removed (since it is invisible) for a flatter and more efficient layout hierarchy.<br>4. Useless parent (去除无用的父控件)- A layout with children that has no siblings, is not a ScrollView or a root layout, and does not have a background, can be removed and have its children moved directly into the parent for a flatter and more efficient layout hierarchy.<br>5. Deep layouts (注意Layout的深度) - Layouts with too much nesting are bad for performance. Consider using flatter layouts such as RelativeLayout or GridLayout to improve performance. The default maximum depth is</p>
<p>4. Hierarchy Viewer:此工具是一个ADT工具（或者monitor,最新版本的SDK建议不使用独立的HV工具,而是直接在monitor中进行操作.）的一部分，可以被用作对视图层级进行快速解读。在处理布局问题时特别有用，对于性能问题也很适用。Hierarchy Viewer默认只能在非加密设备使用，例如工程机，工程平板或者模拟器。为了能够在任何手机上使用Hierarchy Viewer，你得在你的应用中添加ViewServer，这是一个开源库,使用方法可以参考这里。连接上设备，打开Hierarchy Viewer(定位到tools/目录下，直接执行hierarchyviewer的命令，选定需要查看的Process，再点击Load View Hierarchy会显示出当前界面的布局Tree。在每个模块的Traffic light上有三个灯，分别代表了Measure, Layout and Draw三个步骤的性能。</p>
<p><strong>5. 布局优化建议:</strong></p>
<p>1. 布局原则:在Android UI布局过程中，通过遵守一些惯用、有效的布局原则，我们可以制作出高效且复用性高的UI，概括来说包括如下几点：</p>
<p>1. 尽量多使用RelativeLayout和LinearLayout, 不要使用绝对布局AbsoluteLayout，</p>
<p>1. 在布局层次一样的情况下， 建议使用LinearLayout代替RelativeLayout, 因为LinearLayout性能要稍高一点.<br>2. 在完成相对较复杂的布局时,建议使用RelativeLayout,RelativeLayout可以简单实现LinearLayout嵌套才能实现的布局.</p>
<p>2. 将可复用的组件抽取出来并通过include标签使用；<br>3. 使用ViewStub标签来加载一些不常用的布局；<br>4. 动态地inflation view性能要比SetVisiblity性能要好.当然用VIewStub是最好的选择.<br>5. 使用merge标签减少布局的嵌套层次<br>6. 去掉多余的背景颜色(查看背景颜色是否多余,可以将HierarchyView中的图导出为psd文件,然后用Photoshop查看.具体可以参考这个视频(<a href="https://www.youtube.com/watch?v=URyoiAt8098" target="_blank" rel="external">https://www.youtube.com/watch?v=URyoiAt8098</a>))</p>
<p>1. 对于有多层背景颜色的Layout来说,留最上面一层的颜色即可,其他底层的颜色都可以去掉<br>2. 对于使用Selector当背景的Layout(比如ListView的Item,会使用Selector来标记点击,选择等不同的状态),可以将normal状态的color设置为\”@android:color/transparent”,来解决对应的问题</p>
<p>8. 内嵌使用包含layout_weight属性的LinearLayout会在绘制时花费昂贵的系统资源，因为每一个子组件都需要被测量两次。在使用ListView与GridView的时候，这个问题显的尤其重要，因为子组件会重复被创建.所以要尽量避免使用Layout_weight<br>9. 使得Layout宽而浅，而不是窄而深（在Hierarchy Viewer的Tree视图里面体现）</p>
<p><strong>6. 例子</strong></p>
<p><strong>1. 过渡绘制优化较好的应用</strong></p>
<p>设置 画板 录音机（魅族自带应用）:</p>
<p><a href="\"><img src="\" alt="\"></a>  <a href="\"><img src="\" alt="\"></a>  <a href="\"><img src="\" alt="\"></a></p>
<p><strong>2. 过渡绘制优化较严重的应用</strong></p>
<p><strong>文件管理器 图库 应用中心 音乐 视频等</strong></p>
<p><a href="\"><img src="\" alt="\"></a>  <a href="\"><img src="\" alt="\"></a>  <a href="\"><img src="\" alt="\"></a></p>
<p>另外一些第三方客户端的过渡绘制也很严重，见<a href="\">微博</a></p>
<p><img src="\" alt="\">            <img src="\" alt="\"></p>
<p>  <img src="\" alt="\">          <img src="\" alt="\"></p>
<p>另外有能力看源码的同学，下面是绘制OverDraw的源码位置：/frameworks/base/libs/hwui/OpenGLRenderer.cpp,有兴趣的可以去研究研究。</p>
<pre class="\"lang:java" decode:true="" \"="" title="\"CountOverDraw\"">void OpenGLRenderer::renderOverdraw() {
    if (mCaches.debugOverdraw &amp;&amp; getTargetFbo() == 0) {
        const Rect* clip = &amp;mTilingClip;

        mCaches.enableScissor();
        mCaches.setScissor(clip-&gt;left, mFirstSnapshot-&gt;height - clip-&gt;bottom,
                clip-&gt;right - clip-&gt;left, clip-&gt;bottom - clip-&gt;top);

        // 1x overdraw
        mCaches.stencil.enableDebugTest(2);
        drawColor(mCaches.getOverdrawColor(1), SkXfermode::kSrcOver_Mode);

        // 2x overdraw
        mCaches.stencil.enableDebugTest(3);
        drawColor(mCaches.getOverdrawColor(2), SkXfermode::kSrcOver_Mode);

        // 3x overdraw
        mCaches.stencil.enableDebugTest(4);
        drawColor(mCaches.getOverdrawColor(3), SkXfermode::kSrcOver_Mode);

        // 4x overdraw and higher
        mCaches.stencil.enableDebugTest(4, true);
        drawColor(mCaches.getOverdrawColor(4), SkXfermode::kSrcOver_Mode);

        mCaches.stencil.disable();
    }
}

void OpenGLRenderer::countOverdraw() {
    size_t count = mWidth * mHeight;
    uint32_t* buffer = new uint32_t[count];
    glReadPixels(0, 0, mWidth, mHeight, GL_RGBA, GL_UNSIGNED_BYTE, &amp;buffer[0]);

    size_t total = 0;
    for (size_t i = 0; i &lt; count; i++) {
        total += buffer[i] &amp; 0xff;
    }

    mOverdraw = total / float(count);

    delete[] buffer;
}</pre>

<p>还有QA可能用得到的一个指标：OverDraw数值，这个的源码位置在Framework/base/core/java/android/view/HardwareRender.java中</p>
<pre class="\"lang:java" decode:true\"="" title="\"DrawOverDrawCount\"">private void debugOverdraw(View.AttachInfo attachInfo, Rect dirty,
                HardwareCanvas canvas, DisplayList displayList) {

            if (mDebugOverdraw == OVERDRAW_TYPE_COUNT) {
                if (mDebugOverdrawLayer == null) {
                    mDebugOverdrawLayer = createHardwareLayer(mWidth, mHeight, true);
                } else if (mDebugOverdrawLayer.getWidth() != mWidth ||
                        mDebugOverdrawLayer.getHeight() != mHeight) {
                    mDebugOverdrawLayer.resize(mWidth, mHeight);
                }

                if (!mDebugOverdrawLayer.isValid()) {
                    mDebugOverdraw = -1;
                    return;
                }

                HardwareCanvas layerCanvas = mDebugOverdrawLayer.start(canvas, dirty);
                countOverdraw(layerCanvas);
                final int restoreCount = layerCanvas.save();
                layerCanvas.drawDisplayList(displayList, null, DisplayList.FLAG_CLIP_CHILDREN);
                layerCanvas.restoreToCount(restoreCount);
                mDebugOverdrawLayer.end(canvas);

                float overdraw = getOverdraw(layerCanvas);
                DisplayMetrics metrics = attachInfo.mRootView.getResources().getDisplayMetrics();

                drawOverdrawCounter(canvas, overdraw, metrics.density);
            }
}

private void drawOverdrawCounter(HardwareCanvas canvas, float overdraw, float density) {
            final String text = String.format(\"%.2fx\", overdraw);
            final Paint paint = setupPaint(density);
            // HSBtoColor will clamp the values in the 0..1 range
            paint.setColor(Color.HSBtoColor(0.28f - 0.28f * overdraw / 3.5f, 0.8f, 1.0f));

            canvas.drawText(text, density * 4.0f, mHeight - paint.getFontMetrics().bottom, paint);
}</pre>

<p>欢迎大家一起交流。</p>
<p>下一篇文章会用一个实际案例来讲解如何优化过渡绘制。</p>
<p>&nbsp;</p>
<p>参考文章：</p>
<p>1.<a href="\"> http://blog.chengyunfeng.com/?p=458# 翻译的一个老外的优化过程</a><br>(原链接<a href="http://www.curious-creature.org/2012/12/01/android-performance-case-study/" target="_blank" rel="external">http://www.curious-creature.org/2012/12/01/android-performance-case-study/</a>)<br>2. <a href="\">http://blog.csdn.net/yihongyuelan/article/details/12169647 </a>反编译并添加gpu显示</p>
<p>3. <a href="\">http://developer.android.com/training/improving-layouts/optimizing-layout.html#Inspect</a> 官网资料</p>
<p>4. <a href="\">http://developer.android.com/training/improving-layouts/reusing-layouts.html </a>官网资料</p>
<p>5. <a href="\">http://developer.android.com/training/improving-layouts/loading-ondemand.html</a> 官网资料</p>
<p>6. <a href="\">http://developer.android.com/training/improving-layouts/smooth-scrolling.html </a>官网资料</p>
<p>7.<a href="\"> http://developer.android.com/tools/help/hierarchy-viewer.html</a> 官网关于hierarchy view的介绍</p>
<p>8. <a href="\">http://tools.android.com/tips/lint lint</a>工具介绍</p>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>博客有一段时间没有更新了，到了新公司后，一直比较忙，博客也更新地不那么频繁了，倒是利用这个VPS搭建的VPN每天都在用，速度也蛮不错的。最近一直在看Android上和性能相关的部分，也就是所谓的Android性能优化，才发现Android性能这一块，自己懂得还是太少了，所以从上层开始看，也算是一点一点入门吧。这个系列将讲解学习过程中总结的和性能相关的内容。</p>
<p>首先将讲解一下GPU过渡绘制，也是开发者最直接接触的部分吧，这个内容将分为两个部分来将讲，第一部分初步讲解一下gpu过渡绘制的原理，和一些优化建议，第二部分将用实际例子来讲解优化GPU过渡绘制的一般步骤。</p>
<p><strong>1. 过渡绘制概念:</strong></p>
<p>GPU过渡绘制的概念：GPU过度绘制指的是在屏幕一个像素上绘制多次(超过一次),比如一个TextView后有背景，那么显示文本的像素至少绘了两次，一次是背景，一次是文本。GPU过度绘制或多或少对性能有些影响,设备的内存带宽是有限的，当过度绘制导致应用需要更多的带宽(超过了可用带宽)的时候性能就会降低。带宽的限制每个设备都可能是不一样的。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[极简PPT的九大原则]]></title>
    <link href="http://androidperformance.com/2014/07/28/how-to-write-a-better-ppt/"/>
    <id>http://androidperformance.com/2014/07/28/how-to-write-a-better-ppt/</id>
    <published>2014-07-28T10:46:44.000Z</published>
    <updated>2015-03-26T12:45:53.000Z</updated>
    <content type="html"><![CDATA[<div>1、能十几页就不几十页；</div>

<div>2、能用图就不用字；</div>

<div>3、能用字就不用词；</div>

<div>4、能用词就不用句；</div>

<div>5、能用句就不用篇；</div>

<div>6、能讲故事就不讲理 论；</div>

<div>7、能谈问题就不谈概念；</div>

<div>8、逻辑、逻辑、逻辑；</div>

<div>9、你不可能面面俱到，让人记住哪怕只有一件事、一句话、一个词，就是成功。</div>]]></content>
    <summary type="html">
    <![CDATA[<div>1、能十几页就不几十页；</div>

<div>2、能用图就不用字；</div>

<div>3、能用字就不用词；</div>

<div>4、能用词就不用句；</div>

<div>5、能用句就不用篇；</div>

<div>6、能讲故事就不讲理 论；</div]]>
    </summary>
    
      <category term="科技与人文" scheme="http://androidperformance.com/categories/%E7%A7%91%E6%8A%80%E4%B8%8E%E4%BA%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Android小技巧]:如何让EditText不自动获取焦点]]></title>
    <link href="http://androidperformance.com/2014/06/03/android-edittext-do-not-auto-get-focus/"/>
    <id>http://androidperformance.com/2014/06/03/android-edittext-do-not-auto-get-focus/</id>
    <published>2014-06-02T16:31:49.000Z</published>
    <updated>2015-03-27T05:26:19.000Z</updated>
    <content type="html"><![CDATA[<p>Android中,使用EditText作为输入框很方便,但是有时候EditText会自动获取焦点,其行为:点击进入这个页面后,EditText自动获取焦点,导致软键盘直接跳出.有时候这么做很方便,但是大部分时候我们还是希望在点击EditText的时候,软键盘才弹出来.</p>
<p>这里有个很简单也很实用的技巧,即在EditText的父Layout中,加入下面的两个属性即可:</p>
<p><pre class="lang:java decode:true ">android:focusable=”true”<br>android:focusableInTouchMode=”true”</pre><br>这样做的原理是让用户进入到这个页面之后,EditText的父控件 获取焦点,这样的话EditText就获取不到焦点,软键盘也不会自动弹起.只有在点击EditText的时候,软键盘才会弹起.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android中,使用EditText作为输入框很方便,但是有时候EditText会自动获取焦点,其行为:点击进入这个页面后,EditText自动获取焦点,导致软键盘直接跳出.有时候这么做很方便,但是大部分时候我们还是希望在点击EditText的时候,软键盘才弹出来.</p]]>
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Frame animation模拟脉搏跳动小动画]]></title>
    <link href="http://androidperformance.com/2014/06/01/android-frame-animation/"/>
    <id>http://androidperformance.com/2014/06/01/android-frame-animation/</id>
    <published>2014-06-01T10:07:18.000Z</published>
    <updated>2015-03-27T05:26:33.000Z</updated>
    <content type="html"><![CDATA[<p>逐帧动画是一种常见的动画形式（Frame By Frame），其原理是在“连续的关键帧”中分解动画动作，也就是在时间轴的每帧上逐帧绘制不同的内容，使其连续播放而成动画。 因为逐帧动画的帧序列内容不一样，不但给制作增加了负担而且最终输出的文件量也很大，但它的优势也很明显：逐帧动画具有非常大的灵活性，几乎可以表现任何想表现的内容，而它类似与电影的播放模式，很适合于表演细腻的动画。例如：人物或动物急剧转身、 头发及衣服的飘动、走路、说话以及精致的3D效果等等。</p>
<p>Android中的逐帧动画是Frame animation。<span style="\"color:" #000000;\"="">Frame animation可以被定义在XML文件中，也可以完全编码实现。3.0以前，android支持两种动画模式，tween animation,frame animation，在android3.0中又引入了一个新的动画系统：property animation，这三种动画模式在SDK中被称为property animation,view animation,drawable animation。 </span></p>
<a id="more"></a>
<p>本篇使用的方法是在xml中定义效果，以下是想达到的动画的效果。</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>1.首先准备所需图片（逐帧）。</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>2.在res/anim下或res/rawable下新建xml来编写动画效果。内容类似下图：</p>
<pre class="\"lang:java" decode:true\"="">&lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\"
    android:oneshot=\"false\"&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00040\" android:duration=\"100\" /&gt;//duration是每帧图片的时长，单位ms
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00041\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00042\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00043\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00044\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00045\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00046\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00047\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00048\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00049\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00050\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00051\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00052\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00053\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00054\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00055\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00056\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00057\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00058\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00059\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00060\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00061\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00062\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00063\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00064\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00065\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00066\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00067\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00068\" android:duration=\"100\" /&gt;
    &lt;item android:drawable=\"@drawable/soundwave_new_1_00069\" android:duration=\"100\" /&gt;
&lt;/animation-list&gt;</pre>

<p>xml保存为scanning_anim.xml.其中,</p>
<pre class="\"lang:java" decode:true\"="">animation-list//最外层是animition-list控件，可以容纳item，每个item是一帧图片。</pre>

<pre class="\"lang:java" decode:true\"="">android:oneshot=\"false\"<span style="\"color:" #000000;\"="">//如果为true，表示动画只播放一次停止在最后一帧上，如果设置为false表示动画循环播放。</span></pre>

<p>3.以上xml中定义的动画要以一个imageView作为载体来显示。以下例子用一个类稍稍封装：</p>
<pre class="\"lang:java" decode:true\"="">public class ScanningAnimationView extends ImageView {
    AnimationDrawable scanningDrawable;
    public ScanningAnimationView(Context context) {
        super(context);
    }
    public ScanningAnimationView(Context context, AttributeSet attrs) {
        super(context, attrs);
        setBackgroundResource(R.anim.scanning_anim);
        scanningDrawable=(AnimationDrawable)this.getBackground();
    }

    public void start() {
        scanningDrawable.start();
    }
    public void stop() {
        scanningDrawable.stop();
    }
}</pre>

<p>4.用户直接使用这个封装好的ImageView调用start和stop即可。</p>
<p>调用动画：</p>
<pre class="\"lang:java" decode:true\"="">public class MainActivity extends ActionBarActivity {
    ScanningAnimationView image;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        image = (ScanningAnimationView)findViewById(R.id.imageView);
        Button startButton = (Button) findViewById(R.id.start);
        Button endButton = (Button)findViewById(R.id.end);
        startButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                image.start();
            }
        });

        endButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                image.stop();
            }
        });
    }
</pre>

<p>imageView的布局：</p>
<pre class="\"lang:java" decode:true\"="">&lt;com.example.nurse.app.util.ScanningAnimationView
    android:layout_width=\"wrap_content\"
    android:layout_height=\"wrap_content\"
    android:id=\"@+id/imageView\"
    android:layout_centerHorizontal=\"true\"
    android:layout_alignParentTop=\"true\"
    android:layout_alignParentStart=\"true\"/&gt;</pre>

<p>本篇完。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>逐帧动画是一种常见的动画形式（Frame By Frame），其原理是在“连续的关键帧”中分解动画动作，也就是在时间轴的每帧上逐帧绘制不同的内容，使其连续播放而成动画。 因为逐帧动画的帧序列内容不一样，不但给制作增加了负担而且最终输出的文件量也很大，但它的优势也很明显：逐帧动画具有非常大的灵活性，几乎可以表现任何想表现的内容，而它类似与电影的播放模式，很适合于表演细腻的动画。例如：人物或动物急剧转身、 头发及衣服的飘动、走路、说话以及精致的3D效果等等。</p>
<p>Android中的逐帧动画是Frame animation。<span style=\"color: #000000;\">Frame animation可以被定义在XML文件中，也可以完全编码实现。3.0以前，android支持两种动画模式，tween animation,frame animation，在android3.0中又引入了一个新的动画系统：property animation，这三种动画模式在SDK中被称为property animation,view animation,drawable animation。 </span></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(2)]]></title>
    <link href="http://androidperformance.com/2014/05/31/android-tips-round-up-2/"/>
    <id>http://androidperformance.com/2014/05/31/android-tips-round-up-2/</id>
    <published>2014-05-31T10:20:47.000Z</published>
    <updated>2015-03-27T05:18:54.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第二篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/text/format/DateUtils.html#formatDateTime%28android.content.Context,%20long,%20int%29" target="_blank" rel="external">DateUtils.formatDateTime()</a> 用来进行区域格式化工作,输出格式化和本地化的时间或者日期.</p>
<p><a href="http://developer.android.com/reference/android/app/AlarmManager.html#setInexactRepeating(int, long, long, android.app.PendingIntent" target="_blank" rel="external">AlarmManager.setInexactRepeating</a>) 通过闹铃分组的方式省电,即使你只调用了一个闹钟,这也是一个好的选择,（可以确保在使用完毕时自动调用 AlarmManager.cancel ()。原文说的比较抽象,这里详细说一下:setInexactRepeating指的是设置非准确闹钟,使用方法:alarmManager.setInexactRepeating(AlarmManager.RTC, startTime,intervalL, pendingIntent),非准确闹钟只能保证大致的时间间隔，但是不一定准确，可能出现设置间隔为30分钟，但是实际上一次间隔20分钟，另一次间隔40分钟。它的最大的好处是可以合并闹钟事件，比如间隔设置每30分钟一次，不唤醒休眠，在休眠8小时后已经积累了16个闹钟事件，而在手机被唤醒的时候，非准时闹钟可以把16个事件合并为一个, 所以这么看来,非准时闹钟一般来说比较节约能源.</p>
<p><a href="http://developer.android.com/reference/android/text/format/Formatter.html#formatFileSize(android.content.Context, long" target="_blank" rel="external">Formatter.formatFileSize()</a>) 一个区域化的文件大小格式化工具。通俗来说就是把大小转换为MB,G,KB之类的字符串.</p>
<p><a href="http://developer.android.com/reference/android/app/ActionBar.html#hide(" target="_blank" rel="external">ActionBar.hide()</a>)/<a href="http://developer.android.com/reference/android/app/ActionBar.html#show(" target="_blank" rel="external">.show()</a>) 顾名思义,隐藏和显示ActionBar,可以优雅地在全屏和带Actionbar之间转换.</p>
<p><a href="http://developer.android.com/reference/android/text/util/Linkify.html#addLinks(android.text.Spannable, int" target="_blank" rel="external">Linkify.addLinks()</a>)  在Text上添加链接.很实用.</p>
<p><a href="http://developer.android.com/reference/android/text/StaticLayout.html" target="_blank" rel="external">StaticLayout</a> 在自定义 View 中渲染文字的时候很实用。</p>
<p><a href="http://developer.android.com/reference/android/app/Activity.html#onBackPressed(" target="_blank" rel="external">Activity.onBackPressed()</a>) 很方便的管理back键的方法,有时候需要自己控制返回键的事件的时候,可以重写一下.比如加入 “点两下back键退出” 功能.</p>
<a id="more"></a>
<p><a href="http://developer.android.com/reference/android/view/GestureDetector.html" target="_blank" rel="external">GestureDetector</a> 用来监听和相应对应的手势事件,比如点击,长按,慢滑动,快滑动,用起来很简单,比你自己实现要方便许多.</p>
<p><a href="http://developer.android.com/reference/android/graphics/DrawFilter.html" target="_blank" rel="external">DrawFilter</a> 可以让你在不调用onDrew方法的情况下,操作canvas,比了个如,你可以在创建自定义 View 的时候设置一个 DrawFilter，给父 View 里面的所有 View 设置反别名。</p>
<p><a href="http://developer.android.com/reference/android/app/ActivityManager.html#getMemoryClass(" target="_blank" rel="external">ActivityManager.getMemoryClass()</a>) 告诉你你的机器还有多少内存,在计算缓存大小的时候会比较有用.</p>
<p><a href="http://developer.android.com/reference/android/view/ViewStub.html" target="_blank" rel="external">ViewStub</a> 它是一个初始化不做任何事情的 View，但是之后可以载入一个布局文件。在慢加载 View 中很适合做占位符。唯一的缺点就是不支持标签，所以如果你不太小心的话，可能会在视图结构中加入不需要的嵌套。</p>
<p><a href="http://developer.android.com/reference/android/os/SystemClock.html#sleep(long" target="_blank" rel="external">SystemClock.sleep()</a>) 这个方法在保证一定时间的 sleep 时很方便，通常我用来进行 debug 和模拟网络延时。</p>
<p><a href="http://developer.android.com/reference/android/util/DisplayMetrics.html#density" target="_blank" rel="external">DisplayMetrics.density</a> 这个方法你可以获取设备像素密度,大部分时候最好让系统来自动进行缩放资源之类的操作,但是有时候控制的效果会更好一些.(尤其是在自定义View的时候).</p>
<p><a href="http://developer.android.com/reference/android/util/Pair.html#create(A, B" target="_blank" rel="external">Pair.create()</a>) 方便构建类和构造器的方法。</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/04/14/android-tips-round-up-part-2/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-2/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-2.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第二篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/text/format/DateUtils.html#formatDateTime%28android.content.Context,%20long,%20int%29">DateUtils.formatDateTime()</a> 用来进行区域格式化工作,输出格式化和本地化的时间或者日期.</p>
<p><a href="http://developer.android.com/reference/android/app/AlarmManager.html#setInexactRepeating(int, long, long, android.app.PendingIntent">AlarmManager.setInexactRepeating</a>) 通过闹铃分组的方式省电,即使你只调用了一个闹钟,这也是一个好的选择,（可以确保在使用完毕时自动调用 AlarmManager.cancel ()。原文说的比较抽象,这里详细说一下:setInexactRepeating指的是设置非准确闹钟,使用方法:alarmManager.setInexactRepeating(AlarmManager.RTC, startTime,intervalL, pendingIntent),非准确闹钟只能保证大致的时间间隔，但是不一定准确，可能出现设置间隔为30分钟，但是实际上一次间隔20分钟，另一次间隔40分钟。它的最大的好处是可以合并闹钟事件，比如间隔设置每30分钟一次，不唤醒休眠，在休眠8小时后已经积累了16个闹钟事件，而在手机被唤醒的时候，非准时闹钟可以把16个事件合并为一个, 所以这么看来,非准时闹钟一般来说比较节约能源.</p>
<p><a href="http://developer.android.com/reference/android/text/format/Formatter.html#formatFileSize(android.content.Context, long">Formatter.formatFileSize()</a>) 一个区域化的文件大小格式化工具。通俗来说就是把大小转换为MB,G,KB之类的字符串.</p>
<p><a href="http://developer.android.com/reference/android/app/ActionBar.html#hide(">ActionBar.hide()</a>)/<a href="http://developer.android.com/reference/android/app/ActionBar.html#show(">.show()</a>) 顾名思义,隐藏和显示ActionBar,可以优雅地在全屏和带Actionbar之间转换.</p>
<p><a href="http://developer.android.com/reference/android/text/util/Linkify.html#addLinks(android.text.Spannable, int">Linkify.addLinks()</a>)  在Text上添加链接.很实用.</p>
<p><a href="http://developer.android.com/reference/android/text/StaticLayout.html">StaticLayout</a> 在自定义 View 中渲染文字的时候很实用。</p>
<p><a href="http://developer.android.com/reference/android/app/Activity.html#onBackPressed(">Activity.onBackPressed()</a>) 很方便的管理back键的方法,有时候需要自己控制返回键的事件的时候,可以重写一下.比如加入 “点两下back键退出” 功能.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android小技巧(1)]]></title>
    <link href="http://androidperformance.com/2014/05/28/android-tips-round-up-1/"/>
    <id>http://androidperformance.com/2014/05/28/android-tips-round-up-1/</id>
    <published>2014-05-28T15:47:43.000Z</published>
    <updated>2015-03-27T05:18:48.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第一篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/app/Activity.html#startActivities(android.content.Intent[]" target="_blank" rel="external">Activity.startActivities()</a>) 常用于在应用程序中间启动其他的Activity.</p>
<p><a href="http://developer.android.com/reference/android/text/TextUtils.html#isEmpty(java.lang.CharSequence" target="_blank" rel="external">TextUtils.isEmpty()</a>) 简单的工具类,用于检测是否为空</p>
<p><a href="http://developer.android.com/reference/android/text/Html.html#fromHtml(java.lang.String" target="_blank" rel="external">Html.fromHtml()</a>) 用于生成一个Html,参数可以是一个字符串.个人认为它不是很快,所以我不怎么经常去用.（我说不经常用它是为了重点突出这句话：请多手动构建 Spannable 来替换 Html.fromHtml），但是它对渲染从 web 上获取的文字还是很不错的。</p>
<p><a href="http://developer.android.com/reference/android/widget/TextView.html#setError%28java.lang.CharSequence%29" target="_blank" rel="external">TextView.setError()</a> 在验证用户输入的时候很棒</p>
<p><a href="http://developer.android.com/reference/android/os/Build.VERSION_CODES.html" target="_blank" rel="external">Build.VERSION_CODES</a> 这个标明了当前的版本号,在处理兼容性问题的时候经常会用到.点进去可以看到各个版本的不同特性</p>
<p><a href="http://developer.android.com/reference/android/util/Log.html#getStackTraceString(java.lang.Throwable" target="_blank" rel="external">Log.getStackTraceString()</a>) 方便的日志类工具,方法Log.v()、Log.d()、Log.i()、Log.w()和Log.e()都是将信息打印到LogCat中，有时候需要将出错的信息插入到数据库或一个自定义的日志文件中，那么这种情况就需要将出错的信息以字符串的形式返回来，也就是使用static String getStackTraceString(Throwable tr)方法的时候.</p>
<p><a href="http://developer.android.com/reference/android/view/LayoutInflater.html#from%28android.content.Context%29" target="_blank" rel="external">LayoutInflater.from()</a> 顾名思义,用于Inflate一个layout,参数是layout的id.这个经常写Adapter的人会用的比较多.</p>
<a id="more"></a>
<p><a href="http://developer.android.com/reference/android/view/ViewConfiguration.html#getScaledTouchSlop%28%29" target="_blank" rel="external">ViewConfiguration.getScaledTouchSlop()</a> 使用 ViewConfiguration 中提供的值以保证所有触摸的交互都是统一的。这个方法获取的值表示:用户的手滑动这个距离后,才判定为正在进行滑动.当然这个值也可以自己来决定.但是为了一致性,还是使用标准的值较好.</p>
<p><a href="http://developer.android.com/reference/android/telephony/PhoneNumberUtils.html#convertKeypadLettersToDigits%28java.lang.String%29" target="_blank" rel="external">PhoneNumberUtils.convertKeypadLettersToDigits</a> 顾名思义.将字母转换为数字,类似于T9输入法,</p>
<p><a href="http://developer.android.com/reference/android/content/Context.html#getCacheDir%28%29" target="_blank" rel="external">Context.getCacheDir()</a> 获取缓存数据文件夹的路径,很简单但是知道的人不多,这个路径通常在SD卡上(这里的SD卡指的是广义上的SD卡,包括外部存储和内部存储)Adnroid/data/您的应用程序包名/cache/  下面.测试的时候,可以去这里面看是否缓存成功.缓存在这里的好处是:不用自己再去手动创建文件夹,不用担心用户把自己创建的文件夹删掉,在应用程序卸载的时候,这里会被清空,使用第三方的清理工具的时候,这里也会被清空.</p>
<p><a href="http://developer.android.com/reference/android/animation/ArgbEvaluator.html" target="_blank" rel="external">ArgbEvaluator</a> 用于处理颜色的渐变。就像 Chris Banes 说的一样，这个类会进行很多自动装箱的操作，所以最好还是去掉它的逻辑自己去实现它。这个没用过,不明其所以然,回头再补充.</p>
<p><a href="http://developer.android.com/reference/android/view/ContextThemeWrapper.html" target="_blank" rel="external">ContextThemeWrapper</a> 方便在运行的时候修改主题.</p>
<p><a href="http://developer.android.com/reference/android/widget/Space.html" target="_blank" rel="external">Space</a> space是Android 4.0中新增的一个控件，它实际上可以用来分隔不同的控件，其中形成一个空白的区域.这是一个轻量级的视图组件，它可以跳过Draw，对于需要占位符的任何场景来说都是很棒的。</p>
<p><a href="http://developer.android.com/reference/android/animation/ValueAnimator.html#reverse%28%29" target="_blank" rel="external">ValueAnimator.reverse()</a> 这个方法可以很顺利地取消正在运行的动画.我超喜欢.</p>
<h2 id="备忘">备忘</h2><p>More: <a href="http://www.androidperformance.com/android-tips-round-up.html" target="_blank" rel="external">Part1</a> , <a href="http://www.androidperformance.com/android-tips-round-up-2.html" target="_blank" rel="external">Part2</a> , <a href="http://www.androidperformance.com/android-tips-round-up-3.html" target="_blank" rel="external">Part3</a> , <a href="http://www.androidperformance.com/android-tips-round-up-4.html" target="_blank" rel="external">Part4</a>, <a href="http://www.androidperformance.com/android-tips-round-up-5.html" target="_blank" rel="external">Part5</a><br>原文地址:<a href="http://blog.danlew.net/2014/03/30/android-tips-round-up-part-1/" target="_blank" rel="external">http://blog.danlew.net/2014/03/30/android-tips-round-up-part-1/</a><br>原文作者:<a href="http://blog.danlew.net/about/" target="_blank" rel="external">http://blog.danlew.net/about/</a><br>本文地址:<a href="http://www.androidperformance.com/android-tips-round-up-1.html" target="_blank" rel="external">http://www.androidperformance.com/android-tips-round-up-1.html</a> 转载请注明.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文是一篇译文,这篇是这个系列的第一篇.讲述的是Android开发中遇到的一些好用的小技巧,或者一些实用的API,很多人都知道,但也有人不知道,记录下来,如果能帮助到大家,也是极好的.由于不是严格的博文,所以翻译也不那么严格,有些工具和类我也会经常用,所以我会根据自己的想法去写.有些地方坐在并没有将这个工具的作用讲出来,我会补充上去.</p>
<h2 id="正文">正文</h2><p><a href="http://developer.android.com/reference/android/app/Activity.html#startActivities(android.content.Intent[]">Activity.startActivities()</a>) 常用于在应用程序中间启动其他的Activity.</p>
<p><a href="http://developer.android.com/reference/android/text/TextUtils.html#isEmpty(java.lang.CharSequence">TextUtils.isEmpty()</a>) 简单的工具类,用于检测是否为空</p>
<p><a href="http://developer.android.com/reference/android/text/Html.html#fromHtml(java.lang.String">Html.fromHtml()</a>) 用于生成一个Html,参数可以是一个字符串.个人认为它不是很快,所以我不怎么经常去用.（我说不经常用它是为了重点突出这句话：请多手动构建 Spannable 来替换 Html.fromHtml），但是它对渲染从 web 上获取的文字还是很不错的。</p>
<p><a href="http://developer.android.com/reference/android/widget/TextView.html#setError%28java.lang.CharSequence%29">TextView.setError()</a> 在验证用户输入的时候很棒</p>
<p><a href="http://developer.android.com/reference/android/os/Build.VERSION_CODES.html">Build.VERSION_CODES</a> 这个标明了当前的版本号,在处理兼容性问题的时候经常会用到.点进去可以看到各个版本的不同特性</p>
<p><a href="http://developer.android.com/reference/android/util/Log.html#getStackTraceString(java.lang.Throwable">Log.getStackTraceString()</a>) 方便的日志类工具,方法Log.v()、Log.d()、Log.i()、Log.w()和Log.e()都是将信息打印到LogCat中，有时候需要将出错的信息插入到数据库或一个自定义的日志文件中，那么这种情况就需要将出错的信息以字符串的形式返回来，也就是使用static String getStackTraceString(Throwable tr)方法的时候.</p>
<p><a href="http://developer.android.com/reference/android/view/LayoutInflater.html#from%28android.content.Context%29">LayoutInflater.from()</a> 顾名思义,用于Inflate一个layout,参数是layout的id.这个经常写Adapter的人会用的比较多.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JAVA修饰符]]></title>
    <link href="http://androidperformance.com/2014/05/28/javamodifier/"/>
    <id>http://androidperformance.com/2014/05/28/javamodifier/</id>
    <published>2014-05-28T12:14:59.000Z</published>
    <updated>2015-03-27T05:24:30.000Z</updated>
    <content type="html"><![CDATA[<div style="color: #000000;font-family: 微软雅黑"><strong>java.lang.reflect.Modifier</strong><br><table><br><tbody><br><tr><br><td colspan="2"><strong>ABSTRACT</strong></td><br></tr><br><tr><br><td></td><br><td>Abstract(抽象)可以修饰类、方法。包含一个或多个抽象方法的类本身必须被声明为抽象类。除了抽象方法之外，抽象类还可以包含具体数据和具体方法。抽象方法充当着占位的角色，它们的具体实现在子类中。扩展抽象类可以有两种选择：一种是在子类中定义部分抽象方法或抽象方法也不定义，这样就必须将子类也标记为抽象类；另一种是定义全部的抽象方法，这样子类就不是抽象类了。<br><br>类即使不含有抽象方法也可以将类声明为抽象类。抽象类不能实例化。也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。不过可以定义一个抽象类的对象变量，但是它只能引用继承抽象类的非抽象子类的对象。<br><br>注意比较：<br><strong>private void</strong> <strong>print(){}</strong>；此语句表示方法的空实现。<br><strong>Abstract void</strong> <strong>print()</strong>； 此语句表示方法的抽象，无实现。<br><br>Abstract和static或者Abstract和final不能放在一起，否则便会出现错误。<br><br>&nbsp;</td><br></tr><br><tr><br><td><strong>FINAL</strong></td><br><td></td><br></tr><br><tr><br><td></td><br><td>final可以修饰类，方法，域。<br>域被声明为final，则构造对象之后就不允许改变它们的值了。如果被修饰的域是对象引用，则对象内的值还是可以改变的，但是对象的引用不能改变。（必须初始化，不能被修改）<br>方法被声明为final，可以确保方法不会在子类中改变语义，就是说不能被子类覆盖。<br><br>PS：早期JAVA中，有时为了避免动态绑定带来的系统开销而使用final修饰符。如果一个方法很短并且没有被覆盖，编译器就能够对它进行优化处理，这个过程被称为内联（inlining）。例如，内联调用e.getName()将被替换为访问e.name域。这是由于CPU在处理调用方法的指令时，使用的分支转移会扰乱预取指令策略，增加系统开销，使用内联可以避免这一开销。但是，如果getName在另一个类中被覆盖，那么编译器就无法知道覆盖的代码将会做什么操作，因此就不能对它进行内敛处理了。<br><br>不过现在虚拟机中的即时编译器比传统编译器的处理能力要强得多。这种编译器可以准确地知道类之间的继承关系，并能够检测出类中是否真正地存在覆盖给定的方法。如果方法简短，被调用频繁而且没有真正地被覆盖，那么即时编译器就会对这个方法进行内联处理。如果虚拟机加载了另一个类，而在这个类中包含对内联方法的覆盖，那么优化器将取消对覆盖方法的内联。这过程很慢而且很少发生。<br><br>类被声明为final，相当于其中的方法自动成为final方法，但是不包括类中的域。这种操作可以阻止利用被修饰的类定义子类。就是说不允许被继承的类被称为final类。一般来说一个类要么为继承设计，并提供文档说明；要么就禁止继承，成为一个final类。<br><a id="more"></a><br><br><br>&nbsp;</td><br></tr><br><tr><br><td colspan="2"><strong>INTERFACE</strong></td><br></tr><br><tr><br><td></td><br><td>在JAVA语言中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。公开接口与类相似，一个文件只能有一个public接口，且与文件名相同。 在一个文件中不可同时定义一个public接口和一个public类。<br><br>接口中可以包含多个方法，也可以定义常量。接口中所有方法自动属于public和abstract，所以不能在接口中实现方法。在接口中声明方法时不必提供修饰符public，但在类实现接口时public不可省略，如果省去public则在编译的时候提示出错。而且类要实现接口中所有的方法否则类就是一个抽象类。接口中可以定义常量，常量自动具有public，static，final属性。接口决不能含有实例域，可以将接口看成是没有实例域的抽象类。<br><br>接口不是类，不能使用new运算法实例化一个接口，虽然不能构造接口的对象，但可以声明接口的变量，接口变量必须引用实现了接口的类的对象。接口可以像建立继承关系一样，形成一条或多条从较高通用性到较高专用性的接口链。要注意接口继承接口使用关键字<strong>extends</strong>，并且可以进行多继承。类实现接口使用关键字<strong>implements</strong>，可以实现多个接口，并同时继承一个且最多一个超类。<br><br>接口与抽象类：一个类可以实现多个接口，但是一个类只能有一个超类。类与超类的关系是“is-a”，类与被实现接口的关系是“like-a”。抽象类可以包含据体数据和具体方法，接口只能包含常量和抽象方法。<br>PS：可以使用instanceof检查一个对象是否属于某个特定的类，也可以使用instanceof检查一个对象是否实现了某个特定的接口。<br><br>&nbsp;</td><br></tr><br><tr><br><td><strong>NATIVE</strong></td><br><td></td><br></tr><br><tr><br><td></td><br><td>JAVA编程语言使用关键字native提醒编译器被修饰的方法将在外部定义，而且方法标题后直接跟分号，这种声明方式和抽象方法类似。<br><pre class="lang:java decode:true ">class HelloNative{<br>    public native void greeting();<br>}<br></pre><br>如果一个含有本地方法的类被继承，子类会继承这个本地方法并且可以用java语言重写这个方法。本地方法非常有用，因为它有效地扩充了jvm。事实上，我们所写的java代码已经用到了本地方法，在sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java程序能够超越java运行时的界限。有了本地方法，java程序可以做任何应用层次的任务。<br>PS：通过java.system.loadLibrary()方法装载含有本地方法的库。<br><br>&nbsp;</td><br></tr><br><tr><br><td colspan="2"><strong>PRIVATE，PROTECTED，PUBLIC</strong></td><br></tr><br><tr><br><td></td><br><td>这三个修饰符都是用来控制类和成员的访问级别。还有一个访问级别叫做包级私有（package-private），也就是没有修饰符修饰缺省（default）的访问级别。<br><br>对于顶层的类（非嵌套的类）和接口，只有两种可能的访问级别：包级私有的（package-private）和公有的（public）。如果使用public修饰符声明了顶层类或者接口，那它就是公有的；否则就是包级私有的。<br>如果类或者接口能够被做成包级私有的，它就应该被做成包级私有的。通过把类或者接口做成包级私有，它实际上成了这个包的实现的一部分，而不是该包导出API的一部分，在以后的发行版本中，可以对它进行修改，替换或者删除，而无需担心会影响到现有客户端程序。如果把它做成公有的，你就有责任永远支持它，以保持它们的兼容性。<br>如果一个包级私有的顶层类（或者接口）只是在某个类的内部被用到，就应该考虑使它成为唯一使用它的那个类的私有嵌套类。这样可以将它的可访问范围从包中所有类缩小到了使用它的那个类。然而，降低不必要公有类的可访问性，比降低包级私有的顶层类的可访问性重要得多：因为公有类是包的API的一部分，而包级私有的顶层类则已经是这个包的实现的一部分。<br><br>对于成员（域，方法，嵌套类和嵌套接口）有四种可能的访问级别，下面按照可访问性的递增顺序罗列出来：<br><br><em>   私有的（private） —— 只有在声明该成员的顶层类内部才可以访问这个成员。
</em>   包级私有（package-private） —— 声明该成员的包内部的任何类都可以访问这个成员。从技术上讲，它被称为“缺省（default）访问级别”，如果没有为成员指定访问修饰符，就采用这个访问级别。<br><em>   受保护的（protected） —— 声明该成员的类的子类可以访问这个成员，并且，声明该成员的包内部的任何类可以访问这个成员。（分为在同一个包内和不在同一个包内）
</em>   公有的（public） —— 在任何地方都可以访问该成员<br>在设计一个类时，只有当同一个包内部的另一个类真正需要访问一个成员的时候，你才应该删除private修饰符，使该成员变成包级私有的。如果经常这么做，则应该重新检查系统设计，看是否有另一种分解方案所得到的类，与其他类之间的耦合度会更小。私有成员和包级私有成员都是一个类的实现中的一部分，一般不会影响它的导出的API。然而如果这个类实现了serializable接口，这些域就有可能会被“泄露”到到导出API中。<br><br>对于公有类的的成员，当访问级别从包级私有变成保护级别时，会大大增强可访问性。受保护的成员是类的导出API的一部分，必须永远得到支持。导出的类的受保护成员也代表了该类对于某个实现细节的承诺。受保护的成员应该尽量少用。如果方法覆盖了超类中的一个方法，子类中的访问级别就不允许低于超累中的访问级别。这样可以确保任何可使用超类的实例的地方也都可以吃用子类的实例。<br><br>实例域决不能公有，如果域是非final的，或者是一个指向可变对象的final引用，那么一旦使这个域成为公有的，就放弃了对存储在这个域中的值进行限制的能力；这意味着，你也放弃了强制这个域不可变的能力。因此，包含公有可变域的类并不是线程安全的。<br><br>同样的建议也适用于静态域，除非通过公有的静态final域来暴露一些常量。这些域要么包含基本类型的值，要么包含指向不可变对象的引用。如果final域包含可变对象的引用，它便具有非final域的所有缺点。虽然本身不能被修改，但是它所引用的的对象却可以被修改——这会导致灾难性的后果。<br><br>总而言之，应该始终尽可能降低可访问性。除了公有静态final域的特殊情况外，公有类都不应该包含公有域。并且要确保公有静态final域所引用的对象都是不可变的。<br><br>&nbsp;</td><br></tr><br><tr><br><td><strong>STATIC</strong></td><br><td></td><br></tr><br><tr><br><td></td><br><td>static修饰符可以用来修饰域，方法，初始化块，类。<br><br><em>   static修饰域和方法<br>如果将域用static修饰，则每个类中只有一个这样的域。每个对象对所有的实例域都有一份自己的拷贝，而静态域则是共享的。静态变量用的相对较少，而静态常量用的相对较多。<br><br>静态方法是一种不能向对象实施操作的方法。可以认为静态方法是没有this参数的方法。因为静态方法不能操作对象，所以不能在静态方法中访问实例域，但是可以访问自身类中的静态域。静态方法可以被类调用，也可以被对象调用。在下面两种情况下使用静态方法：<br><br>1.  一个方法不需要访问对象状态，其所需参数都是通过显式参数提供。<br>2.  一个方法只需要访问类的静态域。<br>静态方法可以用来做静态工厂方法，代替构造器。和静态域配合可以实现单例模式。main函数也是一个静态方法。

</em>   static修饰初始化块<br>static修饰初始化块主要是有一个顺序问题。静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序以此是（静态变量、静态初始化块）&gt;（变量、初始化块）&gt;构造器。括号内的各项是由在代码中的顺序决定的。静态初始化块与静态方法一样，不能向对象实施操作，也就不能访问实例域和非静态方法。<br><br>在继承关系中，父类的静态变量和静态初始化块先执行，然后是子类的静态变量和静态初始化块执行，然后才是父类的变量，初始化块和构造器，最后是子类的变量，初始化块和构造器。<br><br><em>   static修饰类<br>如果一个类要被声明为static的，只有一种情况，就是静态成员类。静态成员类是最简单的一种嵌套类。最好把它看做是普通类，只是刚好声明在了另一个类的内部，它可以访问外部类的所有成员，包括那些声明为私有的成员。静态成员类是外部类的一个静态成员，与其他静态成员一样，也遵从同样的可访问性规则。<br>静态成员类的一种常见用法是作为公有的辅助类，仅当与它的外部类一起使用时才有意义。比如使用builder模式构建类的对象（effective java 2-2）。而私有静态成员类的一种常见用法是用来代表外部类所代表的对象的组件。<br><br>如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中，使它成为静态成员类。如果省略了static修饰符，则每个实例都将包含一个额外的指向外围对象的引用。保存这份引用要消耗时间和空间，并会导致外围实例在符合垃圾回收时却仍然得以保留。如果在没有外围实例的情况下，也需要分配实例，就必须使用静态成员类，因为非静态成员类的实例必须要有一个外围实例。<br>静态成员类的一种常见用法是作为公有的辅助类，仅当与它的外部类一起使用时才有意义。比如使用builder模式构建类的对象（effective java 2-2）。而私有静态成员类的一种常见用法是用来代表外部类所代表的对象的组件。<br><br>如果声明成员类不要求访问外围实例，就要始终把static修饰符放在它的声明中，使它成为静态成员类。如果省略了static修饰符，则每个实例都将包含一个额外的指向外围对象的引用。保存这份引用要消耗时间和空间，并会导致外围实例在符合垃圾回收时却仍然得以保留。如果在没有外围实例的情况下，也需要分配实例，就必须使用静态成员类，因为非静态成员类的实例必须要有一个外围实例。<br><br>&nbsp;</em></td><br></tr><br><tr><br><td colspan="2"><strong>STRICTFP</strong></td><br></tr><br><tr><br><td></td><br><td>strictfp, 即 strict float point (精确浮点)。<br><br>strictfp 关键字可应用于类、接口或方法。使用 strictfp 关键字声明一个方法时，该方法中所有的float和double表达式都严格遵守FP-strict的限制,符合IEEE-754规范。当对一个类或接口使用 strictfp 关键字时，该类中的所有代码，包括嵌套类型中的初始设定值和代码，都将严格地进行计算。严格约束意味着所有表达式的结果都必须是 IEEE 754 算法对操作数预期的结果，以单精度和双精度格式表示。如果你想让你的浮点运算更加精确，而且不会因为不同的硬件平台所执行的结果不一致的话，可以用关键字strictfp.<br><br>&nbsp;</td><br></tr><br><tr><br><td colspan="2"><strong>SYNCHRONIZED</strong></td><br></tr><br><tr><br><td></td><br><td>如果一个方法使用synchronized修饰符，那么对象的锁将保护整个方法。也就是说，要调用该方法，线程必须获得内部的对象锁。代码示例：<br><pre class="lang:java decode:true ">public synchronized void method() {<br>    // TODO<br>}<br></pre><br>等价于<br><pre class="lang:java decode:true ">public void method() {<br>    this.intrinsicLock.lock();<br>    try {<br>        // TODO<br>    } finally {<br>        this.intrinsicLock.unlock();<br>    }<br>}<br></pre><br>synchronized修饰符还可以修饰一个代码块，当线程进入如下形式的阻塞：<br><pre class="lang:java decode:true ">synchronized(obj) {<br>    // TODO<br>}<br></pre><br>于是它获得了obj的锁。<br><br>可以看到使用synchronized修饰符编写代码要整洁的多。你必须了解每个对象都有一个内部锁，并且该锁有一个内部条件。由锁来管理那些试图进入synchronized方法的线程，由条件来管理那些调用wait的线程。<br><br>将静态方法声明为synchronized也适合法的。如果调用这种方法，该方法获得相关的类对象的内部锁。例如A类有一个静态同步的方法，那么当该方法被调用时，A.class对象被锁住。因此没有其他线程可以调用同一个类的这个或任何其他的同步静态方法。<br><br>最好不要使用synchronized修饰符。许多情况下你可以使用java.util.concurrent包中的一种机制，它会为你处理所有的加锁。过度的同步可能会导致性能降低，死锁，甚至不确定的行为<br><br>&nbsp;</td><br></tr><br><tr><br><td colspan="2"><strong>TRANSIENT</strong></td><br></tr><br><tr><br><td></td><br><td><br>transient可以修饰域。java提供了一个框架，用来将对象编码成字节流（序列化 serializing），并从字节流编码中重新构建对象（反序列化 deserializing）。transient修饰符表明这个实例域将从一个类的默认序列化形式中省略掉。 意思就是临时的，不会随对象一起序列化，所以在反序列化时这个修饰符修饰的域将被初始化为它们的默认值：对于对象引用，默认值为null；对于数值基本域，默认值为0；对于boolean域，默认值为false。如果 这些值不能被任何transient域所接受，你就必须提供一个readObject方法，它首先调用defaultReadObject，然后把这些transient域恢复为可接受的值。另一种方法是，这些域可以被延迟到第一次使用的时候才 真正的被初始化。</td><br></tr><br><tr><br><td colspan="2"><strong>VOLATILE</strong></td><br></tr><br><tr><br><td></td><br><td>volatile可以修饰域，保证任何一个线程在读取该域的时候都将看到最近刚刚写入的值，但是volatile修饰符不执行互斥访问。volatile修饰的域在每次被线程访问时，都强迫从共享内存中重新读取该域的值。而且当域值发生改变时，强迫线程将变化值写回到共享内存中。这样在任何一个时刻，两个不同的线程总是看到被修饰域的同一个值。<br><br>java语言规范中写到：为了获取最佳的速度，允许线程保存共享成员变量的私有拷贝，而且只有当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。<br><br>这样当多个线程与同一个对象进行交互时，就必须要让线程及时得到共享成员变量的变化。而volatile修饰符的作用就是提示VM：对于被修饰成员变量不允许线程保存私有拷贝，而应让线程直接与共享成员变量交互。<br>在使用volatile修饰符是要小心下面情况：<br><pre class="lang:java decode:true ">//Broken - requires synchronization!<br>private static volatile int nextSerialNumber = 0 ;<br><br>public static int generateSerialNumber() {<br>    return nextSerialNumber ++;<br>}<br></pre><br>这个方法的目的是要确保每个调用都返回不同的值（只要不超过2的32次方个调用）。这个方法的状态只包含一个原子访问的域：nextSerialNumber，这个域的多有可能的值都是合法的。因此不需要任何同步来保护它的约束条件。然而，如果没有同步，这个方法仍然无法正常工作。<br><br>问题在于，增量操作符（++）不是一个原子操作。它在nextSerialNumber域中执行两项操作：首先读取它的值，然后写回一个新值，相当于原来的值再加上1。如果第二个线程在第一个线程读取旧值和写回一个新值期间读取这个域，第二个线程就会与第一个线程一起看到同一个值，并返回相同的序列号。这就是安全性失败（safety failure）：这个程序会计算出错误的结果。<br><br>修正generateSerialNumber方法的一种方法是在它的声明中增加synchronized修饰符。这样可以确保多个调用不会交叉存取，确保每个调用都会看到之前多有调用的效果。一旦这么做，就可以且应该从nextSerialNumber中删除volatile修饰符。为了让这个方法更可靠，要用long代替int，或者在nextSerialNumber快要重叠时抛出异常。<br><br>最好的方法是使用类AtomicLong，它是<em>*java.util.concurrent.atomic</em>的一部分。它所做的工作正是这里需要的。并且有可能比同步版的generateSerialNumber执行的更好：<br><pre class="lang:java decode:true ">private static final AtomicLong nextSerialNumber = new AtomicLong();<br><br>public static long generateSerialNumber() {<br>    return nextSerialNumber.getAndIncrement();<br>}<br></pre><br>当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步。如果没有同步，就无法保证一个线程所做的修改可以被另一个线程获知。未能同步共享可变数据会造成程序的活性失败（liveness failure）和安全失败（safety failure）。这样的失败是最难调试的。它们可能是间歇性的。而且与时间相关，程序的行为在不同的VM上可能根本不同。如果只需要线程之间的交互通信，而不需要互斥，volatile修饰符就是一种可以接受的同步形式，但是要正确使用它可能需要一些技巧。<br><br>当要访问的变量已经在synchronized代码块中，或者为常量时，不必使用该修饰符。<br><br>&nbsp;</td><br></tr><br></tbody><br></table><br></div><br><div style="color: #000000;font-family: 微软雅黑"><br><table><br><tbody><br><tr><br><td>Article Name:</td><br><td>JAVA修饰符</td><br></tr><br><tr><br><td>Author:</td><br><td>刘天昊</td><br></tr><br><tr><br><td>Email:</td><br><td>liutianhao.pro@gmail.com</td><br></tr><br></tbody><br></table><br></div>]]></content>
    <summary type="html">
    <![CDATA[<div style="color: #000000;font-family: 微软雅黑"><strong>java.lang.reflect.Modifier</strong><br><table><br><tbody><br><tr><br><td colspan="2"><strong>ABSTRACT</strong></td><br></tr><br><tr><br><td></td><br><td>Abstract(抽象)可以修饰类、方法。包含一个或多个抽象方法的类本身必须被声明为抽象类。除了抽象方法之外，抽象类还可以包含具体数据和具体方法。抽象方法充当着占位的角色，它们的具体实现在子类中。扩展抽象类可以有两种选择：一种是在子类中定义部分抽象方法或抽象方法也不定义，这样就必须将子类也标记为抽象类；另一种是定义全部的抽象方法，这样子类就不是抽象类了。<br><br>类即使不含有抽象方法也可以将类声明为抽象类。抽象类不能实例化。也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。不过可以定义一个抽象类的对象变量，但是它只能引用继承抽象类的非抽象子类的对象。<br><br>注意比较：<br><strong>private void</strong> <strong>print(){}</strong>；此语句表示方法的空实现。<br><strong>Abstract void</strong> <strong>print()</strong>； 此语句表示方法的抽象，无实现。<br><br>Abstract和static或者Abstract和final不能放在一起，否则便会出现错误。<br><br>&nbsp;</td><br></tr><br><tr><br><td><strong>FINAL</strong></td><br><td></td><br></tr><br><tr><br><td></td><br><td>final可以修饰类，方法，域。<br>域被声明为final，则构造对象之后就不允许改变它们的值了。如果被修饰的域是对象引用，则对象内的值还是可以改变的，但是对象的引用不能改变。（必须初始化，不能被修改）<br>方法被声明为final，可以确保方法不会在子类中改变语义，就是说不能被子类覆盖。<br><br>PS：早期JAVA中，有时为了避免动态绑定带来的系统开销而使用final修饰符。如果一个方法很短并且没有被覆盖，编译器就能够对它进行优化处理，这个过程被称为内联（inlining）。例如，内联调用e.getName()将被替换为访问e.name域。这是由于CPU在处理调用方法的指令时，使用的分支转移会扰乱预取指令策略，增加系统开销，使用内联可以避免这一开销。但是，如果getName在另一个类中被覆盖，那么编译器就无法知道覆盖的代码将会做什么操作，因此就不能对它进行内敛处理了。<br><br>不过现在虚拟机中的即时编译器比传统编译器的处理能力要强得多。这种编译器可以准确地知道类之间的继承关系，并能够检测出类中是否真正地存在覆盖给定的方法。如果方法简短，被调用频繁而且没有真正地被覆盖，那么即时编译器就会对这个方法进行内联处理。如果虚拟机加载了另一个类，而在这个类中包含对内联方法的覆盖，那么优化器将取消对覆盖方法的内联。这过程很慢而且很少发生。<br><br>类被声明为final，相当于其中的方法自动成为final方法，但是不包括类中的域。这种操作可以阻止利用被修饰的类定义子类。就是说不允许被继承的类被称为final类。一般来说一个类要么为继承设计，并提供文档说明；要么就禁止继承，成为一个final类。<br>]]>
    
    </summary>
    
      <category term="Java" scheme="http://androidperformance.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一张图记住Vim快捷键]]></title>
    <link href="http://androidperformance.com/2014/05/27/picture-about-vim/"/>
    <id>http://androidperformance.com/2014/05/27/picture-about-vim/</id>
    <published>2014-05-27T05:14:56.000Z</published>
    <updated>2015-03-26T12:45:53.000Z</updated>
    <content type="html"><![CDATA[<p>微博上的一张配图(感谢图片作者),可以设为壁纸,记住VIM的快捷键.关于Vim的使用,可以查看这里:<a href="http://www.grackertalk.com/%e4%bd%bf%e7%94%a8vim.html" title="使用VIM" target="_blank" rel="external">Vim使用教程</a></p>
<p><a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim快捷键.jpg" target="_blank" rel="external"><img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim快捷键.jpg" alt="vim快捷键"></a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>微博上的一张配图(感谢图片作者),可以设为壁纸,记住VIM的快捷键.关于Vim的使用,可以查看这里:<a href="http://www.grackertalk.com/%e4%bd%bf%e7%94%a8vim.html" title="使用VIM" target="_]]>
    </summary>
    
      <category term="Linux" scheme="http://androidperformance.com/categories/Linux/"/>
    
      <category term="开发工具推荐" scheme="http://androidperformance.com/categories/Linux/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用VIM]]></title>
    <link href="http://androidperformance.com/2014/05/25/usevim/"/>
    <id>http://androidperformance.com/2014/05/25/usevim/</id>
    <published>2014-05-25T12:27:20.000Z</published>
    <updated>2015-03-27T05:25:21.000Z</updated>
    <content type="html"><![CDATA[<div style="color: #000000;font-family: 微软雅黑"><br>    <span><br>        为什么有那么多编辑器我要使用vim？因为当我想保存文件时总是习惯性的：wq，即使我正在使用eclipse什么的~<br>        其实使用熟练使用vim可以让你完全摆脱鼠标，摆脱小键盘，摆脱方向键，你的手不用离开那块键盘区域就能完成你能想到的任何事情。<br>        不过vim并不算是个很友好的编辑器，刚开始使用你会觉得它十分特别非常极其的操蛋。你会想怎么会有人用这种东西，还不如notepad，不如gedit，更不如我比较喜欢用的sublime Text。但是如果你强迫自己使用一到两周后慢慢你会发现这东西真是让人爱不释手。<br>        刚开始使用这货的时候，也是各种蛋疼~去看各种VIM命令大全，VIM命令手册等等的吧，收效甚微，看了也记不住。后来慢慢觉得命令不是看会的，而是用会的。不要去记那些命令是什么，而是当你需要什么样的命令时再去找这样的命令，甚至你可以创造一个这样的命令。<br>    </span><br><a id="more"></a><br><br>#<br>        VIM的三种模式<br><br>    <span><br>        不过基本的还是要稍微介绍一下的。比如vim的模式。一打开vim什么都不动就是普通（Normal）模式，这个时候是不能输入的，刚开始用你会觉得妈的打开个编辑器还不让我写。不要着急~按一下i就可以插入了，这时候就进入了编辑（Insert ）模式。退出编辑模式可以使用[ESC]，按下[ESC]后回到Normal模式，这时候输“：”就会进入命令模式了，比如：q是退出。现在使用这个命令应该是退不出来了，因为已经编辑了，所以可以使用：q！，加上感叹号之后可以强制命令执行，当然你要是想保存的可以使用：wq，w是写入，q是退出，写入之后就可以退出了吧。执行以下卧槽还不行，木有文件名，vim也不知道写到哪里啊，跟上文件名，使用：wq filename，这个时候就能退出了，这时候当前目录下就会出现名字为filename的文件了，cat一下就是你刚才写的内容，当然你要是毛都没写那在：q的时候就退出了~<br>    </span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.01.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.01.gif" alt="vim.20140525.01">
        </a><br>    </div><br>    <span><br>        小节：三种模式，普通模式，编辑模式，命令模式，普通模式可以使用一下快捷键，命令模式可以使用命令，比如刚才的w和q，编辑模式就不啰嗦了。<br>    </span><br><br>#<br>        光标移动命令<br><br>    <span><br>        了解了vim的模式可以用了吧？不行~你是不知道怎么移动光标呢。。。那用方向键不行吗？可以是可以的~但是这样手要移动的距离就远了，效率不高了。vim有很多移动光标用的快捷键，也有很多类似的命令，这里可能介绍不全，太多了，我只说我常用的。<br>        h，j，k，l 这四个键就是移动光标用的快捷键，当然要记得快捷键是在普通模式下用的。用之前可以习惯性按一下[ESC]，h在最左边，所以h是左移，l在最右边，所以l是右移，j有个钩，看上去就是个下移的货，K就只能上移了，快来试一下吧。除了这几个快捷键还有很多<br>    </span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.02.jpg" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.02.jpg" alt="vim.20140525.02">
        </a><br>    </div><br>    <span><br>        随便试几下，感受一下，刚开始肯定不习惯，但是一定要管住自己的手，不要去使用方向键，慢慢去习惯。当然移动光标的方法有很多。<br>        常用快捷键：<br>    </span><br>    <table><br>        <tr> <td>gg</td> <td>移动到文件开头</td> </tr><br>        <tr> <td>G</td> <td>移动到文件末尾</td> </tr><br>        <tr> <td>Ctrl + e</td> <td>向下滚动一行</td> </tr><br>        <tr> <td>Ctrl + y</td> <td>向上滚动一行</td> </tr><br>        <tr> <td>Ctrl + d</td> <td>向下滚动半个屏幕</td> </tr><br>        <tr> <td>Ctrl + u</td> <td>向上滚动半个屏幕</td> </tr><br>        <tr> <td>Ctrl + f</td> <td>向下滚动一个屏幕</td> </tr><br>        <tr> <td>Ctrl + b</td> <td>向上滚动一个屏幕</td> </tr><br>        <tr> <td>-(减号)</td> <td>移动到上面一行的开始</td> </tr><br>        <tr> <td>+ / ENTURN(回车)</td> <td>移动到下面一行的开始</td> </tr><br>        <tr> <td>^ / 0</td> <td>移动到行开头</td> </tr><br>        <tr> <td>$</td> <td>移动到行末尾</td> </tr><br>        <tr> <td>w</td> <td>向右移动一个单词</td> </tr><br>        <tr> <td>W</td> <td>向右移动一个以空格为分隔符的单词</td> </tr><br>        <tr> <td>b</td> <td>向左移动一个单词</td> </tr><br>        <tr> <td>B</td> <td>向左移动一个以空格为分隔符的单词</td> </tr><br>        <tr> <td>e</td> <td>向右移动到一个单词的结尾</td> </tr><br>        <tr> <td>E</td> <td>向右移动到一个以空格为分隔符的单词的结尾</td> </tr><br>        <tr> <td>t(c)</td> <td>向右移动到指定字符(c)之前的一个字符</td> </tr><br>        <tr> <td>T(c)</td> <td>向左移动到指定字符(c)之后的一个字符</td> </tr><br>        <tr> <td>f(c)</td> <td>向右移动到指定字符(c)</td> </tr><br>        <tr> <td>F(c)</td> <td>向左移动到指定字符(c)</td> </tr><br>        <tr> <td>numG</td> <td>移动到第num行(与：num类似)</td> </tr><br>        <tr> <td>H / M / L</td> <td>移动到屏幕 顶部 / 中部 / 底部</td> </tr><br>        <tr> <td>&#096;&#096;(ESC下面那个按键按两次)</td> <td>光标回到之前的位置</td> </tr><br>    </table><br>    <span><br>        这些快捷键不需要一次都记住，看个大概就好，差不多知道有哪些功能就行，等到需要用了回来找一下，然后去用，这样印象深刻才能记得住。上面的快捷键中可能w,b,e三个快捷键的大小写的功能有点绕，用个图片来说明一下，w和W之间的却别，b，e两个与w类似，建议自己尝试一下。<br>    </span><br>    <span>使用w（小写）</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.02.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.02.gif" alt="vim.20140525.02">
        </a><br>    </div><br>    <span>使用W（大写）</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.03.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.03.gif" alt="vim.20140525.03">
        </a><br>    </div><br>    <span>常用命令：</span><br><br><em>   :num（行号）     比如:15就是跳到15行的第一个字符
</em>   :$              移动到文件末尾<br>    <span><br>        说到这再啰嗦一句，要分清楚命令和快捷键，命令要先进入命令模式，也就是先按“ : ”然后输入命令。快捷键是在普通模式下，也就是按完ESC之后可以直接按键。<br>        脱离了方向键的束缚这下可以让你的双手安安心心的放在主键盘区域了。现在学会了模式切换稍微回顾一下：<br>    </span><br><br><em>   [ ESC ]进入普通模式，可以使用快捷键。
</em>   [ : ]冒号进入命令模式，可以使用命令。<br><em>   [ i ]进入编辑模式，可以编写文本。<br>    <span><br>        学会模式切换，光标移动，还有基本命令就可以编写文本或者程序了，只是效率还不够高，用起来不太方便。没关系，慢慢来，弄VIM这事一定不能急，我第一次用的时候差点把键盘砸了。<br>    </span><br><br># 添加和修改文本<br><br>    <span><br>        要想给文件添加文本就要进入编辑模式（其实也不一定），进入编辑模式的快捷键可不只是i。<br>    </span>

</em>   i / I     在光标前插入  /  在该行第一个非空白字符前插入<br><em>   a / A     在光标后插入  /  在该行行尾插入
</em>   o / O     在当前行的下面新建一行  /  在当前行的上面新建一行<br><em>   r / R     替换光标指定的字符（一次替换一个）  /   替换从当前光标所在的字符开始，直到按ESC键结束<br>    <span><br>        这四个字母的效果都比较简单，可以自己试一下，这里演示一下 r 和 R 。<br>    </span><br>    <span>使用r（小写）</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.04.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.04.gif" alt="vim.20140525.04">
        </a><br>    </div><br>    <span>使用R（大写）</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.05.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.05.gif" alt="vim.20140525.05">
        </a><br>    </div><br>    <span><br>        这四个字母除了 r 和 R 都能使VIM进入编辑模式。编写代码或者文本还需要不断地修改或者删除文本，VIM有各种各样的删除快捷键和命令。<br>    </span>

</em>   x / X      删除光标所在字符 /  删除光标前面一个字符<br>    <span><br>        这个两个快捷键都可以通过连续按键达到持续删除的效果，要注意看光标所在字符。<br>    </span><br>    <span>使用x（小写）</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.06.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.06.gif" alt="vim.20140525.06">
        </a><br>    </div><br>    <span>使用X（大写）</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.07.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.07.gif" alt="vim.20140525.07">
        </a><br>    </div><br>    <span><br>        可以看出来 x（小写）会删掉光标所在字符， X （大写）则不会。当然要是觉得连续按不方便可以直接在前面加重复因子，说得这么高大上，其实就是在前面加数字比如：6x 就是相当于按6次x，效果就是删掉6个字符了。前面的数字可以很大不局限于一位数，比如99x也可以的，不过我觉得十以上的你也不会一个字符一个字符的数到你想删除的地方吧。小心眼花~<br>        再看两个字母 c / C 和 d / D<br>        这两个字母的用法差不多，效果也差不多，稍微有点区别的就是使用 c / C 相关的快捷键后会直接从命令模式进入编辑模式，而 d / D 相关的则依然停留在普通模式。<br>    </span><br><br><em>   cc / dd                 删除一整行
</em>   C, c$ / D, d$           从光标当前位置删除到行尾<br>    <span><br>        cc / dd 也是可以使用重复因子的，比如：5cc / 5dd<br>        在删除多行时除了使用上面的快捷键之外还可以使用命令。<br>    </span><br><br><em>   :num1,num2d             删除行号num1和num2之间的所有行，包含num1和num2。（命令要在命令模式下使用，先按“ : ”）<br>    <span><br>        注意 c$ / d$ 是 d / c 与另一个快捷键 $ 的结合，$ 的作用是把光标移到行尾，所以联想一下别的移动快捷键组合一下：<br>    </span>

</em>   c0, c^ / d0, d^<br><em>   cw / dw</em>   cW / dW<br><em>   ce / de
</em>   ……<br>    <span><br>        这种快捷键还有很多，你可以自己来尝试组合，并观察效果。<br>    </span><br>    <span>(c)代表一个字符</span><br><br><em>   ct(c) / dt(c)        从光标当前位置删除到当前行的下一个字符(c)，不包括(c)。
</em>   cf(c) / df(c)        从光标当前位置删除到当前行的下一个字符(c)，包括(c)。<br>    <span><br>        这里交叉演示一下ct(c) 和 df(c) ，除了要看清 t 和 f 的区别，还要注意之前说的 c 和 d 的区别。当然也可以使用 T 和 F ，方向相反而已。<br>    </span><br>    <span>使用ct&#060;</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.08.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.08.gif" alt="vim.20140525.08">
        </a><br>    </div><br>    <span>使用df&#060;</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.09.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.09.gif" alt="vim.20140525.09">
        </a><br>    </div><br>    <span>注意字符“ &lt; ”的删除情况和左下角显示的“插入”，这表示VIM进入了编辑模式。</span><br><br><em>   s / S         删除当前字符并进入编辑模式（相当于快捷键 x + i 的组合） /  删除当前行并进入编辑模式（相当于快捷键组合dd + O）<br>    <span><br>        这两个命令也是可是使用重复因子的，具体效果自己尝试。<br>        改变字母的大小写也是比较常见的需求，所以VIM当然会有对应的快捷键<br>    </span>

</em>   ~   光标所在字符变成大写或小写，与字母原状态相反。并且光标右移。<br><em>   gu / gU<br>    <span><br>        这个“ ~ ”同样可以使用重复因子，但是我还是不喜欢去数字符，所以连续按就好了。<br>        gu 和 gU可以像c 和 d 一样在后面加移动快捷键，把当前位置到指定位置的字母全部改变，比较直观的是gu就是变成小写，gU是变成大写。比如gu$ / gU$<br>    </span><br><br># 复制与粘贴<br><br>    <span> 复制快捷键y和d有点相似：</span>

</em>   yy, Y          复制当前行<br><em>   y0, y^</em>   y$<br><em>   ……<br>    <span>跟 d 差不多，同样可以在前面加重复因子，同样可以接移动快捷键，具体效果自己yy吧。而且复制多行的命令也类似：</span>

</em>   :num1,num2y          复制行号num1和num2之间的所有行，包含num1和num2。（命令要在命令模式下使用，先按“ : ”，其实我这条也是从前面 yy 过来的）<br>    <span>粘贴快捷键 </span><br><br>*   p / P       粘贴至光标后，若复制整行则粘贴在当前行的下面。 /   粘贴至光标前，若复制整行则粘贴在当前行的上面。<br>    <span>其实不只是 yy  后可以使用 p / P，dd之后也是可以的，你就当成是剪切吧。</span><br>    <span>快捷键组合 dd + j + j + p</span><br>    <div><br>        <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.10.gif" target="_blank" rel="external"><br>            <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.10.gif" alt="vim.20140525.10">
        </a><br>    </div>

<h1 id="搜索与替换（命令）">搜索与替换（命令）</h1><pre><code><span class="tag">&lt;<span class="title">span</span>&gt;</span>搜索命令<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
</code></pre><ul>
<li>:/rexp                      向前搜索rexp</li>
<li>:?rexp                      向后搜索rexp</li>
<li>:n                          重复最近一次搜索*   :N                          重复最近一次搜索，但方向相反</li>
<li>:/                          向前重复最近一次搜索</li>
<li>:？                         向后重复最近一次搜索</li>
<li><p>:%                          查找对应的括号如：(  ) , [  ] , {  }<br><span></span></p>
<pre><code>替换命令
替换命令的通用格式是   :[address]s<span class="regexp">/old/</span><span class="keyword">new</span>[<span class="regexp">/gc]</span>
</code></pre><p></p>
</li>
<li><p>address                行编号或者由都好分割的两个行编号，” . “代表当前行，” $ “代表最后一行，” % “代表全文，默认为当前行。</p>
</li>
<li>old / new              被替换的字符串 / 替换后的字符串</li>
<li>c                      替换前是否需要确认</li>
<li>g                      全局替换，每行不止替换一处。<br><span>比如使用   :%s/class/Class/gc</span><div><br>    <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.11.gif" target="_blank" rel="external"><br>        <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.11.gif" alt="vim.20140525.11">
    </a><br></div><br><span>也可以用来做注释用。 :%s/^/#/g</span><br><div><br>    <a href="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.12.gif" target="_blank" rel="external"><br>        <img src="http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.12.gif" alt="vim.20140525.12">
    </a><br></div>

</li>
</ul>
<h1 id="区块模式">区块模式</h1><pre><code><span class="tag">&lt;<span class="title">span</span>&gt;</span>
    首先按esc进入命令行模式下，按下Ctrl + v，进入列（也叫区块）模式；在行首使用上下键选择需要注释的多行。
    然后可以进行删除或者插入等操作，比如也来个多行注释吧。
    选择多行后按 I （大写），然后写注释符号，按下ESC，稍等一下注释就出来了。
<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
<span class="tag">&lt;<span class="title">div</span>&gt;</span>
    [
        ![vim.20140525.13](http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.13.gif)
    ](http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.13.gif)
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>
</code></pre><h1 id="其他快捷键和命令">其他快捷键和命令</h1><pre><code>&lt;span&gt;
    <span class="constant">VIM还</span>有很多快捷键和命令，这里不可能说全，如图：[<span class="constant">VIM.</span>png](<span class="symbol">http:</span>/<span class="regexp">/coolshell.cn/</span><span class="regexp">/wp-content/uploads</span><span class="regexp">/2009/</span><span class="number">03</span>/vim.png)
    下面在列举几个常用的吧。
&lt;<span class="regexp">/span&gt;</span>
</code></pre><ul>
<li>J（大写）             将当前行与下一行连接起来</li>
<li>.                    重复上一次命令</li>
<li>u                    撤销（可连续使用）</li>
<li>Ctrl + r             取消上一次撤销（可连续使用）</li>
<li>Ctrl + P / Ctrl + n  插入模式下使用的快捷键，补全一个词，p是向上搜索，n是向下搜索。</li>
<li><p>Ctrl + xl            插入模式下使用的快捷键，补全一行，Ctrl + P / Ctrl + n 选择上一个或者下一个匹配。<br><span>使用快捷键组合 J + . (连续三次) + u(连续四次) + <a href="连续四次">Ctrl + r</a></span><br><div></div></p>
<pre><code><span class="collection">[
    !<span class="collection">[vim.20140525.14]</span><span class="list">(<span class="keyword">http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.14.gif</span>)</span>
]</span><span class="list">(<span class="keyword">http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.14.gif</span>)</span>
</code></pre><p></p></li></ul></div><br><span>使用Ctrl + P / Ctrl + n 和 使用Ctrl + xl </span><br><div><p></p>
<pre><code><span class="collection">[
    !<span class="collection">[vim.20140525.15]</span><span class="list">(<span class="keyword">http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.15.gif</span>)</span>
]</span><span class="list">(<span class="keyword">http://www.grackertalk.com/wp-content/uploads/2014/05/vim.20140525.15.gif</span>)</span>
</code></pre><p></p></div><br><span>命令</span><p></p>

<li><p>:w ， :w filename， :q! ， :wq          这四个命令前面都说过了，不再赘述。*   :&#120;                将工作缓存区内容写入当前文件并退出（与快捷键 ZZ 相同），功能与 :wq 相同。</p>
</li>
<li>:sp / :vsp   横向分屏，竖向分屏。</li>
<li>:e                打开另一个文件</li>
<li>:ls                查看已经打开的文件。</li>
<li>:!bash         执行shell命令<br><span><pre><code>关于分屏和打开多文件建议查看博客：[<span class="link_label">http://coolshell.cn/articles/11312.html</span>](<span class="link_url">http://coolshell.cn/articles/11312.html</span>)
终极命令 :help
</code></pre></span></li>

<h1 id="配置文件">配置文件</h1><pre><code>&lt;span&gt;
    可以通过对VIM配置文件进行修改来达到打开自动配置的效果。比如显示行号。一般修改当前用户的配置文件就可以了，路径<span class="string">" ~/.vimrc "</span>，如果文件不存在可以新建一个。
&lt;/span&gt;
&lt;span&gt;
    <span class="built_in">set</span> ts=<span class="number">4</span>
    <span class="built_in">set</span> expandtab
    <span class="built_in">set</span> ai
    <span class="built_in">set</span> nu
    <span class="built_in">let</span> mapleader=<span class="string">","</span>
    inoremap ( ()
    inoremap [ []
    inoremap { {}
    inoremap <span class="string">' '</span><span class="string">'
    inoremap " ""
&lt;/span&gt;
&lt;span&gt;
    这是一份非常简单的配置文件。里面配置了tab是4个空格，自动缩进，显示行号等等~还有映射。通过映射我们可以设计自己的命令。通过配置文件也可以配置VIM的插件，VIM的插件系统可是十分强大，足够让你打造一个完美的开发环境。快去尝试吧。
&lt;/span&gt;</span>
</code></pre><p></p>
<div style="color: #000000;font-family: 微软雅黑"><br>    <table><br>        <tr><br>            <td>Article Name:</td><br>            <td>使用VIM</td><br>        </tr><br>        <tr><br>            <td>Author:</td><br>            <td>刘天昊</td><br>        </tr><br>        <tr><br>            <td>Email:</td><br>            <td>liutianhao.pro@gmail.com</td><br>        </tr><br>    </table><br></div>]]></content>
    <summary type="html">
    <![CDATA[<div style="color: #000000;font-family: 微软雅黑"><br>    <span><br>        为什么有那么多编辑器我要使用vim？因为当我想保存文件时总是习惯性的：wq，即使我正在使用eclipse什么的~<br>        其实使用熟练使用vim可以让你完全摆脱鼠标，摆脱小键盘，摆脱方向键，你的手不用离开那块键盘区域就能完成你能想到的任何事情。<br>        不过vim并不算是个很友好的编辑器，刚开始使用你会觉得它十分特别非常极其的操蛋。你会想怎么会有人用这种东西，还不如notepad，不如gedit，更不如我比较喜欢用的sublime Text。但是如果你强迫自己使用一到两周后慢慢你会发现这东西真是让人爱不释手。<br>        刚开始使用这货的时候，也是各种蛋疼~去看各种VIM命令大全，VIM命令手册等等的吧，收效甚微，看了也记不住。后来慢慢觉得命令不是看会的，而是用会的。不要去记那些命令是什么，而是当你需要什么样的命令时再去找这样的命令，甚至你可以创造一个这样的命令。<br>    </span><br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://androidperformance.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[个人收藏的技术相关博客及其RSS地址(持续更新)]]></title>
    <link href="http://androidperformance.com/2014/05/21/it-blog-rss-list/"/>
    <id>http://androidperformance.com/2014/05/21/it-blog-rss-list/</id>
    <published>2014-05-21T13:25:03.000Z</published>
    <updated>2015-03-27T05:24:19.000Z</updated>
    <content type="html"><![CDATA[<p>这个项目记录了个人订阅的一些科技人的Blog地址,欢迎大家推荐,一起来完善!我使用的Mac客户端的Rss软件Readkit,如果你有更好的Rss阅读软件,欢迎推荐.目前手机上还没有找到对应的软件,Readkit没有手机的版本,也不知道什么时候会出手机版本.ORZ……目前的数量还不多,希望大家能多推荐些,但是最好是那种质量比较高的Blog,每个人的时间都有限,把最好的时光浪费在美好的事物上.</p>
<p><strong>本文内容的github地址:<a href="https://github.com/Gracker/Rss-IT" target="_blank" rel="external">https://github.com/Gracker/Rss-IT</a> 欢迎大家补充和推荐.github和本Blog我会持续更新.</strong></p>
<a id="more"></a>
<h2 id="技术博客"><strong>技术博客</strong></h2><ol>
<li>酷壳<br>网站 : <a href="http://coolshell.cn/" target="_blank" rel="external">CoolShell.cn</a><br>Rss地址 : <a href="http://coolshell.cn/feed" target="_blank" rel="external">http://coolshell.cn/feed</a></li>
<li>老赵点滴 - 追求编程之美<br>网站 : <a href="http://blog.zhaojie.me/" target="_blank" rel="external">blog.zhaojie.me</a><br>Rss地址 : <a href="http://blog.zhaojie.me/rss" target="_blank" rel="external">http://blog.zhaojie.me/rss</a></li>
<li>阮一峰的网络日志<br>网站 : <a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="external">ruanyifeng.com/blog</a><br>Rss地址 : <a href="http://www.ruanyifeng.com/blog/atom.xml" target="_blank" rel="external">http://www.ruanyifeng.com/blog/atom.xml</a></li>
<li>四火的唠叨<br>网站 : <a href="http://www.raychase.net/" target="_blank" rel="external">raychase.net</a><br>Rss地址 : <a href="http://www.raychase.net/feed" target="_blank" rel="external">http://www.raychase.net/feed</a></li>
<li>云风的 BLOG<br>网站 : <a href="http://blog.codingnow.com/" target="_blank" rel="external">blog.codingnow.com</a><br>Rss地址 : <a href="http://blog.codingnow.com/atom.xml" target="_blank" rel="external">http://blog.codingnow.com/atom.xml</a></li>
<li>运维与架构<br>网站 : <a href="http://www.nginx.cn/" target="_blank" rel="external">nginx.cn</a><br>Rss地址 : <a href="http://www.nginx.cn/feed" target="_blank" rel="external">http://www.nginx.cn/feed</a></li>
<li>ImportNew<br>网站 : <a href="http://www.importnew.com/" target="_blank" rel="external">importnew.com</a><br>Rss地址 : <a href="http://www.importnew.com/feed" target="_blank" rel="external">http://www.importnew.com/feed</a></li>
<li>Styling Android<br>网站 : <a href="http://blog.stylingandroid.com/" target="_blank" rel="external">blog.stylingandroid.com</a><br>Rss地址 : <a href="http://feeds.feedburner.com/StylingAndroid" target="_blank" rel="external">http://feeds.feedburner.com/StylingAndroid</a></li>
<li>Trinea<br>网站 : <a href="http://www.trinea.cn/" target="_blank" rel="external">trinea.cn</a><br>Rss地址 : <a href="http://feed.feedsky.com/trinea" target="_blank" rel="external">http://feed.feedsky.com/trinea</a></li>
<li>破船之家<br>网站 : <a href="http://www.beyondvincent.com/" target="_blank" rel="external">beyondvincent.com</a><br>Rss地址 : <a href="http://beyondvincent.com/atom.xml" target="_blank" rel="external">http://beyondvincent.com/atom.xml</a></li>
<li>老罗的Android开发之旅<br>网站 : <a href="http://blog.csdn.net/luoshengyang" target="_blank" rel="external">blog.csdn.net/luoshengyang</a><br>Rss地址 : <a href="http://blog.csdn.net/luoshengyang/rss/list" target="_blank" rel="external">http://blog.csdn.net/luoshengyang/rss/list</a></li>
<li>代码家<br>网站 : <a href="http://blog.daimajia.com/" target="_blank" rel="external">blog.daimajia.com</a><br>Rss地址 : <a href="http://blog.daimajia.com/feed/" target="_blank" rel="external">http://blog.daimajia.com/feed/</a></li>
<li>fookwood<br>网站 : <a href="http://www.fookwood.com/" target="_blank" rel="external">fookwood.com</a><br>Rss地址 : www.fookwood.com/feeding</li>
<li>Android Notice<br>网站 : <a href="http://androidniceties.tumblr.com/" target="_blank" rel="external">androidniceties.tumblr.com/</a><br>Rss地址 : <a href="http://androidniceties.tumblr.com/rss" target="_blank" rel="external">http://androidniceties.tumblr.com/rss</a></li>
<li>sage42<br>网站 : <a href="http://www.sage42.org/" target="_blank" rel="external">sage42.org</a><br>Rss地址 : <a href="http://www.sage42.org/feed/" target="_blank" rel="external">http://www.sage42.org/feed/</a></li>
<li>danlew — Android小技巧<br>网站 : <a href="http://blog.danlew.net/" target="_blank" rel="external">blog.danlew.net</a><br>Rss地址 : <a href="http://blog.danlew.net/rss/" target="_blank" rel="external">http://blog.danlew.net/rss/</a></li>
<li>Job伯乐在线-Android频道<br>网站 : <a href="http://blog.jobbole.com/" target="_blank" rel="external">blog.jobbole.com/</a><br>Rss地址 : <a href="http://blog.jobbole.com/category/android/feed/" target="_blank" rel="external">http://blog.jobbole.com/category/android/feed/</a></li>
</ol>
<h2 id="非技术博客"><strong>非技术博客</strong></h2><ol>
<li>MacTalk-池建强的随想录<br>网站 : <a href="http://www.macshuo.com/" target="_blank" rel="external">macshuo.com</a><br>Rss地址 : <a href="http://macshuo.com/?feed=rss2" target="_blank" rel="external">http://macshuo.com/?feed=rss2</a></li>
<li>少数派 - 数字生活传道者<br>网站 : <a href="http://www.sspai.com/" target="_blank" rel="external">sspai.com</a><br>Rss地址 : <a href="http://sspai.com/feed" target="_blank" rel="external">http://sspai.com/feed</a></li>
<li>Linux中国<br>网站 : <a href="http://linux.cn/" target="_blank" rel="external">linux.cn/</a><br>全站RSS ： <a href="http://linux.cn/rss.xml" target="_blank" rel="external">http://linux.cn/rss.xml</a><br>技术RSS ： <a href="http://linux.cn/rss-tech.xml" target="_blank" rel="external">http://linux.cn/rss-tech.xml</a><br>新闻RSS ： <a href="http://linux.cn/rss-news.xml" target="_blank" rel="external">http://linux.cn/rss-news.xml</a><br>评论RSS ： <a href="http://linux.cn/rss-talk.xml" target="_blank" rel="external">http://linux.cn/rss-talk.xml</a><br>分享RSS ： <a href="http://linux.cn/rss-share.xml" target="_blank" rel="external">http://linux.cn/rss-share.xml</a></li>
<li>谷奥 :喜欢Google的必备。质量很高。<br>网站 : <a href="http://www.guao.hk/" target="_blank" rel="external">guao.hk</a><br>Rss : <a href="http://www.guao.hk/feed" target="_blank" rel="external">http://www.guao.hk/feed</a></li>
<li>苹果fans: 每天一篇真正有用的苹果教程或新闻<br>网站 : <a href="http://www.mac52ipod.cn/index.php" target="_blank" rel="external">mac52ipod.cn</a><br>Rss地址 : <a href="http://feed.feedsky.com/applefan" target="_blank" rel="external">http://feed.feedsky.com/applefan</a></li>
</ol>
<h2 id="本人的博客"><strong>本人的博客</strong></h2><ol>
<li>但行好事 莫问前程 — GrackerTalk<br>网站 : <a href="http://www.grackertalk.com/" target="_blank" rel="external">grackertalk.com</a><br>Rss地址 : <a href="http://www.grackertalk.com/feeding" target="_blank" rel="external">http://www.grackertalk.com/feeding</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p>这个项目记录了个人订阅的一些科技人的Blog地址,欢迎大家推荐,一起来完善!我使用的Mac客户端的Rss软件Readkit,如果你有更好的Rss阅读软件,欢迎推荐.目前手机上还没有找到对应的软件,Readkit没有手机的版本,也不知道什么时候会出手机版本.ORZ……目前的数量还不多,希望大家能多推荐些,但是最好是那种质量比较高的Blog,每个人的时间都有限,把最好的时光浪费在美好的事物上.</p>
<p><strong>本文内容的github地址:<a href="https://github.com/Gracker/Rss-IT">https://github.com/Gracker/Rss-IT</a> 欢迎大家补充和推荐.github和本Blog我会持续更新.</strong></p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Github" scheme="http://androidperformance.com/categories/Android/Github/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Wordpress]修改主题后导致博客白屏的一种原因分析及解决办法]]></title>
    <link href="http://androidperformance.com/2014/05/18/wordpress-change-theme-with-blank/"/>
    <id>http://androidperformance.com/2014/05/18/wordpress-change-theme-with-blank/</id>
    <published>2014-05-18T01:05:51.000Z</published>
    <updated>2015-03-27T05:26:01.000Z</updated>
    <content type="html"><![CDATA[<p>对于使用<a href="http://wpchina.org/" target="_blank" rel="external">WordPress</a>建立个人博客的同学们来说，遭遇前后台白屏问题是一件非常令人郁闷的事情。wordpress白屏错误之所以令人郁闷，最重要的是你无法获知任何的错误信息，也没有弹出的对话提示，让人修复起来无从下手。想象一下你正在修改博客上的一个设置，或安装或升级一个插件，或升级最新版本的WordPress，或只是打开你的博客开始新的一天，但是你看到的，只是一个空白屏幕,估计想死的心都有了,于是各种google+百度,甚至bing都用上了,还是没有解决,结果若干配置文件被弄得越来越乱……</p>
<h2 id="0-问题背景">0.问题背景</h2><p>在站长工具<a href="http://www.google.com.hk/webmasters/tools/richsnippets?q=http%3A%2F%2Fgrackertalk.com%2F" target="_blank" rel="external">Google Structured Data Testing Tool</a>中跑网站测试的时候,发现会有很多bug导致搜索结果的富内容不完善,有个人信息(与Google+相连),也有文章中的Bug,我使用的主题是Dinky,作者是<span style="color: #121212;"><a href="http://misam.ir/" target="_blank" rel="external">Misam Saki</a>,就会出现:错误： Missing required field “updated”.</span></p>
<p>找到错误后,就去进行相应地修改,这个错误的意思就是说,文章中缺少updated这个字段,是因为有的主题(也可能是所有wordpress主题,不确定)会把updated这个字段去掉,用post_on这样类似的字段来代替.OK,原因找到了,就可以去修改了.然后就呵呵呵了.</p>
<p>找到functions.php,找到显示post_on相关的字段,加上update字段(网上摘抄),点击更新…..然后…..就没有然后了.不管怎么刷,网站的所有页面都是白屏,啥都看不到.</p>
<a id="more"></a>
<h2 id="1-问题解决">1.问题解决</h2><p>昨天遇到这个问题两次,第一次可谓大动干戈,差点就重装VPS了(把wordpress重装了一下,所有的插件,主题都重装的),最后发现还是不行,白屏,最后侥幸进了后台(重装之前后台也进不了),把改坏了的主题替换成其他的主题,熟悉的界面又一次出现了(泪流满面,果然是no zuo no die).</p>
<p>第二次又碰到了这个原因(不是说no zuo no die么?唐僧不是有一句话,我不下地狱,谁下地狱?),好吧自我安慰一下.这次就很镇定了,分析了一下问题后,尝试了Google出的一些方法,大部分是说编码问题,可是我的编码是utf8,没有问题.后来想了想,问题还是出在functions.php上,但是网页修改主题的界面是空白,就算返回可以看到修改前的文件,点击更新就会白屏.</p>
<p><span style="color: #ff0000;">于是远程登录vps后台,找到wordpress的根目录,进入到 /wo-content/theme/下,找到对应的主题,进去看这个主题的functions.php,发现被我改坏的哪一行依旧在,意思就是说前台的修改并没有成功.ORZ……删掉那一行之后又看到了熟悉的界面,</span>这次前后不到5分钟,虽然是个小问题,但是记录下来,如果能帮大家一个忙,也是不错的.</p>
<p>&nbsp;</p>
<h2 id="2-延伸阅读">2.延伸阅读</h2><p>wordpress白屏问题估计每个建站的人都会碰到,一般遇到这种问题之后,先不要慌,想想自己进行了哪些操作,去后台把这些操作还原一下,比如删掉刚刚下载的某个插件,或者刚刚应用的那个主题….之类的,重装是下下策.谨记,.</p>
<p>同时也说明备份是个好习惯,不至于一下损失太大.哈哈</p>
<p>&nbsp;</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于使用<a href="http://wpchina.org/">WordPress</a>建立个人博客的同学们来说，遭遇前后台白屏问题是一件非常令人郁闷的事情。wordpress白屏错误之所以令人郁闷，最重要的是你无法获知任何的错误信息，也没有弹出的对话提示，让人修复起来无从下手。想象一下你正在修改博客上的一个设置，或安装或升级一个插件，或升级最新版本的WordPress，或只是打开你的博客开始新的一天，但是你看到的，只是一个空白屏幕,估计想死的心都有了,于是各种google+百度,甚至bing都用上了,还是没有解决,结果若干配置文件被弄得越来越乱……</p>
<h2 id="0-问题背景">0.问题背景</h2><p>在站长工具<a href="http://www.google.com.hk/webmasters/tools/richsnippets?q=http%3A%2F%2Fgrackertalk.com%2F">Google Structured Data Testing Tool</a>中跑网站测试的时候,发现会有很多bug导致搜索结果的富内容不完善,有个人信息(与Google+相连),也有文章中的Bug,我使用的主题是Dinky,作者是<span style="color: #121212;"><a href="http://misam.ir/">Misam Saki</a>,就会出现:错误： Missing required field “updated”.</span></p>
<p>找到错误后,就去进行相应地修改,这个错误的意思就是说,文章中缺少updated这个字段,是因为有的主题(也可能是所有wordpress主题,不确定)会把updated这个字段去掉,用post_on这样类似的字段来代替.OK,原因找到了,就可以去修改了.然后就呵呵呵了.</p>
<p>找到functions.php,找到显示post_on相关的字段,加上update字段(网上摘抄),点击更新…..然后…..就没有然后了.不管怎么刷,网站的所有页面都是白屏,啥都看不到.</p>]]>
    
    </summary>
    
      <category term="Wordpress" scheme="http://androidperformance.com/categories/Wordpress/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Android4.4]第三方APP无法操作外置SD卡原因分析以及延伸阅读]]></title>
    <link href="http://androidperformance.com/2014/05/17/apps-can-no-android4-4-app-longer-write-files-to-your-sd-card/"/>
    <id>http://androidperformance.com/2014/05/17/apps-can-no-android4-4-app-longer-write-files-to-your-sd-card/</id>
    <published>2014-05-17T03:20:30.000Z</published>
    <updated>2015-03-27T05:20:04.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-问题背景:">1.问题背景:</h3><p>最近做Android4.4的平台移植,遇到一个问题:在Android4.4中,第三方App是没有权限操作外置SD卡的(除非是与自己包名相同的目录),开始以为是自己申请的权限不足,最后发现是Google在Android中限制了这一权限.这是原文:</p>
<blockquote>
<p><span style="\"color:" #404040;\"="">The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions.</span></p>
</blockquote>
<p>意思就是说,只有主存储有读写的权限,第二存储(通常是外置SD卡或者USBOTG,这个可以在设置菜单中自己设置)只有读的权限.原因也有给出:</p>
<blockquote>
<p><span style="\"color:" #404040;\"="">Restricting writes in this way ensures the system can clean up files when applications are uninstalled.</span></p>
</blockquote>
<p>另一个原因我觉得是安全的问题,这一方面的陈述会在下面详细介绍.</p>
<a id="more"></a>
<h3 id="2-解决办法:">2.解决办法:</h3><p>解决办法分两种,一种针对用户,一种针对开发者.</p>
<p><strong><em>针对用户:</em></strong></p>
<p>已经root的用户可以通过修改:<span style="\"color:" #444444;\"="">/system/etc/permissions/platform.xml</span> 文件(使用RE文件管理器即可),找到如下代码块:</p>
<pre class="\"lang:java" decode:true\"="" title="\"写sd卡的权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>修改为:</p>
<pre class="\"lang:java" decode:true\"="" title="\"修改后的写SD卡权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;group gid=\"media_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>然后重启.就可以读写SD卡了.</p>
<p>这个做法其实就是给<span style="\"color:" #666666;\"="">android.permission.WRITE_EXTERNAL_STORAGE</span> 这个权限组加上对media的读写权限.</p>
<p><strong><em>针对开发者:</em></strong></p>
<p><span style="\"color:" #323333;\"="">XDA论坛上的方法，先把文件改为图片类型，再用media content provider来删除.</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"转换成媒体文件,再进行操作\"">private static final Uri FILES_URI = MediaStore.Files.getContentUri(\"external\");
    public static boolean deleteFile(Context context, String path) {
        ContentResolver cr = context.getContentResolver();
        if (cr == null) return false;
        final String selection = FileColumns.DATA + \"=?\";
        final String[] selectionArgs = new String[] { path };
        ContentValues values = new ContentValues();
        values.put(FileColumns.MEDIA_TYPE, FileColumns.MEDIA_TYPE_IMAGE);
        return cr.update(FILES_URI, values, selection, selectionArgs) &gt; 0
                &amp;&amp; cr.delete(FILES_URI, selection, selectionArgs) &gt; 0;
    }</pre>

<p>这样做是因为MediaProvider拥有读写SD卡的 权限,通过它去操作文件也可以达到目标.不过有人反映如果把默认存储设置为内置SD卡，该方法貌似就失效了。不知道有没有更好的办法？</p>
<p><strong><em>针对rom开发者:</em></strong></p>
<p>rom开发者有更好的选择,<span style="\"color:" #444444;\"="">platform.xml的文件位置在源代码:frameworks/base/data/etc/中,和方法1中的步骤一样:</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"写sd卡的权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>修改为:</p>
<pre class="\"lang:java" decode:true\"="" title="\"修改后的写SD卡权限\"">    &lt;permission name=\"android.permission.WRITE_EXTERNAL_STORAGE\" &gt;
        &lt;group gid=\"sdcard_r\" /&gt;
        &lt;group gid=\"sdcard_rw\" /&gt;
    &lt;group gid=\"media_rw\" /&gt;
    &lt;/permission&gt;</pre>

<p>然后重新编译一个rom即可.</p>
<p>&nbsp;</p>
<h3 id="3-延伸阅读">3.延伸阅读</h3><p>Google这么做的原因,我也查阅了一些文章,下面是一些我觉得比较好的回答,大家感兴趣可以自己看一下:</p>
<p>第一篇是Google+上的一个人的分析,大概解释了一下google这样做的原因以及造成的影响(英文很简单):</p>
<blockquote>
<p><span style="\"color:" #404040;\"="">KitKat will make your SD Card completely useless: per the Android API specification, apps can no longer write files to your SD card.  And Samsung is following it.This only applies to dual-storage devices, i.e., devices with a user-writable internal flash storage <strong>AND</strong> a removable SD card.</span></p>
<p><span style="\"color:" #404040;\"="">From </span><span style="\"color:" #427fed;\"=""><a href="http://source.android.com/devices/tech/storage/index.html" target="_blank" rel="external">http://source.android.com/devices/tech/storage/index.html</a></span><span style="\"color:" #404040;\"="">:\”The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions.\”</span></p>
<p><span style="\"color:" #404040;\"="">If your device has user-accessible internal flash storage, your SD Card is a \”secondary external storage device\”.</span></p>
<p><span style="\"color:" #404040;\"="">What this means is that with KitKat, applications will no longer be able create, modify, or remove files and folders on your external SD card.  As a for-instance, you can no longer use a file manager to copy files from your computer to the SD card over a network.  This ability, which has existed since the beginning of Android, has been taken away.</span></p>
<p><span style="\"color:" #404040;\"="">The only stated reason for this removal of functionality is that, \”Restricting writes in this way ensures the system can clean up files when applications are uninstalled.\”  I do not pretend to understand this logic.  Apps are still allowed to write in arbitrary directories on the primary storage (with the appropriate permission), but are denied the same access to external storage.</span></p>
<p><span style="\"color:" #404040;\"="">Samsung has implemented this feature with their KitKat OTA updates.  Note3 users are now complaining that FX File Explorer can no longer write to their external SD cards.  There are solutions to this problem for users with root access.  Users without root access appear to be screwed.</span></p>
<p><span style="\"color:" #404040;\"="">I\’m not quite certain how Google intends for you to place files on your SD card.  Perhaps you have to use proprietary Google apps that contain permissions unavailable to the rest of the developer world.  Perhaps you\’re supposed to put everything on the cloud and pay carrier data fees to get it there.  Perhaps you\’re supposed to use some kind of WIRE to attach your WIRELESS device to your computer and have the computer do that work for you.</span></p>
<p><span style="\"color:" #404040;\"="">In my opinion this is a horrible misstep by Google and the Android Open Source Project.  Functionality has been removed without reason, to the severe detriment of users and developers alike.</span></p>
<p><span style="\"color:" #404040;\"="">I apologize for not bringing this to everyone\’s attention when KitKat 4.4 was released, but it was not mentioned in the Android 4.4 changes document:</span><span style="\"color:" #427fed;\"=""><a href="http://developer.android.com/about/versions/android-4.4.html" target="_blank" rel="external">http://developer.android.com/about/versions/android-4.4.html</a></span><span style="\"color:" #404040;\"="">.  It\’s only mentioned in the article on </span><span style="\"color:" #427fed;\"="">source.android.com</span><span style="\"color:" #404040;\"="">.  I was only made aware of its existence from user reports as a result of Samsung implementing this change in its KitKat OTA updates. </span></p>
</blockquote>
<p>第二篇是知乎上的讨论,大家自行脑补:</p>
<blockquote>
<p><span style="\"color:" #232323;\"="">这有可能真的只是一个限制，影响很小，因为这个限制并不彻底，primary external storage 仍然可写，而支持双 SD 的设备并不很多。我们大家更期待的是让 primary external storage 也同样受到这个限制，虽然这个修改将涉及到更多应用的不兼容。</span></p>
<p><span style="\"color:" #232323;\"="">所以这个问题并没有彻底解决，到对 primary external storage 也限制的那个时候，才真正的解决了这个问题。</span></p>
<p><span style="\"color:" #232323;\"="">就目前而言，第二 SD 卡仍然是可以读写的，只是要读写到指定的目录（具体应该在 /Android/data/）。这样的规定意味着应用程序只能对 SD 卡的指定目录进行读写，不能读写任意目录。相当于 Google 出手对 SD 卡目录结构进行了规范。之前 android 不限制目录，所以各种应用就随意的在 SD 卡上建一个目录。然后 SD 卡上的目录到处都是，用户对这种现象早就深恶痛绝了！如果 Google 对这件事情下狠手，只能说是<strong>大快人心</strong>。</span></p>
<p><span style="\"color:" #232323;\"="">另外说一下，SD 卡上的指定目录是这样获取的：</span><br><span style="\"color:" #232323;\"="">1，程序相关的 内置存储目录，这个目录位于内置 flash，应用程序可以随意读写：</span></p>
<p><pre class="\"lang:java" decode:true\"="">getFilesDir();</pre><br><span style="\"color:" #232323;\"="">2，程序相关的 SD 卡外部存储目录，这个目录位于 SD 卡，应用程序可以随意读写：</span></p>
<p><pre class="\"lang:java" decode:true="" crayon-selected\"="">getExternalFilesDir(null);</pre><br><span style="\"color:" #232323;\"="">3，SD 卡公共目录，这些目录仍然可以访问，不受权限限制：</span></p>
<p><pre class="\"lang:java" decode:true\"="">Environment.getExternalStoragePublicDirectory(x)</pre><br><span style="\"color:" #232323;\"="">其中 x 可以是 Environment.DIRECTORY_ALARMS 等预定义的常量。可以查找 Environment 的帮助。</span></p>
<p><span style="\"color:" #232323;\"="">如果大家要存储数据，可以用 1 或者 2 的方法，获取正确的目录，然后进行任意读写，这样不会把 SD 卡的目录写乱。</span></p>
</blockquote>
<p>第三篇也是知乎上一个讨论:</p>
<blockquote>
<p><span style="\"color:" #232323;\"="">Google 给出的理由有一定的道理——相信很多有洁癖的人都很讨厌第三方应用在 SD 卡或者内置存储下随意建立文件夹吧，有节操的应用应该只在以自己的包名区分的目录下存放需要的文件。</span></p>
<p><span style="\"color:" #232323;\"="">至于为什么只限制 SD 卡，不包括内置存储，我觉得是因为 SD 卡是可以插在别的地方的，目录结构是有可能暴露出来的，也有可能被修改。规范应用在 SD 卡的读写，可以使得这个 SD 卡上的目录和文件可以在其他设备上被电脑「理解」——「这个目录是在某一个 Android 设备上用到的，我不必理会它」，如果第三方应用随意在 SD 卡根目录创建命名不规范并且无规律的目录，这个 SD 卡在其他地方就会使电脑或者人迷惑——「这个目录是干什么的？是谁创建的？我可不可以删掉它？」。手机的内部存储空间不能拆卸，所以其目录结构不会轻易暴露给用户，也不会放在别的设备上，所以可以暂时不管。</span></p>
</blockquote>
<p>&nbsp;</p>
<p>参考:</p>
<p>1.<a href="\">https://plus.google.com/+TodLiebeck/posts/gjnmuaDM8sn</a></p>
<p>2.<a href="\">http://www.zhihu.com/question/22778889</a></p>
<p>3.<a href="\">http://source.android.com/devices/tech/storage/index.html</a></p>
<p>&nbsp;</p>
<p>相关阅读 :</p>
<ol>
<li><a href="\">Android4.4中扫描文件广播权限变更分析</a></li>
</ol>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-问题背景:">1.问题背景:</h3><p>最近做Android4.4的平台移植,遇到一个问题:在Android4.4中,第三方App是没有权限操作外置SD卡的(除非是与自己包名相同的目录),开始以为是自己申请的权限不足,最后发现是Google在Android中限制了这一权限.这是原文:</p>
<blockquote>
<p><span style=\"color: #404040;\">The WRITE_EXTERNAL_STORAGE permission must only grant write access to the primary external storage on a device. Apps must not be allowed to write to secondary external storage devices, except in their package-specific directories as allowed by synthesized permissions.</span></p>
</blockquote>
<p>意思就是说,只有主存储有读写的权限,第二存储(通常是外置SD卡或者USBOTG,这个可以在设置菜单中自己设置)只有读的权限.原因也有给出:</p>
<blockquote>
<p><span style=\"color: #404040;\">Restricting writes in this way ensures the system can clean up files when applications are uninstalled.</span></p>
</blockquote>
<p>另一个原因我觉得是安全的问题,这一方面的陈述会在下面详细介绍.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[Android4.4]Permission Denial: not allowed to send broadcast android.intent.action.MEDIA_MOUNTED]]></title>
    <link href="http://androidperformance.com/2014/05/14/android4-4permission-denial-not-allowed-to-send-broadcast-android-intent-action-media-mounted/"/>
    <id>http://androidperformance.com/2014/05/14/android4-4permission-denial-not-allowed-to-send-broadcast-android-intent-action-media-mounted/</id>
    <published>2014-05-14T15:37:28.000Z</published>
    <updated>2015-03-27T05:19:36.000Z</updated>
    <content type="html"><![CDATA[<h4 id="摘要:_Android4-4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案-">摘要: Android4.4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案.</h4><p>&nbsp;</p>
<h3 id="0-_问题背景">0. 问题背景</h3><p>在Android4.4之前，许多应用程序使用如下代码去通知更新文件数据库</p>
<pre class="\"lang:java" decode:true\"="" title="\"通知系统更新文件系统\"">sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>这样做的坏处：每次发送这个广播，都会<span style="\"color:" #222222;\"="">让MediaScanner重新扫描一次系统文件，很影响设备的电池寿命。当然传入的路径可以</span> 是单个文件或者内容很少的文件夹，会减轻扫描系统文件的压力，但是还是会因为扫描频繁而浪费电。所以在Android4.4<span style="\"color:" #222222;\"="">开始，只允许系统应用发送这样的intent。</span> 所以在Android4.4系统的机器上会出现如下错误：</p>
<pre class="\"lang:java" decode:true\"="" title="\"错误\""> Permission Denial: not allowed to send broadcast android.intent.action.MEDIA_MOUNTED</pre>

<h3 id="1-_解决办法：">1. 解决办法：</h3><p>1 . 将Intent换为 <a href="\"><code>ACTION_MEDIA_SCANNER_SCAN_FILE</code></a><span style="\"color:" #000000;\"="">.</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"ACTION_MEDIA_SCANNER_SCAN_FILE\"">sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>但是这个Intent只扫描文件，不扫描文件夹。如果你的应用只操作单个文件而不是文件夹，就可以使用这个。 2. 不发广播，换为MediaScannerConnection进行通知更新</p>
<pre class="\"lang:java" decode:true\"="" title="\"MediaScannerConnection\""> MediaScannerConnection.scanFile(this,
          new String[] { file.toString() }, null,
          new MediaScannerConnection.OnScanCompletedListener() {
      public void onScanCompleted(String path, Uri uri) {
          Log.i(\"ExternalStorage\", \"Scanned \" + path + \":\");
          Log.i(\"ExternalStorage\", \"-&gt; uri=\" + uri);
      }
 });</pre>

<p>这样做就属于不发送广播,在4.4上可以正常工作.</p>
<a id="more"></a>
<h4 id="拓展">拓展</h4><p>代码跟踪,让我们看看scanFile做了什么事: 1.查看scanFile的源码:</p>
<pre class="\"lang:java" decode:true\"="" title="\"scanFile\"">    public static void scanFile(Context context, String[] paths, String[] mimeTypes,
            OnScanCompletedListener callback) {
        ClientProxy client = new ClientProxy(paths, mimeTypes, callback);
        MediaScannerConnection connection = new MediaScannerConnection(context, client);
        client.mConnection = connection;
        connection.connect();
    }</pre>

<p>2.ClintProxy源码:</p>
<pre class="\"lang:java" decode:true\"="" title="\"ClientProxy\"">    static class ClientProxy implements MediaScannerConnectionClient {
        final String[] mPaths;
        final String[] mMimeTypes;
        final OnScanCompletedListener mClient;
        MediaScannerConnection mConnection;
        int mNextPath;

        ClientProxy(String[] paths, String[] mimeTypes, OnScanCompletedListener client) {
            mPaths = paths;
            mMimeTypes = mimeTypes;
            mClient = client;
        }

        public void onMediaScannerConnected() {
            scanNextPath();
        }

        public void onScanCompleted(String path, Uri uri) {
            if (mClient != null) {
                mClient.onScanCompleted(path, uri);
            }
            scanNextPath();
        }

        void scanNextPath() {
            if (mNextPath &gt;= mPaths.length) {
                mConnection.disconnect();
                return;
            }
            String mimeType = mMimeTypes != null ? mMimeTypes[mNextPath] : null;
            mConnection.scanFile(mPaths[mNextPath], mimeType);
            mNextPath++;
        }
    }</pre>

<p>3.MediaScannerConnection的connect方法:</p>
<pre class="\"lang:java" decode:true\"="" title="\"connect\"">    /**
     * Initiates a connection to the media scanner service.
     * {@link MediaScannerConnectionClient#onMediaScannerConnected()}
     * will be called when the connection is established.
     */
    public void connect() {
        synchronized (this) {
            if (!mConnected) {
                Intent intent = new Intent(IMediaScannerService.class.getName());
                intent.setComponent(
                        new ComponentName(\"com.android.providers.media\",
                                \"com.android.providers.media.MediaScannerService\"));
                mContext.bindService(intent, this, Context.BIND_AUTO_CREATE);
                mConnected = true;
            }
        }
    }</pre>

<p>这里可以看到,最后是start了一个service:MediaScannerService MediaScannerService 的源码可以在<a href="\">这里看到</a>:我们重点看一下scan方法:</p>
<pre class="\"lang:java" decode:true\"="" title="\"scan\"">private void scan(String[] directories, String volumeName) {
        // don\'t sleep while scanning
        mWakeLock.acquire();

        ContentValues values = new ContentValues();
        values.put(MediaStore.MEDIA_SCANNER_VOLUME, volumeName);
        Uri scanUri = getContentResolver().insert(MediaStore.getMediaScannerUri(), values);

        Uri uri = Uri.parse(\"file://\" + directories[0]);
        sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_STARTED, uri));

        try {
            if (volumeName.equals(MediaProvider.EXTERNAL_VOLUME)) {
                 openDatabase(volumeName);    
            }

            MediaScanner scanner = createMediaScanner();
            scanner.scanDirectories(directories, volumeName);
        } catch (Exception e) {
            Log.e(TAG, \"exception in MediaScanner.scan()\", e); 
        }

        getContentResolver().delete(scanUri, null, null);

        sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_FINISHED, uri));
        mWakeLock.release();
    }</pre>

<p>可以看到最终调用了<span style="\"color:" #48484c;\"="">MediaScanner来进行扫描,扫描结束后,发送ACTION_MEDIA_SCANNER_FINISHED广播.应用程序可以接受此广播来更新界面之类</span></p>
<p>&nbsp;</p>
<p>参考资料：</p>
<ol>
<li><p><a href="\">http://stackoverflow.com/questions/18624235/android-refreshing-the-gallery-after-saving-new-images</a></p>
</li>
<li><p><a href="\">http://stackoverflow.com/questions/21469431/permission-denial-not-allowed-to-send-broadcast-in-android</a></p>
</li>
<li><p><a href="\">http://www.androideng.com/?p=1108</a></p>
</li>
</ol>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="摘要:_Android4-4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案-">摘要: Android4.4修改了MEDIA_MOUNTED广播的权限,导致发送这个广播会出现权限问题,本文分析这个问题出现的原因,并给出解决方案.</h4><p>&nbsp;</p>
<h3 id="0-_问题背景">0. 问题背景</h3><p>在Android4.4之前，许多应用程序使用如下代码去通知更新文件数据库</p>
<pre class=\"lang:java decode:true\" title=\"通知系统更新文件系统\">sendBroadcast(new Intent(Intent.ACTION_MEDIA_MOUNTED, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>这样做的坏处：每次发送这个广播，都会<span style=\"color: #222222;\">让MediaScanner重新扫描一次系统文件，很影响设备的电池寿命。当然传入的路径可以</span> 是单个文件或者内容很少的文件夹，会减轻扫描系统文件的压力，但是还是会因为扫描频繁而浪费电。所以在Android4.4<span style=\"color: #222222;\">开始，只允许系统应用发送这样的intent。</span> 所以在Android4.4系统的机器上会出现如下错误：</p>
<pre class=\"lang:java decode:true\" title=\"错误\"> Permission Denial: not allowed to send broadcast android.intent.action.MEDIA_MOUNTED</pre>

<h3 id="1-_解决办法：">1. 解决办法：</h3><p>1 . 将Intent换为 <a href="\"><code>ACTION_MEDIA_SCANNER_SCAN_FILE</code></a><span style=\"color: #000000;\">.</span></p>
<pre class=\"lang:java decode:true\" title=\"ACTION_MEDIA_SCANNER_SCAN_FILE\">sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, 
     Uri.parse(\"file://\" + Environment.getExternalStorageDirectory())));</pre>

<p>但是这个Intent只扫描文件，不扫描文件夹。如果你的应用只操作单个文件而不是文件夹，就可以使用这个。 2. 不发广播，换为MediaScannerConnection进行通知更新</p>
<pre class=\"lang:java decode:true\" title=\"MediaScannerConnection\"> MediaScannerConnection.scanFile(this,
          new String[] { file.toString() }, null,
          new MediaScannerConnection.OnScanCompletedListener() {
      public void onScanCompleted(String path, Uri uri) {
          Log.i(\"ExternalStorage\", \"Scanned \" + path + \":\");
          Log.i(\"ExternalStorage\", \"-&gt; uri=\" + uri);
      }
 });</pre>

<p>这样做就属于不发送广播,在4.4上可以正常工作.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[读书笔记]]></title>
    <link href="http://androidperformance.com/2014/05/11/crazy-coder/"/>
    <id>http://androidperformance.com/2014/05/11/crazy-coder/</id>
    <published>2014-05-11T06:50:21.000Z</published>
    <updated>2015-03-27T05:22:41.000Z</updated>
    <content type="html"><![CDATA[<p>本书描写了绝影等程序员的成长之路，分为大学、工作、创业三部分。作者笔下以绝影、BOSS liu、Bug Yang等为代表的程序员是大多程序员成长的真实写照，很多网友看过小说之后都说“这些事好像就是我身上发生的事情，但是我写不出来，绝影写出来了”。绝影给疯狂的程序员下了一个定义,现在在我看来,是相当精髓的:‘疯狂的程序员’绝对不是靠狂妄和拼命的程序员，而是能够踏实，持续努力的程序员。等你真正做到了这两点，技术上去了，在写程序这个领域，能够限制你的只有你的想像力，到那个时候，你才算个‘疯狂的程序员’，这种程序员阿，是能令竞争对手无比恐惧的。” </p>
<p>第一次读&lt;疯狂的程序员&gt;这本书,还是在大学的时候,现在也不记得当时是如何知道这本书的,总之读了之后,便一发不可收拾,翻来覆去读了好几遍,每次读完,都有种被打了鸡血的感觉. 绝影的身影陪伴着我读过了大学的一半生活. 工作了之后再来看这本书,还是依旧有那种感觉.在多看上看了以后,我在其中做了有一些笔记和书摘,摘录在下面,大家一起感受下.</p>
<p>这是本值得程序员或IT界的年轻人一读的书。绝影和boss liu的经历一定会给年轻的程序员以鼓舞和启发。 读完这本书，我觉得绝影他们研究的技术并不难，但是很实在。我现在却是想得太多，动手太少，可以称做伪程序员吧，欠练。 我觉得在关注技术的同时也不能对身边的人关心太少。绝影原来的女朋友小燕还是不错的，只是一直以来绝影对她的关心太少了。等到失去的时候才发现这一点就太晚了</p>
<p>另外作者在书中反复强调的一个观点就是:要么做第一个，要么做最好的一个. 这也是绝影所一直坚持的,所以对待每件事情都很认真,每件事情都去做到完美,他更像是给自己做东西,而不是给别人打工.</p>
<a id="more"></a>
<p>当然作者也是很幽默的,这一点让他和其他的程序员有所不同,这本书从头到尾读起来都很轻松,这也归功于作者的文笔:</p>
<blockquote>
<p><span style="color: #a9a9a9;">2013-07-17 00:41:18</span></p>
<p>人无非有两种方法提高自己，一是真的提高自己，二是打击别人提高自己</p>
<p><span style="color: #a9a9a9;">2013-07-17 11:59:55</span></p>
<p>越是神秘的东西人们就越好奇，越好奇就越羡慕。为啥老说别人的老婆比自己的好，肤浅地说是因为“审美疲劳”，有深度一点，那是因为你天天对着她，早没了神秘感。比如黑客。黑客是啥？其实黑客还不是人，还不是要吃饭睡觉泡妹妹。但是因为他神秘，为什么神秘？因为你不知道他在干什么，更不知道他干那些是用的什么技术方法，但是他又能干些你想都想不到的事情，所以好多人就羡慕黑客。正如鲁迅先生说的：“看不懂的文章，至少别人不会说是坏文章。</p>
<p><span style="color: #a9a9a9;">2013-07-17 13:36:46</span></p>
<p>程序员是值得尊敬的，程序员的双手是魔术师的双手。他们把枯燥无味的代码变成了丰富多彩的软件……</p>
<p><span style="color: #a9a9a9;">2013-07-17 13:42:54</span></p>
<p>所以说人活得很累，有很多事情，像学习，在很多时候都不是为自己学，是为别人学。为什么？因为你在别人心目中是个高手。你不得不花比别人更多时间去维护你在别人心目中高手的形象。你做到了，但那又有什么，别人认为你理所当然应该是个高手，那是你应该，他才不会管你比自己多花了多少时间和精力而来赞扬你刻苦，值得学习</p>
<p><span style="color: #a9a9a9;">2013-07-17 13:45:44</span></p>
<p>他想谭老教授凭这书也赚了不少钱吧。这也没什么不好，能够真正给别人带来好处的东西就是应该让人赚到钱，当然，如果你的东西真的有价值，你也不用愁赚不到钱。可现在的人一天到晚还是愁：哎呀物价涨了，啥时候才能赚大钱啊？这样想的时候你自己好好反省一下：你真的有多高的技术么？你真的有多高的智商么？你做的东西真的有那么大的价值么？</p>
<p><span style="color: #a9a9a9;">2013-07-17 13:47:50</span></p>
<p>这种可怕思想存在于现在大部分人的头脑中。别人就算真的好，那也不是真的好，因为我不懂，你跟我讲你水平高，没用，我不懂啊。除非你给我出具一份专家的鉴定书。所以，你比他好一点，他不会承认你，会嫉妒你。要是你比他好很多，他才会承认你，然后会很崇拜你。所以你要做，就应该比别人做得好很多。</p>
<p><span style="color: #a9a9a9;">2013-07-17 13:59:07</span></p>
<p>所以我们有时候也要理解老师，他们天天在讲台上讲，对他来说下面坐的有80%都是文盲――有文化的文盲，当然他们会很认真地记着笔记，甚至能预感到那些是重点，那些是考点。你以为老师喜欢这样的人吗？他觉得他在对着一群猪讲课，他觉得自己心中的东西比起书上来，那都是至理名言，可是，以他们的智商，他们无法理解</p>
<p><span style="color: #a9a9a9;">2013-07-18 00:51:17</span></p>
<p>所以有时候人的技术啊，知识啊也许并不是学出来的，是逼出来的。比如你去考软件设计师，本来至少有半年的时间来准备，可以那编译原理里面什么词法分析语法分析什么正则表达式啊看得你头都大了，这很正常，毕竟你是数学专业的就不是计算机专业的，是计算机专业的就不是数学专业的，甚至你跟这两个专业都不沾边。最后想算了还是放弃了，反正考试还有那么多内容，其它的学好点，一样能过。后来工作了，有一天，你BOSS跟你说：“小张啊，你从来没让我们失望过啊，最近很多程序员反应咱们那编译器不好用，你看干脆咱们自己开发个编译器算了。给你一个月时间够了吧，你可从来没让我们失望过啊。”他这么一说，尽管在那一个月中你每天都在心中骂他，可最后你自己都吓了一跳――居然还是把编译器给搞出来了。就这么一个月的时间逼一下，比那半年的效率都高得多。其实就算做不出来也没什么，做不出来很正常，做出来了你是牛人，这一个月要这么累死累活地工作是为什么？不是为了钱，是为了别人对你的信任和肯定。所以你骂完BOSS，偶尔回想起来也许你还是会感谢他的。</p>
<p><span style="color: #a9a9a9;">2013-07-18 00:52:32</span></p>
<p>对程序员来说，大部分快乐是从解决问题特别是独立解决问题中来的，不是从这个CASE有多大，奖金有多少中来的</p>
<p><span style="color: #a9a9a9;">2013-07-18 00:54:52</span></p>
<p>所以写程序有时候就是很有意思。比如你搞数学的，一就是一二就是二绝不可能出来三，但程序就不一样，方法自由，很多时候解决一个问题的方法直接反应出这个程序员的性格和思想</p>
<p><span style="color: #a9a9a9;">2013-07-18 10:36:59</span></p>
<p>艺术家和程序员有一个共同点就是对自己的作品宝贝得不得了，像自己的儿子似的，就算自己的儿子有一点瑕疵，但终归是自己的儿子，不到万不得已也不愿意轻易去修改它。这就是为什么在公司里面开会的结果是大家一致认为程序应该这样这样改，就是程序员不同意修改。</p>
<p><strong> 23 出差</strong></p>
<p><span style="color: #a9a9a9;">2013-07-22 10:54:37</span></p>
<p>对于“Sense”这个概念当然是老总的看法，你要是真听进去了，飘飘然觉得自己真的在写程序上有“Sense”那你就完了。你以为自己有“Sense”比别人聪明比别人学得快，于是你就放慢了学习的脚步。本来回家还要看三个小时的代码结果你去打了三个小时游戏，第二天去了公司当然就什么也不知道。这就是看三个小时代码和打三个小时游戏的区别，也是有没有“Sense”的区别。看了，你就有，没看，你就没有</p>
<p><strong> 24 BOSS Liu</strong></p>
<p><span style="color: #a9a9a9;">2013-07-22 10:58:02</span></p>
<p>所以程序员实际上就是一个幕后工作者。你程序写得好，客户用得很满意，他们会说：“哦，这个KIPACS软件不错，软件很好用。”不会说：“哦，这个绝影写的KIPACS软件很不错，绝影很厉害。”如果你程序写得不好，虽然他们不会说：“哦，绝影这人写的软件很糟糕。”但是你自己知道。很多时候，别人说你技术不行你都可以接受也可以理解，再牛B的程序员也会有自己不擅长的方面，但是如果别人说你做的东西不行，你往往会非常失望和难过，因为这不仅仅意味着你在某一方面的技术不行。</p>
<p><span style="color: #a9a9a9;">2013-07-22 11:07:25</span></p>
<p>所以很多时候面试官活得很累，不断提高自己设计高水平的面试题目当然是他们份内的事情，问题是一个好的面试官每一道题目都是他的劳动成果，就像你写的程序一样。可是那些回答问题的人根本就管这些，他们的唯一的目的就是把这题答出来，为了达到目的，往往不惜编造假话。有些回答一听就知道是错误的，或者是骗人的，可他们回答得怔怔有词，好像在他们眼中你这题就是专门为他们准备的或者你出这题没有一点技术含量，想到自己花了那么多心思来准备的题目被搞成这样，搞得你自己都开始怀疑自己的智商。</p>
<p><strong> 27 毕业</strong></p>
<p><span style="color: #a9a9a9;">2013-07-22 11:19:18</span></p>
<p>所以现在赚钱就是这样，什么技术啊，水平啊，味道啊，服务啊对人来说都是瞎扯淡，48块钱一杯的极品南山和98块钱一杯的极品南山有几个人能喝出50块钱的价格差？要命的是明明啥都没喝出来，还故作深沉地说：“看，这就是98和48的差别，这个余味太带酸……”什么才能赚钱？是噱头，是眼球。哪怕你死了，你要死得其所，让人杀人焚尸，成了大案子，最好上了新闻头条上了公安厅挂牌督办。知道了这一点，你就能够明白为什么现在“芙蓉姐姐”火爆得不得了，也狠赚了一笔钱</p>
<p><strong> 31 大CASE</strong></p>
<p><span style="color: #a9a9a9;">2013-07-22 12:39:21</span></p>
<p>所以有时候写程序就像放屁。放屁这个事情毕竟是件不雅的事，所以大部分人还是要偷偷地放。比如几十个人挤在公交车里，冷不丁谁偷偷放个屁，于是大家一边捂着鼻子一边互相指责：“你放的，你放的。”而真正放屁的人看到这情况，为掩人耳目，也充当起南郭先生，不断说：“谁放的？谁放的？”在这种情况下，屁很容易就放出来了。要是真正让你在大庭广众众目睽睽之下来放屁，怕就算你吃下两斤豌豆也放不出也不敢放出一个来，最要命的是肚子咕咕姑不断叫，就是不敢放</p>
<p><strong> 33 燕儿的工作</strong></p>
<p><span style="color: #a9a9a9;">2013-07-22 12:52:54</span></p>
<p>所以资本家确实有值得我们学习的地方：一、可以招个文员进来，应付公司打杂的琐情；二、本科刚毕业，工资不用开很高；三、可以和绝影安排在一个宿舍，节省了公司开销；四、最关键的，还让绝影觉得自己像欠了他好大一个人请，以后就得巴心巴干跟着他干。此乃三十六计中借刀杀人的最高境界――借了别人刀，把别人杀了，还让别人掉下的头给自己说声：谢谢。</p>
<p><strong> 37 动摇</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 06:47:47</span></p>
<p>早几年人们都觉得做技术的人很牛B，往往给人的印象是生活粗糙，不修边幅，做的又尽是些匪夷所思的事情。那毕竟是做的脑力劳动，中国几千年的思想下来就是“劳心者治人，劳力者治于人”，所以搞技术的莫名其妙有了优越感，越是有优越感，就越是不修边幅，鲁迅先生能做到把喝咖啡的时间都拿来工作，我还不能做到把梳头洗脸的时间拿来工作？ 所以封建社会的腐朽思想害死人：人人都认为搞技术好，于是人人都来搞技术，搞到最后技术实在太多了，反而如何把技术销售出去才成了摆在人们面前的最重要的问题，于是慢慢地搞销售才成了王道</p>
<p><strong> 38 张厂长的遥控器</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 14:24:04</span></p>
<p>，全世界对软件都有偏见，都觉得硬件好，念初中的时候，老师就说：什么是硬件？硬件就是看得见摸得着的东西。什么是软件？软件就是看不见摸不着的东西。人们的心态就是这样，往往更喜欢实实在在捏在手中的东西。早些年布雷顿森林体系的时候，你跟他说金属本位制，美元也是硬通货，直接跟黄金挂钩的，可人们还是偏偏喜欢黄金，眼看金融危机一来，赶紧把美元全部换成黄金，搞得美国也没了那么多金子，不得不放弃美元，美元也变成了货币符号，最后害了谁？还不是害了自己，自己辛辛苦苦挣再多钱，不过是货币符号而已。</p>
<p><strong> 39 真正的注册机</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 14:29:14</span></p>
<p>。现在单位里特别是国有单位，年轻人往往对年长的领导腹绯很多，而上了年纪的领导又对这些年轻人意见很大，归根到底，人老了，不求有功，但求无过，凡事畏畏缩缩，又觉得年轻人办事不牢靠，太激进太冒险。</p>
<p><strong> 40 精华和糟粕</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 14:37:14</span></p>
<p>所以说人跟人不同，狗和狗有异，同样一个妹妹走在学校里，西师的瞅也不瞅一眼，川大的说：“美女呀！”要是放到绝影他们学校，土匪多半会惊叫：“快看，女的！</p>
<p><span style="color: #a9a9a9;">2013-07-23 16:11:57</span></p>
<p>所以人活着累，自己技术菜，首先是被同行、老板看不起，挣的钱不多，还被老婆同学看不起。几个同行走到一起别人都兴高采烈讨论inline hook，你插一句：SSDT用什么函数获取？你自己都不好意思。 混了几年，好不容易技术高了点，也就是比上不足比下有余吧，顶级高手又不屑你，正如美女都不在街上逛一样，高手根本不混群。美女去哪里了？多半在私家车上。高手去哪里了？多半在写程序。即使这样，菜鸟也有有求于你的时候，菜鸟毕竟是菜鸟，出招都不按常理，有些问题问得你自己都吃紧，但是没办法，谁叫你是程序员呢？谁叫你技术比人家高点呢？你就得想办法帮别人解决。 再混几年，终于到顶级高手的地步了，突然发现群里没法混了。你想一个资格的大学教授可能去幼儿园教小朋友吗？即使你给他8000块钱一个月，人家还不一定愿意去教，好钢得用在刀刃上啊。于是自己来研究问题。先前那两个阶段，都还有很多东西可以参考，群上啊，网上啊，什么问题都能找到点资料。现在自己到了这个阶段，啥事都只能靠自己，费尽心机研究点成果出来又不敢独自偷偷享用。谁叫你是高手呢，你总得经常发表点研究成果吧。这是什么精神？这就是新时代的雷锋精神</p>
<p><strong> 41 网吧</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 16:18:46</span></p>
<p>还是《长江七号》里的小屁孩子说得对，做公司就要做大的，做什么不重要，关键是要做大，你一个小小的公司，不要说销售，就是贷款，都还要看银行脸色，做大了就不一样，银行是天天请客吃饭求你着贷款，要是做到VIP，据说银行那漂亮的公关部经理还可以单独跟你共进晚餐</p>
<p><span style="color: #a9a9a9;">2013-07-23 16:19:07</span></p>
<p>所以程序员要做就得做高手，做什么都无不重要，关键是要做成牛人。你一个小小的程序员，公司有你不多缺你不少，代码得由你来写，出了BUG还得由你负责，不服气，不服气滚一边去，反正你不愿意做有的是人来做。成牛人了就不一样，掌握了公司核心技术，体力活就分给下面的人去做？老板敢随便让你走吗？你一走随便再去一个公司或者马上自己创业搞对他都是极大的心理压力</p>
<p><span style="color: #a9a9a9;">2013-07-23 16:20:16</span></p>
<p>所以说公司对员工，就像谈恋爱。你没有百分之百的把握，就不要轻易给你女朋友承诺什么。你这个CASE没做完，就先不要承诺这个周末我带你去看电影。你永远要记住，承诺本身只能让她在当时那几分中里开心，履行自己的承诺才能让她开心一辈子，而且承诺的东西做不到，时间长了，她会连那几分钟的开心都没有，反而变成对你承诺的厌恶。男人最可怕的是没有钱，最可悲的是没有人信任你。</p>
<p><strong> 42 工资和房价</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 16:23:53</span></p>
<p>你区区一个内务府总管，五品官，我堂堂一个八部巡府，一品官，公堂之上你坐着我站着，不骂你骂谁。</p>
<p><span style="color: #a9a9a9;">2013-07-23 16:44:40</span></p>
<p>东西和技术都是给逼出来，你不向周总保证一周做完，你就永远不可能在一周内把一个月的工作做完。</p>
<p><strong> 43 背出来的面试题</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 16:47:11</span></p>
<p>资本家在各方面都是尽可能降低成本，这种思想放到产品上，就是偷工减料，放到人事上，就是能用大学生的绝不用研究生，能一个人做的绝不让两个人做。而一些国企又恰恰相反，大学生就能解决的一定要让研究生来解决，这叫“对工作重视 ”；一个人就能做的一定要让三四个人甚至一个小组一起上，这叫“人多力量大</p>
<p><span style="color: #a9a9a9;">2013-07-23 16:48:25</span></p>
<p>本来真的不懂，但把自己逼一下，又懂了一些，于是似懂非懂地去公司干，干一段时间下来又发现自己似乎真的懂了。</p>
<p><strong> 44 真正的大CASE</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 16:54:33</span></p>
<p>当美国经济不景气到谷底美国总统就想打仗，转移人们视线，正好这个时候萨达姆又冒了出来，你以为美国真是民主国家，你以为美国都是美国人们说了算，你以为布什不敢打你？不打你打谁？总之你伊拉克一个小国家，这个CASE总能摆平，你管我打你打得对不对，总之能完成CASE才是王道</p>
<p><span style="color: #a9a9a9;">2013-07-23 16:59:56</span></p>
<p>所以中国学校的教育就是死板，那数学从小学学到大学，从加减乘除学到导数微积分复变函数，按照学校的教法到底有多大用处，恐怕用得最多的也就是做生意算下几斤几两多少钱收多少找多少，其实数学的用处可大着呢。各个教材把自己的学问教得头头是道，就是不告诉你物理学里面的矢量就相当于数学里面的复数，就是不告诉你匀速圆周运动的轨迹可以用几何学来求解，归根结底，就是不告诉你这门学问到底有啥用处</p>
<p><span style="color: #a9a9a9;">2013-07-23 17:00:21</span></p>
<p>大环境如此，搞得写程序也如此，不管是学校里程序设计课程，还是社会上这样培训班那样电脑学校，都只管各自教各自的，学汇编就80x68，学C语言就TurboC，搞得最后大学C语言课程学完，连C语言能写Windows下窗口程序都不知道。最后写程序是教了，那教的是如何去写程序，根本不教你为什么要写程序，写程序能写些什么出来</p>
<p><span style="color: #a9a9a9;">2013-07-23 17:01:06</span></p>
<p>所以对人来说，什么思维最重要，当然是抽象思维。狗也会做梦，甚至还会说梦话，但是狗会抽象思维吗？你能让狗把一堆人民币想像成一堆骨头吗？不能，既然只有人这种高等动物才会抽象，那就要把它发挥到淋漓尽致</p>
<p><span style="color: #a9a9a9;">2013-07-23 17:03:41</span></p>
<p>在他看来，这世界上最幸福的事莫过于亲眼看着别人把自己的设想变成现实，你要明白，为什么T台上的模特虽然能够吸引众多的闪光灯和眼球，但是设计师总是最后出场，而且总是被这些美女模特们簇拥着出场。这就像修房子，虽然里面的一砖一瓦不知道凝结了多少工人的心血，但他们永远体会不到一座座高楼拔地而起的幸福和成就感，因为在他们眼中，只能看到一块砖或一片瓦，只有设计师，在他眼中看到的是整栋雄伟的大厦</p>
<p><span style="color: #a9a9a9;">2013-07-23 17:03:22</span></p>
<p>人呐，眼光放长远一些，看到的东西就更多一些，生活得也更有意义一些</p>
<p><strong> 45 向业主致敬</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 17:06:38</span></p>
<p>其实你要知道，什么是程序员，能为一两千块工资天天在公司加班加点回家还继续干到两三点甚至通宵的程序员，他们根本就不在乎挣多少钱。程序员，他们想的是什么？他们想的永远都是技术，他们崇尚的也永远是技术，哪怕我现在身上只有两毛前，只要有志同道合的人跟我聊技术，我一样敢跟他从C++聊到ASM，从API钩子聊到inline hook，从Ring3聊到Ring0。聊完了，今天晚上吃什么？吃什么并不重要，重要的是如何才能获取Kernel基址</p>
<p><strong> 48 非洲</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 22:26:26</span></p>
<p>所以人啊，特别是现在的年轻人，总觉得压力大，要买房，要买车，要结婚要生孩子，压力还不大？其实根本没必要去考虑这些，你考虑得再多，房价还是一样往上涨。就站在工薪阶层来说，一套房子几十万，你挣几十年钱一次性付清买套房子，压力倒是没有，不过住不了几年又要入土为安。现在有机会让你先把房子住上，等于多让你享几十年的福，还不赶紧去住上，现在房子少人多，你不去住多的是人去做，到时候人把房子住满了，你又得后悔，还考虑啥压力？房子标价五十万，或者贷款二十万，这都是死的，可人是活的，今年你只挣两万三万不代表你一辈子只挣两万三万。 所以技术也是如此，现在你觉得自己菜，到明年你技术又会比今年有所提高，虽然你自己不怎么感觉得到，但提高是实实在在的。不怕人没长进，就怕人没耐心，等不到明年就打退堂鼓。</p>
<p><strong> 49 技术经理</strong></p>
<p><span style="color: #a9a9a9;">2013-07-23 22:29:03</span></p>
<p>所以女人呐，天天到晚都在说烦烦烦。早上起来没赶上公车迟到了烦，跟同事相处不顺了烦，出门下雨了弄脏衣服烦，不下雨出太阳晒黑皮肤了烦，不下雨不出太阳刮点风吹乱了头发也烦，老公天天下班回家不出门觉得生活太平淡了烦，老公天天下班不回家出去玩怀疑他有外遇了也烦。</p>
<p><span style="color: #a9a9a9;">2013-07-23 22:30:21</span></p>
<p>理想就如同美女，生活就如同大便。</p>
<p><strong> 50 Bug Yang</strong></p>
<p><span style="color: #a9a9a9;">2013-07-25 07:23:11</span></p>
<p>现在的年轻人啊，就是这么自以为是。BUG？BUG在哪里？我没看到BUG就是没有BUG。牛人？牛人在哪里啊？我没看到牛人我就是世界上最牛的人。技术？这技术有什么用？我没看到这技术的用途它就是没用。抱着这种思想，于是一天只想着我要做什么，根本就不考虑我应该做什么。久而久之，胆子越来越大，大话越来越牛，技术反而越来越粗糙</p>
<p><strong> 53 Architect</strong></p>
<p><span style="color: #a9a9a9;">2013-07-26 06:36:56</span></p>
<p>可现在的资本家呀，啥事都只想向钱看齐，就像现在流行的说法，撞伤不如撞死，好多司机一见撞了人，干脆又把车倒回去撞死算了，最后结果呢？本来撞伤了人，属交通意外，承担民事责任就行了，现在搞成了故意伤害，还得追求刑事责任还附带民事赔偿。而资本家呢？自以为自己聪明，放弃后续维护以小博大赚了大头，结果坏了自己名声，本来人家还有个一两千万的大CASE，正考虑你上个CASE还做得不错，要不要把这个也给你算了，反正大家合作过，再合作起来也比较方面。可是到最后，才这么一点小小的问题你就不去给人家维护了，这下可好，到手的大CASE又飞了。</p>
<p><strong> 54 失败的EB</strong></p>
<p><span style="color: #a9a9a9;">2013-07-26 06:44:47</span></p>
<p>这就是中国的现实啊。在中国，做技术的人不能说不多，技术也不能说比国外差得十万八千里，可中国的软件还是发展不上去，中国做技术的人还始终还活在尴尬中。为什么？也许有一天，技术真正和商业利益分开了，中国的软件就有希望了，中国的程序员也就有希望了。</p>
<p><strong> 60 Nothing Impossible</strong></p>
<p><span style="color: #a9a9a9;">2013-07-28 11:30:40</span></p>
<p>谈到最后，你不愿意归不愿意，不去也得去，去多久还不是公司说了算，领导们总认为自己的决定是高瞻远瞩，站在台上挥一挥手，下面的群众便立刻斗志昂扬――那是农民起义的事了。纵观历史上，农民起义为什么总失败，或者就算不失败到最后也是被地主阶级利用，成为他们改朝换代的工具？历史书上说得很清楚了，是因为农民阶级没有先进理论作指导。 资本家当然自认为比地主阶级高级，事实在，资本家总是认为自己比谁都高级，地主阶级都能利用的事情，他们当然也不在话下。 问题是时代不同了，现在的人，特别是搞IT的，谁没有文化？一个比一个有文化。早几年没有社会经验，当然轻易被忽悠了，现在吃的亏多了，哪里还能轻易被忽悠的。赵本山的小品不正是这个过程的反应吗？ 这</p>
<p><strong> 61 校园</strong></p>
<p><span style="color: #a9a9a9;">2013-07-28 11:54:38</span></p>
<p>技术也是如此，以前天天用SDK，MFC写着程序，去网上看牛人们动辄就是RING0，RING0的，觉得这RING0是如此神奇，于是崇拜得要命，好像一但进入RING0自己便从菜鸟一跃而成牛人，也就是佛法上讲的天天坐在那里不吃不喝，有一天突然就“顿悟”了，成佛了。 等有一天要是你真正去搞驱动了，搞内核了，又觉得RING0也不过尔尔，不过就是多了些特权指令，换了些导入库而已。于是搞着RING0的人觉得RING0也不过瘾，没搞RING0的人又觉得RING0如此神奇，崇拜得要命。技术本身没有什么区别，区别在于人们对他的看法而已</p>
<p><strong> 68 外挂</strong></p>
<p><span style="color: #a9a9a9;">2013-07-28 17:08:20</span></p>
<p>现实生活中，哪个男人不是自作一副清高状，骂妓女，骂小姐，骂她们不要脸。但是骂完后呢？还不是跟妓女跟小姐玩得很Happy。再看看一些当官的，开起反腐倡廉的会来在上面说得头头是道，转身一下讲台手马上又伸了出来。他们对妓女有成见，很大程度上是对‘别人和妓女Happy’有成见，他们对腐败深恶痛绝，很大程度上是对“别人腐败”深恶痛绝。要是换成了自己，就有足够理由把这些成见抛开了。这叫啥？这就叫假正经。”</p>
<p><strong> 72 西班牙布局</strong></p>
<p><span style="color: #a9a9a9;">2013-07-29 08:06:28</span></p>
<p>这就比如现在搞软件开发，什么VC，VB，Delphi工具多得要死，就连VC都还分VC6,VC7.1,VC8好几个版本。新人一上来便问：“什么工具最好啊？”，“有中文版的吗？”，“最新版本是多少？”结果一个个上来就装上动辄几个G的恐龙般大小的IDE。要知道，这个时候，BOSS Liu还用着VC6呢。 在他们看来，学技术当然要学最先进的技术，用工具当然也得用最先进的工具。为什么？不知道，但是最新的就是最好的。可是抱着这样的思想，学技术就累得要死，技术那么多，而且在天天更新啊。开发环境也复杂得要死，你总不可能随时用个硬盘把VC8啊，SQL 2005啊这些庞然大物带在身边。所以一换台电脑，所有工作便无从下手了。</p>
<p><strong> 75 搞IT的民工</strong></p>
<p><span style="color: #a9a9a9;">2013-07-29 18:56:50</span></p>
<p>我们一直在追求技术，一直努力把自己的每个CASE做好，可以说这么多年了，我们都对得起我们做的每一个CASE，对得起我们的老板，对得起我们的客户。外人都觉得我们搞IT的很风光阿，每天坐在空调办公室里，在电脑面前打打字就能拿到那么多薪水，人家门卫整天日晒雨淋才那么一点钱。可那些人想过没有，对他们来说上班就是上班，下班就是下班，有时候加班，还拿加班费？我们呢？可以说我们根本没有下班。我们上班是上班，回到家还是写程序，有人给我们算加班吗？有人给我们拿加班费吗？</p>
<p><strong> 80 夭折</strong></p>
<p><span style="color: #a9a9a9;">2013-08-02 23:30:59</span></p>
<p>“是啊。以前我们就经常忙，经常熬夜。最开始，是对新知识，新技术的好奇，那时候我们疯狂地吸取知识。后来去公司了，我们还是经常加班经常熬夜，还不是为了能按时把CASE做下来，为了得到老板和同事，甚至用户的肯定。可现在呢？说实话我觉得我们现在的热情还不如一些菜鸟，像Bug Yang，他学习起来就比我们疯狂。工作上就更不用说了，什么肯定啊，赞扬啊，当然有，但那都是老板们停留在口头上的。有些话说了一次又一次，说实话，我都觉得我们对技术的追求和对CASE负责的心理是被资本家们利用了。所以，要我说，写程序就两种：要么纯粹就是爱好，不计任何回报，就像我们刚学写程序那样；要么就是给自己写程序，为自己挣钱，就像我们现在一样。要是一直给资本家写程序，写到最后，就两个字：痛苦！。</p>
<p><strong> 81 丁骨牛排</strong></p>
<p><span style="color: #a9a9a9;">2013-08-02 23:34:21</span></p>
<p>所以，在绝影看来，写程序永远不要停留在只跟代码打交道，只跟机器打交道的地步。这就像下棋。初学的时候怕丢人，还是偷偷买套软件回来下。你发现这机器真是太神奇了，你无论多么努力居然还是下不赢它。可机器毕竟是机器，你总是会慢慢进步的。有一天，你终于把它下赢了，于是你发现，从那以后，它居然再也下不过你。这时候，你就觉得，跟机器下棋实在是件很没意思的事情，下棋，还是得跟人下。</p>
<p><span style="color: #a9a9a9;">2013-08-02 23:34:29</span></p>
<p>写程序，还是得跟人打交道，只有跟人，你来我往，才是真正智慧上的交流，无论输赢，这才是最有意思的事情。</p>
<p><strong> 84 BOSS Liu和VB</strong></p>
<p><span style="color: #a9a9a9;">2013-08-02 23:54:06</span></p>
<p>‘疯狂的程序员’绝对不是靠狂妄和拼命的程序员，而是能够踏实，持续努力的程序员。等你真正做到了这两点，技术上去了，在写程序这个领域，能够限制你的只有你的想像力，到那个时候，你才算个‘疯狂的程序员’，这种程序员阿，是能令竞争对手无比恐惧的。”</p>
<p><strong> 86 装孙子</strong></p>
<p><span style="color: #a9a9a9;">2013-08-03 00:01:00</span></p>
<p>你知道燕儿为什么要跟我分手吗？她跟我说：‘你确实对我很好，也给了我很多，可是几年下来，我渐渐发现你给我的其实并不是我想要的。’我问她：‘那你想要什么呢？’她也答不上来，只是说：很多她想要的东西别人轻轻松松就能给她，在她生气的时候别人很容易就能哄她开心，别人说的话也都正和她意。可是为什么都只是别人，而不是绝影我呢？为什么我和她在一起，相互之间就总是指责，总是争吵呢？</p>
<p><span style="color: #a9a9a9;">2013-08-03 00:01:55</span></p>
<p>我告诉她。在很多时候，看起来我的确忽视了她，但我心里一直把她放在最重要的位置。我们在一起几年了，我和她都知道她也并不是个完美的人，我总是很明确地指出她的不足，她的缺点，因为我爱她，我要对她负责，我应该让她不断地变得完美。这些批评她的话让她听了，肯定会不舒服。可是别人不一样，她的那些朋友，只是普通朋友而已，他们不需要为她负什么责任，不需要担心她有没有自己喜欢的事业，不需要关心她的工作有没有前途。所以他们可以总是说她喜欢听的话，总是迁就她的缺点。这，也许就是为什么我总不能哄她开心的原因吧。她跟朋友在一起的时间不多，所以他们在一起的时候，总会做一些很开心很值得回味的事情。可是这又和我不一样，我和她，要面对的是每一天的生活，有时候单调而乏味的每一天。这和我们俩一个道理，以前我们在一起工作时，空余时间不是一起吃烧烤就是陪你喝酒。现在呢？我们总是用有限的在一起的时间，尽可能多地讨论问题，分享经验和心得。 “我又告诉她，也许我她的才是你真正需要的东西，只是因为你有了，所以你不觉得这有多么宝贵，等到有一天你失去这些的时候，也许你会后悔。</p>
<p><span style="color: #a9a9a9;">2013-08-03 00:02:19</span></p>
<p>，技术其实还是我们最需要的东西，以前我们没有技术，所以疯狂的追求它。现在呢？有了一点，它才显得不那么重要，如果这样放任下去，等到我们失去它的那一天，我们一定会后悔莫及的</p>
<p><span style="color: #808080;">多看笔记 来自多看阅读 for Kindle</span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>本书描写了绝影等程序员的成长之路，分为大学、工作、创业三部分。作者笔下以绝影、BOSS liu、Bug Yang等为代表的程序员是大多程序员成长的真实写照，很多网友看过小说之后都说“这些事好像就是我身上发生的事情，但是我写不出来，绝影写出来了”。绝影给疯狂的程序员下了一个定义,现在在我看来,是相当精髓的:‘疯狂的程序员’绝对不是靠狂妄和拼命的程序员，而是能够踏实，持续努力的程序员。等你真正做到了这两点，技术上去了，在写程序这个领域，能够限制你的只有你的想像力，到那个时候，你才算个‘疯狂的程序员’，这种程序员阿，是能令竞争对手无比恐惧的。” </p>
<p>第一次读&lt;疯狂的程序员&gt;这本书,还是在大学的时候,现在也不记得当时是如何知道这本书的,总之读了之后,便一发不可收拾,翻来覆去读了好几遍,每次读完,都有种被打了鸡血的感觉. 绝影的身影陪伴着我读过了大学的一半生活. 工作了之后再来看这本书,还是依旧有那种感觉.在多看上看了以后,我在其中做了有一些笔记和书摘,摘录在下面,大家一起感受下.</p>
<p>这是本值得程序员或IT界的年轻人一读的书。绝影和boss liu的经历一定会给年轻的程序员以鼓舞和启发。 读完这本书，我觉得绝影他们研究的技术并不难，但是很实在。我现在却是想得太多，动手太少，可以称做伪程序员吧，欠练。 我觉得在关注技术的同时也不能对身边的人关心太少。绝影原来的女朋友小燕还是不错的，只是一直以来绝影对她的关心太少了。等到失去的时候才发现这一点就太晚了</p>
<p>另外作者在书中反复强调的一个观点就是:要么做第一个，要么做最好的一个. 这也是绝影所一直坚持的,所以对待每件事情都很认真,每件事情都去做到完美,他更像是给自己做东西,而不是给别人打工.</p>]]>
    
    </summary>
    
      <category term="读书笔记" scheme="http://androidperformance.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android开发:Log2File工具类]]></title>
    <link href="http://androidperformance.com/2014/05/02/android_log_to_file/"/>
    <id>http://androidperformance.com/2014/05/02/android_log_to_file/</id>
    <published>2014-05-02T05:25:35.000Z</published>
    <updated>2015-03-27T05:19:46.000Z</updated>
    <content type="html"><![CDATA[<div style="color: #000000;">Log2File工具类是用于Android程序将Log记录到文件中(如sd卡)的工具,应用场景：</div><br><div style="color: #000000;"><br><br>1.  无法连接电脑进行调试（usb线被usbotg占用）<br>2.  Log不容易被抓取<br>3.  Bug出现很随机，不是必出现<br>4.  其他自己脑补<br><br>##  0.说明<br><br>这篇文章最早是在我的CSDN博客上面发布了:<a href="http://blog.csdn.net/grackergao/article/details/18322749" title="Log2File类的使用" target="_blank" rel="external">http://blog.csdn.net/grackergao/article/details/18322749</a> .现在讲他转移到了这里,代码的Github地址 :<a href="https://github.com/Gracker/Android-Utils/blob/master/Log2File.java" title="Log2File的github地址" target="_blank" rel="external">https://github.com/Gracker/Android-Utils/blob/master/Log2File.java</a><br><br><a id="more"></a><br><br>## 1.Log2File工具类源码<br><br><pre class="lang:java decode:true " title="Log2File工具类源码">import java.io.BufferedWriter;<br>import java.io.File;<br>import java.io.FileWriter;<br>import java.io.IOException;<br>import java.util.Date;<br><br>import android.content.Context;<br>import android.os.Environment;<br><br>public class Log2File<br>{<br>    private static boolean  logInit;<br>    private static BufferedWriter writer;<br><br>    private Log2File()<br>    {<br><br>    }<br><br>    /<strong><br>     <em> 初始化Log,创建log文件
     </em> @param ctx<br>     <em> @param fileName
     </em> @return<br>     */<br>    public static boolean init(Context ctx, String fileName)<br>    {<br>        if(!logInit)<br>        {<br>            String state = Environment.getExternalStorageState();<br>            if (Environment.MEDIA_MOUNTED.equals(state))<br>            {<br>                File sdDir = Environment.getExternalStorageDirectory();<br>                File logDir = new File(sdDir.getAbsolutePath() + “/log2file/“ +<br>                        ctx.getPackageName() + “/“);<br><br>                try {<br>                    if(!logDir.exists())<br>                    {<br>                        logDir.mkdirs();<br>                    }<br><br>                    File logFile = new File(logDir, fileName);<br>                    logFile.createNewFile();<br><br>                    writer = new BufferedWriter(new FileWriter(logFile, true));<br>                    logInit = true;<br>                } catch (IOException e) {<br>                    // TODO Auto-generated catch block<br>                    e.printStackTrace();<br>                }<br><br>            }<br><br>        }<br><br>        return logInit;<br>    }<br><br>    /</strong><br>     <em> 写一条log
     </em> @param msg<br>     <em>/<br>    public static void w(String msg)<br>    {<br>        if(logInit)<br>        {<br>            try {<br>                Date date = new Date();<br>                writer.write(“[“ + date.toLocaleString() + “] “ + msg);<br>                writer.newLine();<br>                writer.flush();<br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>            }<br>        }<br>    }<br><br>    /**
     </em> 关闭log<br>     */<br>    public static void close()<br>    {<br>        if(logInit)<br>        {<br>            try {<br>                writer.close();<br>                writer = null;<br><br>            } catch (IOException e) {<br>                // TODO Auto-generated catch block<br>                e.printStackTrace();<br>            }<br><br>            logInit = false;<br>        }<br>    }<br>}<br></pre><br><br>##  2.Log2File类的使用<br><br><div>这个工具类的使用比较简单</div><br><div>1.首先调用init进行初始化</div><br><div><br><pre class="lang:java decode:true " title="Log2File类的初始化">Log2File.init(context, fileName);</pre><br>2.调用w()进行输出<br><pre class="lang:java decode:true " title="调用w(String msg)函数进行输出">Log2File.w(String msg);</pre><br>3.使用完毕后，记得要关闭Log<br><pre class="lang:java decode:true  crayon-selected" title="关闭Log">Log2File.close();</pre><br></div><br></div>]]></content>
    <summary type="html">
    <![CDATA[<div style="color: #000000;">Log2File工具类是用于Android程序将Log记录到文件中(如sd卡)的工具,应用场景：</div><br><div style="color: #000000;"><br><br>1.  无法连接电脑进行调试（usb线被usbotg占用）<br>2.  Log不容易被抓取<br>3.  Bug出现很随机，不是必出现<br>4.  其他自己脑补<br><br>##  0.说明<br><br>这篇文章最早是在我的CSDN博客上面发布了:<a href="http://blog.csdn.net/grackergao/article/details/18322749" title="Log2File类的使用">http://blog.csdn.net/grackergao/article/details/18322749</a> .现在讲他转移到了这里,代码的Github地址 :<a href="https://github.com/Gracker/Android-Utils/blob/master/Log2File.java" title="Log2File的github地址">https://github.com/Gracker/Android-Utils/blob/master/Log2File.java</a><br><br>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Github" scheme="http://androidperformance.com/categories/Android/Github/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用VPS搭建VPN+VPN路由设置+MacOS的VPN登录设置]]></title>
    <link href="http://androidperformance.com/2014/05/02/use-vps-and-vpn/"/>
    <id>http://androidperformance.com/2014/05/02/use-vps-and-vpn/</id>
    <published>2014-05-02T01:54:20.000Z</published>
    <updated>2015-03-27T05:25:06.000Z</updated>
    <content type="html"><![CDATA[<h4 id="虚拟专用网（英语：Virtual_Private_Network，简称VPN），是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。虚拟私人网络的讯息透过公用的网络架构（例如：互联网）来传送内联网的网络讯息。它利用已加密的通道协议（Tunneling_Protocol）来达到保密、传送端认证、信息准确性等私人信息安全效果。这种技术可以用不安全的网络（例如：互联网）来传送可靠、安全的信息。需要注意的是，加密信息与否是可以控制的。没有加密的虚拟专用网信息依然有被窃取的危险。"><strong>虚拟专用网</strong>（<span style="\"color:" #0645ad;\"="">英语</span>：<a href="\"><strong>Virtual Private Network</strong></a>，简称<strong>VPN</strong>），是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。虚拟私人网络的讯息透过公用的网络架构（例如：<span style="\"color:" #0645ad;\"="">互联网</span>）来传送内联网的网络讯息。它利用已加密的<span style="\"color:" #0645ad;\"="">通道协议</span>（Tunneling Protocol）来达到保密、传送端认证、信息准确性等私人信息安全效果。这种技术可以用不安全的网络（例如：互联网）来传送可靠、安全的信息。需要注意的是，加密信息与否是可以控制的。没有加密的虚拟专用网信息依然有被窃取的危险。</h4><h1 id=""> </h1><h2 id="1-搭建VPN">1.搭建VPN</h2><p>使用这个VPS已经有一个月了，wordpress也折腾得差不多了，之前一直说要搭建一个VPN，由于种种原因没有去做，今天刚好有时间，就照着教程来了一遍，总算是搞定了，在Doit上划掉这个Task的时候，幸福感满满的。</p>
<p>搭建过程还是蛮无聊的，教程都写得很清楚，我之所以要搬运一下，是因为搭建+配置+登录，这一套组合拳下来，才能在<a href="\">facebook</a>、<a href="\">youtube</a>上刷网，但是各个教程都只是讲了一部分。我把基本操作搬运过来，然后再加上自己遇到的问题和解决方法，可以让看博客的人对着这篇一路下来就可以直接上网了。</p>
<h3 id="1-1_前提条件">1.1 前提条件</h3><p>首先，你要有一个VPS，国外的VPS。如果不懂可以查看<a href="\" title="\">如何搭建VPS</a>  我使用的是Linode在日本美帝的的服务器（如果你也想买Linode的VPS，购买的时候输入我的邀请code：a96df99ce34b5e0f76695558608c87fb2db5cc03 或者直接：<a href="\" title="\">https://www.linode.com/r=a96df99ce34b5e0f76695558608c87fb2db5cc03</a>）</p>
<p>其次，要懂一点Linux，一点点就可以了。</p>
<a id="more"></a>
<h3 id="1-2_搭建VPN">1.2 搭建VPN</h3><p>本人的Vps的操作系统用的是Ubuntu12.04 LTS ,所以下面的操作基于Ubuntu,悉知:</p>
<p><span style="\"color:" #323333;\"=""><strong>1、用root账户登陆服务器</strong></span><br><span style="\"color:" #323333;\"=""><strong>2、安装PPTPD</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"安装pptpd\"">apt-get install pptpd</pre>

<p><span style="\"color:" #323333;\"=""><strong>3、编辑pptpd.conf文件</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"编辑配置文件\"">vi /etc/pptpd.conf</pre>

<p><span style="\"color:" #323333;\"="">取消注释下面内容</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"需要去掉注释的部分\"">option /etc/ppp/pptpd-options
localip 192.168.0.1
remoteip 192.168.0.234-238,192.168.0.245</pre>

<p><span style="\"color:" #323333;\"="">这几句的意思是：当外部计算机通过pptp联接到vpn后所能拿到的ip地址范围和服务器的ip地址设置。</span><br><span style="\"color:" #323333;\"=""><strong>4、添加用于登陆的账户</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"编辑用户信息\"">vi /etc/ppp/chap-secrets</pre>

<p><span style="\"color:" #323333;\"="">格式如下：</span><br><span style="\"color:" #323333;\"="">用户名 pptpd \”密码\” *   比如:</span></p>
<pre class="\"lang:java" decode:true\"="" title="\"账号密码例子\"">Gracker pptpd \"Ab1234567890\" *</pre>

<p>&nbsp;</p>
<p>密码需要用英文双引号星号(*)代表允许接入的ip可以是任意ip。这样，vpn就搭建好了，不过大多数人包括我在内，用国外服务器搭VPN都是为了偶尔能跳出局域网，所以我们还需要配置转发。</p>
<p><span style="\"color:" #323333;\"=""><strong>5、设置DNS解析，编辑pptpd-options文件</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"编辑转发\"">vi /etc/ppp/pptpd-options</pre>

<p><span style="\"color:" #323333;\"="">找到ms-dns，取消掉注释，并修改DNS地址，这里我推荐大家用Google DNS 8.8.8.8 和 8.8.4.4</span><br><span style="\"color:" #323333;\"=""><strong>6、开启转发</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"开启转发\"">vi /etc/sysctl.conf</pre>

<p><span style="\"color:" #323333;\"="">取消注释以下内容</span></p>
<pre class="\"lang:java" decode:true\"="">net.ipv4.ip_forward=1</pre>

<p><span style="\"color:" #323333;\"="">这句话意思是：打开内核IP转发,执行下面的命令让配置生效(感谢@扎啤 提醒)</span></p>
<pre class="\"lang:java" decode:true\"="">sysctl –p</pre>

<p><span style="\"color:" #323333;\"=""><strong>7、安装iptables并设置</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"安装iptables并设置\"">apt-get install iptables
iptables -t nat -I POSTROUTING -j MASQUERADE</pre>

<p><span style="\"color:" #323333;\"="">后面这句话作用是：立刻让LINUX支持NAT(platinum)</span></p>
<pre class="\"lang:java" decode:true\"="">iptables -I FORWARD -p tcp --syn -i ppp+ -j TCPMSS --set-mss 1356</pre>

<p><span style="\"color:" #323333;\"="">假如有部分网站访问不正确，则加入这句，将MTU值调小，这句将MTU值设置为1356。</span><br><span style="\"color:" #323333;\"="">　但是，只是这样，iptables 的规则会在下次重启时被清除，所以我们还需要把它保存下来，方法是使用 iptables-save 命令：   iptables-save &gt; /etc/iptables-rules然后修改 /etc/network/interfaces 文件，找到 eth0 那一节，在对 eth0 的设置最末尾加上下面这句：    pre-up iptables-restore &lt; /etc/iptables-rules这样当网卡 eth0 被加载的时候就会自动载入我们预先用 iptables-save 保存下的配置。</span><br><span style="\"color:" #323333;\"=""><strong>8、重新启动服务</strong></span></p>
<pre class="\"lang:java" decode:true\"="" title="\"重启pptp\"">/etc/init.d/pptpd restart</pre>

<p><span style="\"color:" #323333;\"=""><strong>9、到这一步,VPN就算搭建好了,登录账号密码之后就可以等脸书,推特等之前呵呵呵的网站了.不过这还不算完,登录过程中也有少许坑,下面将一一介绍.</strong></span></p>
<p>&nbsp;</p>
<h2 id="2-配置路由表">2.配置路由表</h2><p><span style="\"color:" #323333;\"="">VPN 是好用，挂上之后国外的网站是能访问了，但原来国内正常访问嘻唰唰的网站立刻变得慢吞吞了，怎么破？这是个问题。如果连了 VPN 没做任何设置的话，会导致所有网络都是通过 VPN 访问，缺点有二：1、VPN 的流量问题，严重的话还可能导致被 VPN 提供商封杀。2、嘻唰唰变慢吞吞的问题。我们上面搭建的VPN如果直接连接的话,就会导致国内的网站访问速度变慢,解决办法就是配置路由表.下面是<a href="\" title="\">维基百科中关于路由表的介绍</a>:</span></p>
<blockquote>
<p>在<a href="\" title="\">计算机网络</a>中，<strong>路由表</strong>（routing table）或称<strong>路由择域信息库</strong>（RIB, Routing Information Base），是一个存储在<a href="\" title="\">路由器</a>或者联网计算机中的电子表格（文件）或<a href="\" title="\">类数据库</a>。路由表存储着指向特定网络地址的路径（在有些情况下，还记录有路径的<a href="\" title="\">路由度量值</a>）。路由表中含有网络周边的<a href="\" title="\">拓扑</a>信息。路由表建立的主要目标是为了实现<a href="\" title="\">路由协议</a>和静态路由选择。</p>
<p>在现代路由器构造中，路由表不直接参与<a href="\" title="\">数据包</a>的传输，而是用于生成一个小型指向表，这个指向表仅仅包含由路由算法选择的数据包传输优先路径，这个表格通常为了优化硬件存储和查找而被压缩或提前编译。本文将忽略这个执行的详细情况而选择整个路径选择／传输信息子系统作为路由表来说明。</p>
</blockquote>
<p>具体步骤(Mac,Windows和Linux自行补脑):</p>
<p><span style="\"color:" #323333;\"="">1. 打开系统偏好设置—&gt;网络，增加 VPN 设置，VPN 类型选择PPTP，根据提示设置用户名密码等信息即可。</span></p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p><span style="\"color:" #323333;\"="">2. 下载 chnroutes.py，相关网址：<a href="https://code.google.com/p/chnroutes/downloads/list" target="_blank" rel="external">https://code.google.com/p/chnroutes/downloads/list</a></span></p>
<p><span style="\"color:" #323333;\"="">3. 打开终端进入下载文件的目录，执行：python chnroutes.py -p mac，该目录下会生成两个文件「ip-up」和「ip-down」。</span></p>
<p><span style="\"color:" #323333;\"="">4. 把这两个文件复制到 /etc/ppp 下，然后进入该目录执行：sudo chmod a+x ip-up ip-down</span></p>
<p><span style="\"color:" #323333;\"="">测试一下，在终端执行：netstat -nr，检查路由表的输出信息。连接 VPN，然后再次执行：netstat -nr，你会发现路由表已经发生了变化。这时再去访问国内的网站，你发现他们又变得嘻唰唰了，同时还能访问 Twitter 和 Facebook！</span></p>
<p>&nbsp;</p>
<h2 id="3-MacOs的VPN登录设置">3.MacOs的VPN登录设置</h2><h3 id="1-调整vpn网络顺序">1.调整vpn网络顺序</h3><p>Mac上登录vpn很简单,<span style="\"color:" #323333;\"="">打开系统偏好设置—&gt;网络，增加 VPN 设置，VPN 类型选择PPTP，根据提示设置用户名密码等信息即可.但是这样还不能登录Facebook之类的网站的话,就还得把VPN这个网络放到默认网络前面,才能正常登录(<span style="\"color:" #ff0000;\"="">注意VPN的位置</span>):</span></p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>具体步骤:</p>
<p>1.</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>2.</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>&nbsp;</p>
<p>大功告成.</p>
<h3 id="2-给小伙伴共享劳动成果">2.给小伙伴共享劳动成果</h3><p>vpn搭建好了之后,默认我们只设置了一个用户,在/etc/ppp/chap-secrets中,如果有其他小伙伴也想使用的话,按照前面添加用户的方法,在下一行添加即可.由于Linode的vps套餐送的流量很多,一个人通常是用不完的.Linode最近服务升级,官网变得小清新了之外,套餐也变得很给力:</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>Update at : 2014-7-24</p>
<p>Linode有了新的套餐:如下</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>参考:</p>
<p>1.<a href="\" title="\">http://www.storyday.com/html/y2011/2843_vpn_route_tables.html</a></p>
<p>2.<a href="\" title="\">http://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E7%A7%81%E4%BA%BA%E7%B6%B2%E8%B7%AF</a></p>
<p>3.<a href="\" title="\">http://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E8%A1%A8</a></p>
<p>4.<a href="\" title="\">http://www.cnblogs.com/Heisenbug/p/3442522.html</a></p>
<p>5.<a href="\" title="\">http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;amp;mid=200062863&amp;amp;idx=1&amp;amp;sn=ecd28282f9d500db4fdb8df39f3726b2&amp;amp;scene=1#rd</a></p>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="虚拟专用网（英语：Virtual_Private_Network，简称VPN），是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。虚拟私人网络的讯息透过公用的网络架构（例如：互联网）来传送内联网的网络讯息。它利用已加密的通道协议（Tunneling_Protocol）来达到保密、传送端认证、信息准确性等私人信息安全效果。这种技术可以用不安全的网络（例如：互联网）来传送可靠、安全的信息。需要注意的是，加密信息与否是可以控制的。没有加密的虚拟专用网信息依然有被窃取的危险。"><strong>虚拟专用网</strong>（<span style=\"color: #0645ad;\">英语</span>：<a href="\"><strong>Virtual Private Network</strong></a>，简称<strong>VPN</strong>），是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。虚拟私人网络的讯息透过公用的网络架构（例如：<span style=\"color: #0645ad;\">互联网</span>）来传送内联网的网络讯息。它利用已加密的<span style=\"color: #0645ad;\">通道协议</span>（Tunneling Protocol）来达到保密、传送端认证、信息准确性等私人信息安全效果。这种技术可以用不安全的网络（例如：互联网）来传送可靠、安全的信息。需要注意的是，加密信息与否是可以控制的。没有加密的虚拟专用网信息依然有被窃取的危险。</h4><h1 id=""> </h1><h2 id="1-搭建VPN">1.搭建VPN</h2><p>使用这个VPS已经有一个月了，wordpress也折腾得差不多了，之前一直说要搭建一个VPN，由于种种原因没有去做，今天刚好有时间，就照着教程来了一遍，总算是搞定了，在Doit上划掉这个Task的时候，幸福感满满的。</p>
<p>搭建过程还是蛮无聊的，教程都写得很清楚，我之所以要搬运一下，是因为搭建+配置+登录，这一套组合拳下来，才能在<a href="\">facebook</a>、<a href="\">youtube</a>上刷网，但是各个教程都只是讲了一部分。我把基本操作搬运过来，然后再加上自己遇到的问题和解决方法，可以让看博客的人对着这篇一路下来就可以直接上网了。</p>
<h3 id="1-1_前提条件">1.1 前提条件</h3><p>首先，你要有一个VPS，国外的VPS。如果不懂可以查看<a href="\" title="\">如何搭建VPS</a>  我使用的是Linode在日本美帝的的服务器（如果你也想买Linode的VPS，购买的时候输入我的邀请code：a96df99ce34b5e0f76695558608c87fb2db5cc03 或者直接：<a href="\" title="\">https://www.linode.com/r=a96df99ce34b5e0f76695558608c87fb2db5cc03</a>）</p>
<p>其次，要懂一点Linux，一点点就可以了。</p>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://androidperformance.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gracker的书单(持续更新,欢迎推荐书籍)(10月30更新)]]></title>
    <link href="http://androidperformance.com/2014/05/02/gracker-booklist/"/>
    <id>http://androidperformance.com/2014/05/02/gracker-booklist/</id>
    <published>2014-05-01T16:59:01.000Z</published>
    <updated>2015-03-27T05:23:49.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://github.com/Gracker/Gracker-book-list" target="_blank" rel="external">Github</a></p>
<h4 id="自从买了KindlePW,刷了多看之后,读了不少书,也涨了很多见识,这里把我读过的书记录在这里,分享的同时也作为一个记录,以此勉励我-也希望能找到志同道合的小伙伴一起读书-">自从买了KindlePW,刷了多看之后,读了不少书,也涨了很多见识,这里把我读过的书记录在这里,分享的同时也作为一个记录,以此勉励我.也希望能找到志同道合的小伙伴一起读书.</h4><h3 id="读过的书(非技术相关):">读过的书(非技术相关):</h3><ol>
<li>疯狂的程序员     by绝影</li>
<li>MacTalk 人生元编程  by 池建强</li>
<li>黑客与画家  by<a href="\">Paul Graham</a><span style="\"color:" #111111;\"=""> </span></li>
<li>创业的乐趣  by Jason Yin</li>
<li>天行健    by燕垒生</li>
<li>三体1:地球往事    by<span style="\"color:" #212121;\"="">刘慈欣</span></li>
<li>三体2:黑暗森林  by<span style="\"color:" #212121;\"="">刘慈欣</span></li>
<li>三体3:死神永生  by<span style="\"color:" #212121;\"="">刘慈欣</span></li>
<li>Doom启示录  by<a href="\">大卫·卡什诺</a><span style="\"color:" #111111;\"=""> </span></li>
<li>明朝那些事儿(1-7)  by当年明月</li>
<li>南明那些事儿   by<a href="\">洪兵</a><span style="\"color:" #111111;\"=""> </span></li>
<li>晚明兵变  by李文志</li>
<li>中国的天空   by<a href="\">周斌</a><span style="\"color:" #111111;\"=""> / </span><a href="\">邹新奇</a><span style="\"color:" #111111;\"=""> </span><a id="more"></a></li>
<li>抗日战争的细节  by<a href="\">魏风华</a><span style="\"color:" #111111;\"=""> </span></li>
<li>重说中国近代史   by<a href="\">张鸣</a><span style="\"color:" #111111;\"=""> </span></li>
<li>太平天国十四年   by <a href="\">盛巽昌</a><span style="\"color:" #111111;\"=""> </span></li>
<li>极简欧洲史   by<a href="\">约翰·赫斯特（John Hirst</a>)</li>
<li>日本简史  by<a href="\">王新生</a><span style="\"color:" #111111;\"=""> </span></li>
<li><span style="\"color:" #111111;\"="">图解不一样的日本史  by<a href="\">陈秉霖</a> </span></li>
<li>情报日本  by<a href="\">胡平</a><span style="\"color:" #111111;\"=""> </span></li>
<li>美国的耻辱:珍珠港事件内幕  by</li>
<li>一九八四   by<a href="\">乔治·奥威尔</a><span style="\"color:" #111111;\"=""> </span></li>
<li>那卡的曙光   by<a href="\">特威西格耶•杰克逊•卡古瑞</a><span style="\"color:" #111111;\"=""> / </span><a href="\">苏珊•林维尔</a><span style="\"color:" #111111;\"=""> </span></li>
<li>冰与火之歌   by <a href="\">乔治·R. R. 马丁</a><span style="\"color:" #111111;\"=""> </span></li>
<li>羊毛战记  by <a href="\">休·豪伊</a><span style="\"color:" #111111;\"=""> </span></li>
<li>我的奋斗   by <a href="\">罗永浩</a><span style="\"color:" #111111;\"="">  &amp;&amp; <a href="\">希特勒</a> </span></li>
<li>北京法源寺 by 李敖</li>
<li><span style="\"color:" #111111;\"="">唯心有物王阳明正传  by<a href="\">赵家三郎</a> </span></li>
<li>黑鹰坠落  by <a href="\">马克·博登</a><span style="\"color:" #111111;\"=""> </span></li>
<li>爱是有故事的旅行   by 汤佳</li>
<li>达芬奇密码  by<a href="\">[美] 丹·布朗</a></li>
<li>肖申克的救赎  by<a href="\">斯蒂芬·金</a><span style="\"color:" #111111;\"=""> </span></li>
<li>幻影书   by<a href="\">保罗·奥斯特</a><span style="\"color:" #111111;\"=""> </span></li>
<li>Facebook效应   by<a href="\">大卫·柯克帕特里克</a><span style="\"color:" #111111;\"=""> </span></li>
<li>掘金黑客  by<a href="\">凯文·保尔森</a><span style="\"color:" #111111;\"=""> </span></li>
<li>黑客   by<a href="\">Steven Levy</a><span style="\"color:" #111111;\"=""> </span></li>
<li>爆发    by<a href="\">艾伯特-拉斯洛·巴拉巴西</a><span style="\"color:" #111111;\"=""> </span></li>
<li>打造Facebook    by<a href="\">王淮</a><span style="\"color:" #111111;\"=""> / </span><a href="\">祝文让</a><span style="\"color:" #111111;\"=""> </span></li>
<li>陆犯焉识  by <a href="\">严歌苓</a><span style="\"color:" #111111;\"=""> </span></li>
<li>冰与火之歌(1-5) by  <a href="\">[美]乔治·R.R.马丁</a><span style="\"color:" #111111;\"=""> </span></li>
<li>帝国最后的荣耀-大明1592抗日援朝  by  <a href="\">马伯庸</a> / <a href="\">汗青</a></li>
<li>赌球记 by   <a href="\">孔二狗</a></li>
<li>为奴十二年 by  <a href="\">[美]所罗门·诺瑟普</a></li>
<li>了不起的盖茨比 by  <a href="\">[美]菲茨杰拉德</a></li>
<li>天行健 by <a href="\">燕垒生</a></li>
<li>狼图腾 by <a href="\">姜戎</a></li>
<li>追风筝的人 by <a href="\">[美] 卡勒德·胡赛尼</a></li>
<li><a href="\" title="\">1988：我想和这个世界谈谈</a>  by <a href="\">韩寒</a></li>
<li><a href="\" title="\">杜拉拉升职记</a> by <a href="\">李可</a></li>
<li><a href="\" title="\">三重门</a> by <a href="\">韩寒</a></li>
<li>to be continue……</li>
</ol>
<h3 id="读过的书(技术和工作相关)">读过的书(技术和工作相关)</h3><ol>
<li>番茄工作法图解   by<a href="\">Staffan Nöteberg</a><span style="\"color:" #111111;\"=""> </span></li>
<li>卓越程序员密码   by <a href="\">Ka Wai Cheung</a><span style="\"color:" #111111;\"=""> </span></li>
<li>程序员,你伤不起  by <a href="\">吉日嘎拉</a><span style="\"color:" #111111;\"=""> </span></li>
<li>若干Java书籍</li>
<li>若干C++书籍</li>
<li>若干Android书籍</li>
<li>若干杂七杂八的技术书籍</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="https://github.com/Gracker/Gracker-book-list">Github</a></p>
<h4 id="自从买了KindlePW,刷了多看之后,读了不少书,也涨了很多见识,这里把我读过的书记录在这里,分享的同时也作为一个记录,以此勉励我-也希望能找到志同道合的小伙伴一起读书-">自从买了KindlePW,刷了多看之后,读了不少书,也涨了很多见识,这里把我读过的书记录在这里,分享的同时也作为一个记录,以此勉励我.也希望能找到志同道合的小伙伴一起读书.</h4><h3 id="读过的书(非技术相关):">读过的书(非技术相关):</h3><ol>
<li>疯狂的程序员     by绝影</li>
<li>MacTalk 人生元编程  by 池建强</li>
<li>黑客与画家  by<a href="\">Paul Graham</a><span style=\"color: #111111;\"> </span></li>
<li>创业的乐趣  by Jason Yin</li>
<li>天行健    by燕垒生</li>
<li>三体1:地球往事    by<span style=\"color: #212121;\">刘慈欣</span></li>
<li>三体2:黑暗森林  by<span style=\"color: #212121;\">刘慈欣</span></li>
<li>三体3:死神永生  by<span style=\"color: #212121;\">刘慈欣</span></li>
<li>Doom启示录  by<a href="\">大卫·卡什诺</a><span style=\"color: #111111;\"> </span></li>
<li>明朝那些事儿(1-7)  by当年明月</li>
<li>南明那些事儿   by<a href="\">洪兵</a><span style=\"color: #111111;\"> </span></li>
<li>晚明兵变  by李文志</li>
<li>中国的天空   by<a href="\">周斌</a><span style=\"color: #111111;\"> / </span><a href="\">邹新奇</a><span style=\"color: #111111;\"> </span>]]>
    
    </summary>
    
      <category term="读书笔记" scheme="http://androidperformance.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于自由]]></title>
    <link href="http://androidperformance.com/2014/05/01/about_random/"/>
    <id>http://androidperformance.com/2014/05/01/about_random/</id>
    <published>2014-05-01T05:18:03.000Z</published>
    <updated>2015-03-26T12:45:53.000Z</updated>
    <content type="html"><![CDATA[<p><strong>当Youtube被封的时候，我淡定，因为我们有优酷，而且Youtube的英文视频我也看不懂；</strong></p>
<p><strong>当Facebook被封的时候，我淡定，因为我们有人人，而且我也没有多少国外朋友；</strong></p>
<p><strong>当Google被封的时候，我淡定，因为我们有百度，而且百度更懂中文；</strong></p>
<p><strong>当Twiiter被封的时候，我淡定，因为我们有微博，而且Twitter远没有微博功能强大；</strong></p>
<p><strong>当Dropbox被封的时候，我有点不淡定了，因为国内同类服务做的像坨屎；</strong></p>
<p><strong>当Gmail被封的时候，我有点不淡定了，因为Gmail几乎没有垃圾广告；</strong></p>
<p><strong>当Google Docs被封的时候，我有点不淡定了，因为国内没有在线协作平台；</strong></p>
<p><strong>当Google Reader被封的时候，我有点不淡定了，因为国内RSS订阅整合和分享功能远没有Reader优秀；</strong></p>
<p><strong>这时候，我突然想起来Youtube有即时翻译功能，而且里面每天都会产生大量优秀视频；</strong></p>
<p><strong>这时候，我突然想起来Facebook有各种有趣应用，甚至可以整合到Outlook里面；</strong></p>
<p><strong>这时候，我突然想起来Google有scholar search，还有各种个性化的服务；</strong></p>
<p><strong>这时候，我突然想起来Twiiter各种神奇，甚至可以用来估算龙卷风带来的损失；</strong></p>
<p><strong>这时候，我突然想起来Wordpress可以做简易的网站，可以很轻松的定制个性化服务。</strong></p>
<p><strong>于是，我想到墙外看看，却发现——我得不到他们 ，我自由获取信息的权利被默默的剥夺了。</strong></p>
<p><strong>更加恐怖的是： 全世界都用Twitter，Facebook，只有我们用微博。</strong></p>
<p><strong>我们和他们生活在不同的维度，我们使用的永远是劣质的山寨品，甚至还要承担比正品更高的价格。当我们断绝了与外界的联系，当我们只能获得经过别人筛选过的信息，无知者无畏将是我们唯一的宿命。</strong></p>
<p><strong>比起在各种“异端邪说”中艰难寻找真理，对无知的恐惧更让我胆战心惊。</strong></p>
<p><strong>给所有不翻墙的朋友：</strong></p>
<p><strong>你可以说我在墙内得到的信息足够了，翻墙出去完全没有必要，但请记得，终究有一天，你想看看外面的世界，但却发现，由于当初的漠不关心，我们现在已经生活在信息的牢笼中，再也出不去了。</strong></p>
<p><a href="http://weibo.com/p/1001603704341168019296" title="http://weibo.com/p/1001603704341168019296" target="_blank" rel="external">http://weibo.com/p/1001603704341168019296</a></p>
<p><span style="color: #ff6600;">本文非原创,系转载,如侵犯版权,请与我联系,我会迅速删除.</span></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>当Youtube被封的时候，我淡定，因为我们有优酷，而且Youtube的英文视频我也看不懂；</strong></p>
<p><strong>当Facebook被封的时候，我淡定，因为我们有人人，而且我也没有多少国外朋友；</strong></p>
<p><]]>
    </summary>
    
      <category term="生活感悟" scheme="http://androidperformance.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[5coins–轻松记账]]></title>
    <link href="http://androidperformance.com/2014/04/13/beautiful-ios-app-ios5coins/"/>
    <id>http://androidperformance.com/2014/04/13/beautiful-ios-app-ios5coins/</id>
    <published>2014-04-12T16:03:37.000Z</published>
    <updated>2015-03-27T05:20:11.000Z</updated>
    <content type="html"><![CDATA[<p><a href="\"><img src="\" alt="\"></a></p>
<p>记账,是个大工程.</p>
<p>知乎出过一个周刊,叫从存钱罐到财务自由,很多人提到理财的时候,都提到了要记账.可见记账的重要性. 我也前前后后用过好几个记账软件,手机和电脑客户端都有过尝试,不过最终还是没有坚持下来.说来惭愧……毅力是一方面,记账软件的易用性也是一方面,前几次记账觉得这么多功能,狂拽酷炫屌炸天啊.用久了就觉得,老子记个帐而已,何必搞得这么麻烦,花了多少钱,再加个备注,就完事了. 什么地点啊,人啊,消费类型啊,其实没啥必要啊!</p>
<p>今天给大家介绍的这个软件,就是一款很简洁的记账软件(ios) : 5coins - 轻松记账(<a href="\">https://itunes.apple.com/cn/app/5coins-spend-everyday/id572886919?mt=8</a>).现在这款软件已经占据我手机Dock栏一席之地.</p>
<a id="more"></a>
<p>下面来看看截图:</p>
<p>1.加载界面:</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>2.主界面:应用一进去后,就可以看到这个界面,这个界面主要显示了今天的消费情况.上面两个按钮:左边那个点击可以查看消费统计,右边那个点击是增加一笔支出. 下面的三个按钮分别是:年度支出百分比,今天消费详单,云备份.</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>3.记账界面:记账界面突出一个简单,没有复杂的条条框框,输入消费金额即可,备注是可选的,我一般简单描述一下消费项目.</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>4.消费统计界面:可以查看 天,周,月的消费情况.</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>5.消费详单</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>&nbsp;</p>
<p>6.云同步界面,使用icloud同步,简单方便.</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>隐藏功能:左右摇晃手机可以跳转到当前日.</p>
<p>应用很简单,用起来也很舒畅,最重要的是,它让记账不再那么麻烦,这样记账的抵触心理也会小很多.那些想记账缺坚持不下来的同学们可以试试这款软件(PS:收费软件,12大洋,但是绝对值得)</p>
<p>记账归记账,每每看到每天的消费额,你就可以知道你的钱都去哪儿了.也可以针对性地进行分析. 每当你控制不住自己的购物欲或者逛taobao逛得欲罢不能的时候,打开这款应用,看看你最近的消费,绝对能帮你省不少钱. 这也是我介绍这款应用的原因:好用,实用.美.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="\"><img src="\" alt="\"></a></p>
<p>记账,是个大工程.</p>
<p>知乎出过一个周刊,叫从存钱罐到财务自由,很多人提到理财的时候,都提到了要记账.可见记账的重要性. 我也前前后后用过好几个记账软件,手机和电脑客户端都有过尝试,不过最终还是没有坚持下来.说来惭愧……毅力是一方面,记账软件的易用性也是一方面,前几次记账觉得这么多功能,狂拽酷炫屌炸天啊.用久了就觉得,老子记个帐而已,何必搞得这么麻烦,花了多少钱,再加个备注,就完事了. 什么地点啊,人啊,消费类型啊,其实没啥必要啊!</p>
<p>今天给大家介绍的这个软件,就是一款很简洁的记账软件(ios) : 5coins - 轻松记账(<a href="\">https://itunes.apple.com/cn/app/5coins-spend-everyday/id572886919?mt=8</a>).现在这款软件已经占据我手机Dock栏一席之地.</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <link href="http://androidperformance.com/2014/04/12/analysishashmap/"/>
    <id>http://androidperformance.com/2014/04/12/analysishashmap/</id>
    <published>2014-04-11T18:26:27.000Z</published>
    <updated>2015-03-26T12:45:53.000Z</updated>
    <content type="html"><![CDATA[<div style="text-align: left">          链表和数组可以按照人们意愿排列元素的次序，但是，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，直到找到为止。如果集合中元素很多，将会消耗很多时间。有一种数据结构可以快速查找所需要查找的对象，这个就是哈希表（hash table）。</div><br><div>          HashMap是基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。（除了非同步和允许使用 null 之外，HashMap 类与 Hashtable 大致相同。）此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</div><br><div>          1.HashMap的数据结构：</div><br><div><a href="http://www.grackertalk.com/wp-content/uploads/2014/04/hm01.png" target="_blank" rel="external"><img src="http://www.grackertalk.com/wp-content/uploads/2014/04/hm01.png" alt="hm01"></a></div><br><div>           HashMap使用数组和链表来共同组成的。可以看出底层是一个数组，而数组的每个元素都是一个链表头。</div><br><div></div><br><div><br><pre class="theme:eclipse lang:java decode:true">    static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {<br>        final K key;<br>        V value;<br>        Entry&lt;K,V&gt; next;<br>        int hash;<br>        …<br>     }</pre><br><div align="left">Entry是HashMap中的一个内部静态类，包级私有，实现了Map中的接口Entey&lt;K,V&gt;。可以看出来它内部含有一个指向下一个元素的指针。</div><br><div align="left"><span style="font-family: Consolas"> </span></div><br><div>          2.构造函数</div><br><div>          HashMap的构造函数有四个：</div><br><div>HashMap()</div><br><div>          构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。</div><br><div>HashMap(int initialCapacity)</div><br><div>          构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</div><br><div>HashMap(int initialCapacity, float loadFactor)</div><br><div>          构造一个带指定初始容量和加载因子的空 HashMap。</div><br><div>HashMap(Map&lt;? extends K,? extends V&gt; m)</div><br><div>          构造一个映射关系与指定 Map 相同的新 HashMap。</div><br><div>实际上就两种，一个是指定初始容量和加载因子，一个是用一个给定的映射关系生成一个新的HashMap。先来说第一个。</div><br><div><br><pre class="theme:eclipse lang:java decode:true">    /<strong><br>     <em> Constructs an empty &lt;tt&gt;HashMap &lt;/tt&gt; with the specified initial
     </em> capacity and load factor.<br>     <em>
     </em> @param  initialCapacity the initial capacity<br>     <em> @param  loadFactor      the load factor
     </em> @throws IllegalArgumentException if the initial capacity is negative<br>     <em>         or the load factor is nonpositive
     </em>/<br>    public HashMap( int initialCapacity, float loadFactor) {<br>        if (initialCapacity &lt; 0)<br>            throw new IllegalArgumentException( “Illegal initial capacity: “ +<br>                                               initialCapacity);<br>        if (initialCapacity &gt; MAXIMUM_CAPACITY)<br>            initialCapacity = MAXIMUM_CAPACITY;<br>        if (loadFactor &lt;= 0 || Float. isNaN(loadFactor))<br>            throw new IllegalArgumentException( “Illegal load factor: “ +<br>                                               loadFactor);<br><br>        // Find a power of 2 &gt;= initialCapacity<br>        int capacity = 1;<br>        while (capacity &lt; initialCapacity)<br>            capacity &lt;&lt;= 1;<br><br>        this.loadFactor = loadFactor;<br>        threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);<br>        table = new Entry[capacity];<br>        useAltHashing = sun.misc.VM. isBooted() &amp;&amp;<br>                (capacity &gt;= Holder. ALTERNATIVE_HASHING_THRESHOLD);<br>        init();<br>    }</strong></pre><br>&nbsp;<br><div><br><div align="left">参数很简单，初始容量，和加载因子。初始容量定义了初识数组的大小，加载因子和初始容量的乘积确定了一个阈值。阈值最大是(1&lt;&lt;30) + 1。初始容量一定是2的N次方，而且刚刚比要设置的值大。默认初始容量是16，默认加载因子是0.75。当表中的元素数量大于等于阈值时，数组的容量会翻倍，并重新插入元素到新的数组中，所以HashMap不保证顺序恒久不变。</div><br><div align="left">当输入的加载因子小于零或者不是浮点数时会抛出异常（IllegalArgumentException）。</div><br><div align="left"></div><br><div align="left"><br><div>3.put操作</div><br><div><br><pre class="theme:eclipse lang:java decode:true ">    /<br>     <em> Associates the specified value with the specified key in this map.
     </em> If the map previously contained a mapping for the key, the old<br>     <em> value is replaced.
     </em><br>     <em> @param key key with which the specified value is to be associated
     </em> @param value value to be associated with the specified key<br>     <em> @return the previous value associated with &lt;tt&gt;key &lt;/tt&gt;, or
     </em>         &lt;tt&gt;null &lt;/tt&gt; if there was no mapping for &lt;tt&gt; key&lt;/tt&gt; .<br>     <em>         (A &lt;tt&gt;null &lt;/tt&gt; return can also indicate that the map
     </em>         previously associated &lt;tt&gt;null &lt;/tt&gt; with &lt;tt&gt; key&lt;/tt&gt; .)<br>     <em>/<br>    public V put(K key, V value) {<br>        if (key == null)<br>            return putForNullKey(value);<br>        int hash = hash(key);<br>        int i = indexFor(hash, table .length );<br>        for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e. next) {<br>            Object k;<br>            if (e. hash == hash &amp;&amp; ((k = e. key) == key || key.equals(k))) {<br>                V oldValue = e. value;<br>                e. value = value;<br>                e.recordAccess( this);<br>                return oldValue;<br>            }<br>        }<br><br>        modCount++;<br>        addEntry(hash, key, value, i);<br>        return null;<br>    }</em></pre><br>&nbsp;<br><div>由于HashMap只是key值为null，所以首先要判断key值是不是为null，是则进行特殊处理。</div><br></div><br></div><br></div><br></div><br>&nbsp;<br><pre class="theme:eclipse lang:java decode:true ">    /**
      Offloaded version of put for null keys<br>     <em>/<br>    private V putForNullKey(V value) {<br>        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e. next) {<br>            if (e. key == null) {<br>                V oldValue = e. value;<br>                e. value = value;<br>                e.recordAccess( this);<br>                return oldValue;<br>            }<br>        }<br>        modCount++;<br>        addEntry(0, null, value, 0);<br>        return null;<br>    }</em></pre><br>&nbsp;<br><div><br><div align="left">可以看出key值为null则会插入到数组的第一个位置。如果第一个位置存在，则替代，不存在则添加一个新的。稍后会看到addEntry函数。</div><br><div align="left">PS：考虑一个问题，key值为null会插入到table[0]，那为什么还要遍历整个链表呢？</div><br><div align="left">回到put函数中。在判断key不为null后，会求key的hash值，并通过indexFor函数找出这个key应该存在table中的位置。</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Returns index for hash code h.<br>     <em>/<br>    static int indexFor (int h, int length) {<br>        return h &amp; (length-1);<br>    }</em></pre><br>&nbsp;<br><div><br><div align="left">indexFor函数很简短，但是却实现的很巧妙。一般来说我们把一个数映射到一个固定的长度会用取余（%）运算，也就是h % length，但里巧妙地运用了table.length的特性。还记得前面说了数组的容量都是很特殊的数，是2的N次方。用二进制表示也就是一个1后面N个0，（length-1）就是N个1了。这里直接用与运算，运算速度快，效率高。但是这是是利用了length的特殊性，如果length不是2的N次方的话可能会增加冲突。</div><br><div align="left">前面的问题在这里就有答案了。因为indexFor函数返回值的范围是0到（length-1），所以可能会有key值不是null的Entry存到table[0]中，所以前面还是需要遍历链表的。</div><br><div align="left">得到key值对应在table中的位置，就可以对链表进行遍历，如果存在该key则，替换value，并把旧的value返回，modCount++代表操作数加1。这个属性用于Fail-Fast机制，后面讲到。如果遍历链表后发现key不存在，则要插入一个新的Entry到链表中。这时就会调用addEntry函数。</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Adds a new entry with the specified key, value and hash code to<br>     <em> the specified bucket.  It is the responsibility of this
     </em> method to resize the table if appropriate.<br>     <em>
     </em> Subclass overrides this to alter the behavior of put method.<br>     <em>/<br>    void addEntry (int hash, K key, V value, int bucketIndex) {<br>        if ((size &gt;= threshold) &amp;&amp; ( null != table[bucketIndex])) {<br>            resize(2 </em> table. length);<br>            hash = ( null != key) ? hash(key) : 0;<br>            bucketIndex = indexFor(hash, table.length);<br>        }<br><br>        createEntry(hash, key, value, bucketIndex);<br>    }</pre><br>&nbsp;<br><div>这个函数有四个参数，第一个是key的hash值，第二个第三个分别是key和value，最后一个是这个key在table中的位置，也就是indexFor(hash(key), table.length-1)。首先会判断size（当前表中的元素个数）是不是大于或等于阈值。并且判断数组这个位置是不是空。如果条件满足则要resize(2 <em> table. length)，等下我们来看这个操作。超过阈值要resize是为了减少冲突，提高访问效率。判断当前位置不是空时才resize是为了尽可能减少resize次数，因为这个位置是空，放一个元素在这也没有冲突，所以不影响效率，就先不进行resize了。</em></div><br><div><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Rehashes the contents of this map into a new array with a<br>     <em> larger capacity.  This method is called automatically when the
     </em> number of keys in this map reaches its threshold.<br>     <em>
     </em> If current capacity is MAXIMUM_CAPACITY, this method does not<br>     <em> resize the map, but sets threshold to Integer.MAX_VALUE.
     </em> This has the effect of preventing future calls.<br>     <em>
     </em> @param newCapacity the new capacity, MUST be a power of two;<br>     <em>        must be greater than current capacity unless current
     </em>        capacity is MAXIMUM_CAPACITY (in which case value<br>     <em>        is irrelevant).
     </em>/<br>    void resize(int newCapacity) {<br>        Entry[] oldTable = table;<br>        int oldCapacity = oldTable. length;<br>        if (oldCapacity == MAXIMUM_CAPACITY) {<br>            threshold = Integer. MAX_VALUE;<br>            return;<br>        }<br><br>        Entry[] newTable = new Entry[newCapacity];<br>        boolean oldAltHashing = useAltHashing;<br>        useAltHashing |= sun.misc.VM. isBooted() &amp;&amp;<br>                (newCapacity &gt;= Holder. ALTERNATIVE_HASHING_THRESHOLD);<br>        boolean rehash = oldAltHashing ^ useAltHashing;<br>        transfer(newTable, rehash);<br>        table = newTable;<br>        threshold = (int)Math.min(newCapacity <em> loadFactor , MAXIMUM_CAPACITY + 1);<br>    }</em></pre><br>&nbsp;<br><div><br><div align="left">resize操作先要判断当前table的长度是不是已经等于最大容量（1&lt;&lt;30）了，如果是则把阈值调到整数的最大值（(1&lt;&lt;31) - 1），就没有再拓展table的必要了。如果没有到达最大容量，就要生成一个新的空数组，长度是原来的两倍。这时候可能要问了，如果oldTable. length不等于MAXIMUM_CAPACITY，但是（2  oldTable. length）也就是newCapacity大于MAXIMUM_CAPACITY怎么办？这个是不可能的，因为数组长度是2的N次方，而MAXIMUM_CAPACITY = 1&lt;&lt;30。</div><br><div align="left">生成新的数组后要执行transfer函数。</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true">    /<strong><br>     <em> Transfers all entries from current table to newTable.
     </em>/<br>    void transfer(Entry[] newTable, boolean rehash) {<br>        int newCapacity = newTable. length;<br>        for (Entry&lt;K,V&gt; e : table) {<br>            while( null != e) {<br>                Entry&lt;K,V&gt; next = e. next;<br>                if ( rehash) {<br>                    e. hash = null == e. key ? 0 : hash(e. key);<br>                }<br>                int i = indexFor(e.hash, newCapacity);<br>                e. next = newTable[i];<br>                newTable[i] = e;<br>                e = next;<br>            }<br>        }<br>    }</strong></pre><br>&nbsp;<br><div><br><div align="left">这个函数要做的就是把原来table中的值挨个拿出来插到新数组中，由于数组长度发生了改变，所以元素的位置肯定发生变化，所以HashMap不能保证该顺序恒久不变。回到resize函数，这时新的数组已经生成了，只需要替换原来数组就好了。并且要更新一下阈值。可以看出来resize是个比较消耗资源的函数，所以能减少resize的次数就尽量减少。</div><br><div align="left">回到函数addEntry 中，判断完是不是需要resize后就需要创建一个新的Entry了。</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true ">    /<br>     <em> Like addEntry except that this version is used when creating entries
     </em> as part of Map construction or “pseudo -construction” (cloning,<br>     <em> deserialization).  This version needn’t worry about resizing the table.
     </em><br>     <em> Subclass overrides this to alter the behavior of HashMap(Map),
     </em> clone, and readObject.<br>     <em>/<br>    void createEntry( int hash, K key, V value, int bucketIndex) {<br>        Entry&lt;K,V&gt; e = table[bucketIndex];<br>        table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);<br>        size++;<br>    }</em></pre><br>&nbsp;<br><div>调用createEntry函数，参数跟addEntry一样，第一个是key的hash值，第二个第三个分别是key和value，最后一个是这个key在table中的位置。这里的操作与Entry的构造函数有关系。</div><br><div><br><pre class="theme:eclipse lang:java decode:true ">        /**
          Creates new entry.<br>         <em>/<br>        Entry (int h, K k, V v, Entry&lt;K,V&gt; n) {<br>            value = v;<br>            next = n;<br>            key = k;<br>            hash = h;<br>        }</em></pre><br>&nbsp;<br><div>构造函数中传入一个Entry对象，并把它当做这个新生成的Entry的next。所以createEntry函数中的操作相当于把table[bucketIndex]上的链表拿下来，放在新的Entry后面，然后再把新的Entry放到table[bucketIndex]上。</div><br><div><a href="http://www.grackertalk.com/wp-content/uploads/2014/04/hm02.png" target="_blank" rel="external"><img src="http://www.grackertalk.com/wp-content/uploads/2014/04/hm02.png" alt="hm02"></a></div><br><div></div><br><div><br><div><br><div align="left">到这里整个put函数算是结束了。如果新插入的K，V则会返回null。</div><br><div align="left"></div><br><div align="left">4.get操作</div><br><div align="left"><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Returns the value to which the specified key is mapped,<br>     <em> or {@code null} if this map contains no mapping for the key.
     </em><br>     <em> &lt;p&gt;More formally, if this map contains a mapping from a key
     </em> {@code k} to a value {@code v} such that {@code (key==null ? k==null :<br>     <em> key.equals(k))}, then this method returns {@code v}; otherwise
     </em> it returns {@code null}.  (There can be at most one such mapping.)<br>     <em>
     </em> &lt;p&gt;A return value of {@code null} does not &lt;i&gt;necessarily &lt;/i&gt;<br>     <em> indicate that the map contains no mapping for the key; it’s also
     </em> possible that the map explicitly maps the key to {@code null}.<br>     <em> The {@link #containsKey containsKey} operation may be used to
     </em> distinguish these two cases.<br>     <em>
     </em> @see #put(Object, Object)<br>     <em>/<br>    public V get(Object key) {<br>        if (key == null)<br>            return getForNullKey();<br>        Entry&lt;K,V&gt; entry = getEntry(key);<br><br>        return null == entry ? null : entry.getValue();<br>    }</em></pre><br>&nbsp;<br><div>也是先判断key是不是null，做特殊处理。直接上代码，不赘述。</div><br><div><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Offloaded version of get() to look up null keys.  Null keys map<br>     <em> to index 0.  This null case is split out into separate methods
     </em> for the sake of performance in the two most commonly used<br>     <em> operations (get and put), but incorporated with conditionals in
     </em> others.<br>     <em>/<br>    private V getForNullKey() {<br>        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e. next) {<br>            if (e. key == null)<br>                return e. value;<br>        }<br>        return null;<br>    }</em></pre><br>&nbsp;<br><div>key不是null则会调用getEntry函数，并返回一个Entry对象，如果不是null，就返回entry的value。</div><br><div><br><pre class="theme:eclipse lang:java decode:true ">    /**
      Returns the entry associated with the specified key in the<br>     <em> HashMap.  Returns null if the HashMap contains no mapping
     </em> for the key.<br>     <em>/<br>    final Entry&lt;K,V&gt; getEntry(Object key) {<br>        int hash = (key == null) ? 0 : hash(key);<br>        for (Entry&lt;K,V&gt; e = table[ indexFor(hash, table.length)];<br>             e != null;<br>             e = e. next) {<br>            Object k;<br>            if (e. hash == hash &amp;&amp;<br>                ((k = e. key) == key || (key != null &amp;&amp; key.equals(k))))<br>                return e;<br>        }<br>        return null;<br>    }</em></pre><br>&nbsp;<br><div><br><div align="left">直接求key值hash值，然后求table中的位置，遍历链表。有返回entry对象，没有返回null。</div><br><div align="left"></div><br><div align="left">5. Fail-Fast机制：</div><br></div><br></div><br></div><br><pre class="theme:eclipse lang:java decode:true ">    /**
      The number of times this HashMap has been structurally modified<br>     <em> Structural modifications are those that change the number of mappings in
     </em> the HashMap or otherwise modify its internal structure (e.g.,<br>     <em> rehash).  This field is used to make iterators on Collection-views of
     </em> the HashMap fail -fast.  (See ConcurrentModificationException).<br>     */<br>    transient int modCount;</pre><br>&nbsp;<br><div><br><div align="left">    我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</div><br><div align="left">    这一策略在源码中的实现是通过modCount域，保证线程之间修改的可见性。，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。</div><br><div>注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</div><br><div></div><br><div><br><div><br><div>《Core JAVA》</div><br><div>《JDK 中文文档》</div>

<div style="color: #000000;font-family: 微软雅黑"><br>        <table><br>            <tr><br>                <td>Article Name:</td><br>                <td>HashMap源码分析</td><br>            </tr><br>            <tr><br>                <td>Author:</td><br>                <td>刘天昊</td><br>            </tr><br>            <tr><br>                <td>Email:</td><br>                <td>liutianhao.pro@gmail.com</td><br>            </tr><br>        </table><br></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div></div>]]></content>
    <summary type="html">
    <![CDATA[<div style="text-align: left">          链表和数组可以按照人们意愿排列元素的次序，但是，如果想要查看某个指定的元素，却又忘记了它的位置，就需要访问所有的元素，直到找到为止。如果集合中元素很多，将会消耗很多时间。有一种数据结构可以快速查找所需]]>
    </summary>
    
      <category term="Java" scheme="http://androidperformance.com/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Service：开发自己的通知中心(2):辅助性服务实战]]></title>
    <link href="http://androidperformance.com/2014/04/01/android-service-build-your-own-notification-servers-app/"/>
    <id>http://androidperformance.com/2014/04/01/android-service-build-your-own-notification-servers-app/</id>
    <published>2014-03-31T16:05:47.000Z</published>
    <updated>2015-03-27T05:27:19.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-辅助性服务实战介绍">1.辅助性服务实战介绍</h2><p>上一篇文章介绍了什么是Accessibility以及简单的使用，这一篇文章就来讲讲如何使用Accessibility服务来创建一个简单的Android通知中心。Android中通知中心是一个系统层面的服务，负责显示应用和系统发来的通知（Notification，比如USB插入、选择输入法、未接来电、截图、天气信息、新闻推送等等）。在android4.3之前，一般的第三方应用是无法获取Notification list的（在Android4.3之后，有了一个新的接口,NotificationListenerService.getActiveNotifications(),可以获取当前的Notification）。但是利用Accessibility服务可以监听到各种事件的特性，可以开发一个第三方的通知中心，实现与系统通知栏类似的功能。</p>
<a id="more"></a>
<p>下面就来介绍如何开发自己的通知中心。</p>
<h2 id="2-开发第三方通知中心">2.开发第三方通知中心</h2><h3 id="2-1继承AccessibilitySerivce">2.1继承AccessibilitySerivce</h3><p>按照上一篇辅助性服务的介绍，一个辅助性服务可以被捆绑到一个标准的应用程序上，或者以一个单独的安卓工程被创建，我们这里建立一个服务，继承AccessibilitySerivce</p>
<pre class="\"lang:java" decode:true\"="" title="\"继承AccessibilityService\"">import android.accessibilityservice.AccessibilityService;
import android.accessibilityservice.AccessibilityServiceInfo;
import android.app.Notification;
import android.app.PendingIntent;
import android.content.Intent;
import android.os.Parcelable;
import android.util.Log;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;
import android.view.accessibility.AccessibilityRecord;
import android.widget.Toast;

public class NotificationFetcherService extends AccessibilityService {

    private static final String TAG = \"NotificationFetcherService: \";

    public void onAccessibilityEvent(AccessibilityEvent event) {
        if (!(event.getEventType() == AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED) ){
            return;
        }

        Notification localNotification = (Notification)event.getParcelableData();

        if (localNotification != null) {
            Intent intent=new Intent();
            intent.putExtra(\"NotifyData\", localNotification);
            intent.setAction(\".NotificationFetcherService\");
            sendBroadcast(intent);
        }

    }

    @Override
    protected void onServiceConnected() {

        // Define it in both xml file and here,  for compatibility with pre-ICS devices
        AccessibilityServiceInfo info = new AccessibilityServiceInfo();
        info.eventTypes = AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED |
                AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED | 
                AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED;

        info.feedbackType = AccessibilityServiceInfo.FEEDBACK_GENERIC;
        setServiceInfo(info);
    }

    @Override
    public void onInterrupt() {
        System.out.println(\"onInterrupt\");
    }

}</pre>

<p>继承AccessibilitySerivce必须要重写几个重要的方法：</p>
<p>onServiceConnected方法负责在服务和Activity绑定的时候，进行初始化数据，这里新建了一个AccessibilityServiceInfo对象，并将TYPE_NOTIFICATION_STATE_CHANGED、TYPE_WINDOW_STATE_CHANGED、TYPE_WINDOW_CONTENT_CHANGED纳入监听范围，TYPE_NOTIFICATION_STATE_CHANGED表示这个服务可以监听Notification的变化，我们正是使用这个特性来实现第三方的通知中心功能。</p>
<p>onInterrupt是服务断开时调用的函数</p>
<p>onAccessibilityEvent是最重要的，它负责监听所注册的eventTypes（在onServiceConnected中注册的）的事件。从上面的代码中我们可以得到一个Notification对象：</p>
<pre class="\"lang:java" decode:true\"="" title="\"得到Notification对象\"">Notification localNotification = (Notification)event.getParcelableData();</pre>

<p>得到Notification对象之后，就可以进行自己的操作，我这里是通过广播的形式，将收到的Notification发送给Activity进行处理。</p>
<p>这里也会碰到一个小问题：当一个Notification对象太大时（比如截图、未接来电等，Notification.contentView就很大，通过广播传播会出现data过大无法传输的问题），这时可以把Notification.contentView对象暂时保存在Application中，然后再置为null，Activity中接收到数据后，再进行赋值。</p>
<h3 id="2-2在Manifest中注册service">2.2在Manifest中注册service</h3><pre class="\"lang:java" decode:true\"="">&lt;service
            android:name=\".NotificationFetcherService\"
            android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\" &gt;
            &lt;intent-filter&gt;
                &lt;action android:name=\"android.accessibilityservice.AccessibilityService\" /&gt;
            &lt;/intent-filter&gt;

            &lt;meta-data
                android:name=\"android.accessibilityservice\"
                android:resource=\"@xml/accessibilityserviceconfig /&gt;
&lt;/service&gt;</pre>

<p>这里就是普通的service注册，注意 &lt;mate-data&gt;标签中的xml文件：从Android 4.0版本开始，有另外一种方法：使用XML文件来配置这类服务。如果你以XML的形式来定义你的服务，某些像canRetrieveWindowContent可配置的选项就可用了。和service一样的配置，使用XML来定义。如果你要使用XML路径，要在你的mainfest文件中指定它，在你的服务声明中添加&lt;meta-data&gt;标签,并指向这个XML资源文件。比如上面的代码，我们在res/xml/中建立accessibilityaseviceconfig.xml，内容如下：</p>
<pre class="\"lang:java" decode:true\"="">&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;
&lt;accessibility-service xmlns:android=\"http://schemas.android.com/apk/res/android\"
    android:accessibilityEventTypes=\"typeWindowStateChanged|typeNotificationStateChanged|typeWindowContentChanged\"
    android:accessibilityFeedbackType=\"feedbackGeneric\"
/&gt;</pre>

<p>服务这里就配置好了。</p>
<h3 id="2-3_接受并处理Notification">2.3 接受并处理Notification</h3><p>下面的Activity中就可以接受这个数据，然后怎么处理就看自己了，这里只是简单地显示出来。</p>
<pre class="\"lang:java" decode:true\"="">import android.app.Activity;
import android.app.Application;
import android.app.Notification;
import android.app.PendingIntent;
import android.app.PendingIntent.CanceledException;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.os.Parcelable;
import android.os.Process;
import android.text.method.ScrollingMovementMethod;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.RemoteViews;
import android.widget.TextView;

public class NotificaitonActivity extends Activity {
    private static final int NOTIFY_DATA_FLAG = 1;
    private static final String NOTIFY_DATA_ID_STR= \"NotifyData\";

    private NotifyDataReceiver  receiver;
    private TextView textView;
    private LinearLayout rootLayout;
    private Button button;

    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main);
        textView = (TextView) findViewById(R.id.notify_test_textview);
        textView.setMovementMethod(ScrollingMovementMethod.getInstance());
        rootLayout = (LinearLayout) findViewById(R.id.root_layout);

        registerBroadcast();

        button = (Button) findViewById(R.id.test_button);
        button.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                Button b = new Button(NotificaitonActivity.this);
                b.setText(\"Tthis\");
                rootLayout.addView(b);
            }
        });
    }

    private void registerBroadcast() {
        receiver = new NotifyDataReceiver();
        IntentFilter filter = new IntentFilter();
        filter.addAction(\".NotificationFetcherService\");
        this.registerReceiver(receiver, filter);
        Log.e(\"Dx:\", \"Broadcast registered.........\");
    }

    private void addToUi(RemoteViews remoteView) {
        rootLayout.addView(remoteView);
    }

    private void showNotify(String notiString) {
        textView.setText(textView.getText() + \"n\" + notiString);
    }

    private class NotifyDataReceiver extends BroadcastReceiver{

        @Override
        public void onReceive(Context context, Intent intent) {
            Log.e(\"Dx:\", \"Receiver got msg in onReceive()...\");

            Parcelable notifyParcelable = intent.getParcelableExtra(\"NotifyData\");

            if (notifyParcelable != null) {

                Notification notification = (Notification) notifyParcelable;
                showNotify(\"tickerText: \" + notification.tickerText);
                showNotify(\"toString: \" + (String)(notification.toString()));

                RemoteViews remoteV = notification.contentView;
                if (remoteV==null) {
                    showNotify(\"remoteView is: null\" );
                } else {
                    showNotify(\"remoteView is: not null\" );

                    addToUi(remoteV);
                }

                PendingIntent pendIntent = notification.contentIntent;
                if (pendIntent==null) {
                    showNotify(\"pendIntent is: null\" );
                } else {
                showNotify(\"pendIntent is: not null\" );
                }

                showNotify(\"**************************\" );
                showNotify(\"                    \" );

            }

        }
    }

}</pre>

<p><span style="\"color:" #ff0000;\"="">注：这里有很重要的一点，由于AccessibilityService的特殊性，用户必须手动到设置-辅助功能中，打开对应的服务，我们才可以通过AccessibilityService获得对应的数据，这一点非常重要。</span></p>
<p>上面的Activity只是简单地显示Notification，关于更多Notification的操作，可以参考Notification这个类，其中重要的属性有：contentView，flags。要模拟真正的通知中心，还是要费一番功夫的。这里由于公司项目的保密，暂不提供对应的实现代码（其实得到Notification就已经成功了一半了），有兴趣的同学可以私下和我交流。</p>
<h2 id="3-总结和问题">3.总结和问题</h2><p>AccessibilityService的实战就讲到这里，这一篇博文也是拖了一段时间才写完的，也算是为前一段时间的项目做个了结。</p>
<p>项目中目前还存在的问题：</p>
<ol>
<li>无法获取安装这个应用之前的系统的Notification</li>
<li>得到的Notification对象没法保存在本地，所以这个服务被杀掉之后，所有的数据都会丢失。（试过用db4o这种对象数据库来进行存储，发现行不通）</li>
<li>对Android系统的Notification对象的行为模仿不够（有些系统的事件监听不到，比如usb的插拔、usb调试的开关等）</li>
</ol>
<p>上面的问题，如果你有好的想法，我们私下交流。</p>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-辅助性服务实战介绍">1.辅助性服务实战介绍</h2><p>上一篇文章介绍了什么是Accessibility以及简单的使用，这一篇文章就来讲讲如何使用Accessibility服务来创建一个简单的Android通知中心。Android中通知中心是一个系统层面的服务，负责显示应用和系统发来的通知（Notification，比如USB插入、选择输入法、未接来电、截图、天气信息、新闻推送等等）。在android4.3之前，一般的第三方应用是无法获取Notification list的（在Android4.3之后，有了一个新的接口,NotificationListenerService.getActiveNotifications(),可以获取当前的Notification）。但是利用Accessibility服务可以监听到各种事件的特性，可以开发一个第三方的通知中心，实现与系统通知栏类似的功能。</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android:Ubuntu下执行Adb命令找不到设备]]></title>
    <link href="http://androidperformance.com/2014/03/25/ubuntu-adb-can-not-find-devices/"/>
    <id>http://androidperformance.com/2014/03/25/ubuntu-adb-can-not-find-devices/</id>
    <published>2014-03-25T03:15:17.000Z</published>
    <updated>2015-03-27T05:25:00.000Z</updated>
    <content type="html"><![CDATA[<h2 id="1-问题概述">1.问题概述</h2><p><span style="color: #000000;">最近开发Nokia项目，遇到的问题如下：</span></p>
<p><span style="color: #000000;">插入Nokia x后，电脑没有反应，即不识别，同事的windows也不识别，最后在谷歌上搜索了良久，才找到了解决方案，但是没有记录，后来又要给别人配置的时候，发现忘记怎么配置了。想想这也是一个具有通性的问题，还是记录下来，分享给大家。</span></p>
<h2 id="2-问题解决方案">2.问题解决方案</h2><p><span style="color: #000000;">首先问题是：执行adb命令提示找不到设备，在做其他操作之前，请先确认已经做了如下操作：</span></p>
<ol>
<li><span style="color: #000000;">确定已经打开了USB调试选项（设置-开发者选项-USB调试），有的机器没有开发者选项，需要到关于里面点击版本号若干下，或者去百度谷歌。</span></li>
<li><span style="color: #000000;">确定使用sudo命令adb kill-server 和adb start-server后仍然没有用。</span><br><span style="color: #000000;">如果上述操作都确认了，还是找不到设备，那么继续往下看：</span></li>
</ol>
<a id="more"></a>
<h3 id="2-1-运行lsusb"><span style="color: #000000;">2.1.运行lsusb</span></h3><pre class="lang:java decode:true">~ » lsusb                                                                  
Bus 002 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 001 Device 002: ID 8087:0024 Intel Corp. Integrated Rate Matching Hub
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hub
Bus 003 Device 004: ID 1532:0016 Razer USA, Ltd DeathAdder Mouse
Bus 003 Device 003: ID 05d5:624c Super Gate Technology Co., Ltd 
Bus 003 Device 033: ID 0421:06e8 Nokia Mobile Phones 
Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hu</pre>

<h3 id="2-2-注册到udve的rules文件"><span style="color: #000000;">2.2.注册到udve的rules文件</span></h3><pre class="lang:java decode:true">vim  /etc/udev/rules.d/51-android.rules    
添加这个ID：1ebf，如下：    
SUBSYSTEM=="usb", SYSFS{"Nokia Mobile Phones"}=="0421", MODE="06e8"   
保存文件并运行：    
sudo chmod a+rx /etc/udev/rules.d/51-android.rules    
sudo /etc/init.d/udev restart    
运行结果如下：    
Rather than invoking init scripts through /etc/init.d, use the service(8)    
utility, e.g. service udev restart    
Since the script you are attempting to invoke has been converted to an    
Upstart job, you may also use the stop(8) and then start(8) utilities,    
e.g. stop udev ; start udev. The restart(8) utility is also available.    
udev stop/waiting    
udev start/running, process 14636</pre>

<h3 id="2-3-使用sudo_关闭和启动adb"><span style="color: #000000;"> 2.3.使用sudo 关闭和启动adb</span></h3><p><pre class="lang:java decode:true">cd ~/tools/android-sdk-linux_x86/platform-tools<br>sudo ./adb kill-server<br>sudo ./adb start-server</pre><br><span style="color: #000000;"><span style="color: #ff0000;"> 注：一般情况下，上面的操作就可以。特殊情况下，usb设备还是不能被识别，比如我手上这台Nokia X</span>。那么继续：</span></p>
<h3 id="2-4-打开_～/-android/adb_usb-ini，加入之前的lsusb得到的信息"><span style="color: #000000;">2.4.打开 ～/.android/adb_usb.ini，加入之前的lsusb得到的信息</span></h3><p><pre class="lang:java decode:true"># ANDROID 4RD PARTY USB VENDOR ID LIST — DO NOT EDIT.</pre></p>
<h1 id="USE_‘android_update_adb’_TO_GENERATE-">USE ‘android update adb’ TO GENERATE.</h1><h1 id="1_USB_VENDOR_ID_PER_LINE">1 USB VENDOR ID PER LINE</h1><h1 id="for_nokia_x">for nokia x</h1><p>0x0421<br><span style="color: #000000;"> 保存关闭后，就可以识别了。windows下也是如此，不多叙述了。</span></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="1-问题概述">1.问题概述</h2><p><span style="color: #000000;">最近开发Nokia项目，遇到的问题如下：</span></p>
<p><span style="color: #000000;">插入Nokia x后，电脑没有反应，即不识别，同事的windows也不识别，最后在谷歌上搜索了良久，才找到了解决方案，但是没有记录，后来又要给别人配置的时候，发现忘记怎么配置了。想想这也是一个具有通性的问题，还是记录下来，分享给大家。</span></p>
<h2 id="2-问题解决方案">2.问题解决方案</h2><p><span style="color: #000000;">首先问题是：执行adb命令提示找不到设备，在做其他操作之前，请先确认已经做了如下操作：</span></p>
<ol>
<li><span style="color: #000000;">确定已经打开了USB调试选项（设置-开发者选项-USB调试），有的机器没有开发者选项，需要到关于里面点击版本号若干下，或者去百度谷歌。</span></li>
<li><span style="color: #000000;">确定使用sudo命令adb kill-server 和adb start-server后仍然没有用。</span><br><span style="color: #000000;">如果上述操作都确认了，还是找不到设备，那么继续往下看：</span></li>
</ol>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
      <category term="Linux" scheme="http://androidperformance.com/categories/Android/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Service：开发自己的通知中心(1):辅助性服务介绍]]></title>
    <link href="http://androidperformance.com/2014/03/17/android-build-your-own-android-notification-service-app/"/>
    <id>http://androidperformance.com/2014/03/17/android-build-your-own-android-notification-service-app/</id>
    <published>2014-03-17T06:07:53.000Z</published>
    <updated>2015-03-27T05:26:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id=""> </h2><h1 id="1_辅助性服务介绍">1 辅助性服务介绍</h1><p>辅助性服务是安卓框架的一个特性，它的设计是为了让已经安装在安卓设备上的应用程序能够为用户提供一种导航式(引导式）回应。一个辅助性服务能够传达给<br>用户关于这个应用程序的利益，例如把文本转换成语音、当用户手指停留屏幕的一个重要区域时的haptic反馈。这一节涵盖了怎样去创建一个辅助性服务，如何处理应用程序的信息接收，还有如何把信息反馈给用户。<br>创建自己的辅助性服务</p>
<a id="more"></a>
<h1 id="2_创建自己的辅助性服务">2 创建自己的辅助性服务</h1><h2 id="2-1_继承AccessibilitySerivce">2.1 继承AccessibilitySerivce</h2><p>一个辅助性服务可以被捆绑到一个标准的应用程序上，或者以一个单独的安卓工程被创建。在任何情况下，创建这类服务的步骤都是一样的。在你的工程中，创建一个类继续AccessibilitySerivce。</p>
<pre class="\"lang:java" decode:true\"="" title="\"继承AccessibilityService\"">package com.example.android.apis.accessibility;

import android.accessibilityservice.AccessibilityService;

public class MyAccessibilityService extends AccessibilityService {
...
    @Override
    public void onAccessibilityEvent(AccessibilityEvent event) {
    }

    @Override
    public void onInterrupt() {
    }

...
}</pre>

<p>&nbsp;</p>
<h2 id="2-2_在mainfest中声明service">2.2 在mainfest中声明service</h2><p>像其他服务一样，你也可以在mainfest文件中声明它。记得要指定它处理android.accessibilityservice这个意图。以便当应用程序触发一个AccessibilityEvent时，这个服务能被调用。</p>
<pre class="\"lang:java" decode:true\"="" title="\"进行配置\"">&lt;application ...&gt;
...
&lt;service android:name=\".MyAccessibilityService\"&gt;
     &lt;intent-filter&gt;
         &lt;action android:name=\"android.accessibilityservice.AccessibilityService\" /&gt;
     &lt;/intent-filter&gt;
     . . .
&lt;/service&gt;
...
&lt;/application&gt;</pre>

<p>&nbsp;</p>
<h2 id="2-3_配置serivce">2.3 配置serivce</h2><p>如果你为这个服务创建一个新的工程的话，且不打算要一个应用程序，你可以把它启动活动的类（通常叫做MainActivity.java)从你的源文件中删除。同时也把相应的活动元素从你的mainfest文件中删除。<br>配置自己的辅助性服务<br>为你的辅助性服务设置配置变量，用它来告诉系统，如何和何时你想要它运行。哪一类事件你想要去响应？这个服务对所有的应用程序都是活动的吗？或者只有指定的包名的？它使用什么样的反馈？<br>你有两种方法去设置这些变量。反向兼容的方法是以代码的形式来设置它们。<br>可以使setServiceInfo(android.accessibilityservice.AccessibilityServiceInfo).如果要这样做的话，要重写onServiceConnected()方法，然后配置在那里配置你的服务。</p>
<pre class="\"lang:java" decode:true\"=""> 
@Override
public void onServiceConnected() {
    // Set the type of events that this service wants to listen to.  Others
    // won\'t be passed to this service.
    info.eventTypes = AccessibilityEvent.TYPE_VIEW_CLICKED |
            AccessibilityEvent.TYPE_VIEW_FOCUSED;

    // If you only want this service to work with specific applications, set their
    // package names here.  Otherwise, when the service is activated, it will listen
    // to events from all applications.
    info.packageNames = new String[]
            {\"com.example.android.myFirstApp\", \"com.example.android.mySecondApp\"};

    // Set the type of feedback your service will provide.
    info.feedbackType = AccessibilityServiceInfo.FEEDBACK_SPOKEN;

    // Default services are invoked only if no package-specific ones are present
    // for the type of AccessibilityEvent generated.  This service *is*
    // application-specific, so the flag isn\'t necessary.  If this was a
    // general-purpose service, it would be worth considering setting the
    // DEFAULT flag.

    // info.flags = AccessibilityServiceInfo.DEFAULT;

    info.notificationTimeout = 100;

    this.setServiceInfo(info);

}</pre>

<p>从Android 4.0版本开始，有另外一种方法：使用XML文件来配置这类服务。如果你以XML的形式来定义你的服务，某些像canRetrieveWindowContent可配置的选项就可用了。和上面一样的配置，使用XML来定义，格式如下所示：</p>
<pre class="\"lang:java" decode:true\"="">&lt;accessibility-service
     android:accessibilityEventTypes=\"typeViewClicked|typeViewFocused\"
     android:packageNames=\"com.example.android.myFirstApp, com.example.android.mySecondApp\"
     android:accessibilityFeedbackType=\"feedbackSpoken\"
     android:notificationTimeout=\"100\"
     android:settingsActivity=\"com.example.android.apis.accessibility.TestBackActivity\"
     android:canRetrieveWindowContent=\"true\"
/&gt;</pre>

<p>如果你要使用XML路径，要在你的mainfest文件中指定它，在你的服务声明中添加&lt;meta-data&gt;标签,并指向这个XML资源文件。假如你把你的XML文件存储在res/xml/serviceconfig.xml这个路径下，新的标签格式如下所示：</p>
<pre class="\"lang:java" decode:true\"="">&lt;service android:name=\".MyAccessibilityService\"&gt;
     &lt;intent-filter&gt;
         &lt;action android:name=\"android.accessibilityservice.AccessibilityService\" /&gt;
     &lt;/intent-filter&gt;
     &lt;meta-data android:name=\"android.accessibilityservice\"
     android:resource=\"@xml/serviceconfig\" /&gt;
&lt;/service&gt;</pre>

<p>&nbsp;</p>
<h2 id="2-4_响应AccessibilityEvents事件">2.4 响应AccessibilityEvents事件</h2><p>现在,您的服务被设置为运行和监听事件，写一些代码，这样当一个AccessibilityEvent真的到来，它就知道要做什么了！<br>从重写onAccessibilityEvent(AccessibilityEvent)方法开始。然后使用getEventType()来确定事件类型，然后用getContentDescription来取出任何与触发事件相关的标签文本。</p>
<pre class="\"lang:java" decode:true\"=""> 
@Override
public void onAccessibilityEvent(AccessibilityEvent event) {
    final int eventType = event.getEventType();
    String eventText = null;
    switch(eventType) {
        case AccessibilityEvent.TYPE_VIEW_CLICKED:
            eventText = \"Focused: \";
            break;
        case AccessibilityEvent.TYPE_VIEW_FOCUSED:
            eventText = \"Focused: \";
            break;
    }

    eventText = eventText + event.getContentDescription();

    // Do something nifty with this text, like speak the composed string
    // back to the user.
    speakToUser(eventText);
    ...
}</pre>

<p>为更多的上下文查询视图层次结构<br>这一步是可选的，然而它非常有用。Android 4.0(API level 14)的一个新特性：可以用AccessibilityService来查询视图层次结构，收集事件所生成的一些UI组件信息，还有这些UI的父控件和子控件。要做到这一点，确保在你的XML配置文件中做了如下设置：</p>
<pre class="\"lang:java" decode:true\"="">android:canRetrieveWindowContent=\"true\"</pre>

<p>如果设置了，通过getSource()可获得一个AccessibilityNodeInfo对象。如果发起的窗口事件仍然是活动的窗口，该调用将会返回一个对象,否则，会返回null。下面这段代码演示何时接收一个事件，步骤如下：<br>立即捕获触发事件的父视图。<br>在那个视图中，寻找一个标签和一个复选框作的子视图。<br>如果找到，创建一个字符串来向用户报告，以表明这个标签是否被选择了。<br>如果遍历视图层次结构后返回null,则会退出该方法。</p>
<pre class="\"lang:java" decode:true\"=""> 
// Alternative onAccessibilityEvent, that uses AccessibilityNodeInfo

@Override
public void onAccessibilityEvent(AccessibilityEvent event) {

    AccessibilityNodeInfo source = event.getSource();
    if (source == null) {
        return;
    }

    // Grab the parent of the view that fired the event.
    AccessibilityNodeInfo rowNode = getListItemNodeInfo(source);
    if (rowNode == null) {
        return;
    }

    // Using this parent, get references to both child nodes, the label and the checkbox.
    AccessibilityNodeInfo labelNode = rowNode.getChild(0);
    if (labelNode == null) {
        rowNode.recycle();
        return;
    }

    AccessibilityNodeInfo completeNode = rowNode.getChild(1);
    if (completeNode == null) {
        rowNode.recycle();
        return;
    }

    // Determine what the task is and whether or not it\'s complete, based on
    // the text inside the label, and the state of the check-box.
    if (rowNode.getChildCount() &lt; 2 || !rowNode.getChild(1).isCheckable()) {
        rowNode.recycle();
        return;
    }

    CharSequence taskLabel = labelNode.getText();
    final boolean isComplete = completeNode.isChecked();
    String completeStr = null;

    if (isComplete) {
        completeStr = getString(R.string.checked);
    } else {
        completeStr = getString(R.string.not_checked);
    }
    String reportStr = taskLabel + completeStr;
    speakToUser(reportStr);
}</pre>

<p>现在你有一个完整的，可以工作的辅助性服务。现在，你也可以试着配置一下，看看Android的text-to-speech engine,或使用Vibrator提供触觉反馈是如何与用户交互。</p>
<p>最后，要使用配置好的service，必须要到“设置—辅助性服务”中打开对应的service，然后才能相应对应的事件。</p>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id=""> </h2><h1 id="1_辅助性服务介绍">1 辅助性服务介绍</h1><p>辅助性服务是安卓框架的一个特性，它的设计是为了让已经安装在安卓设备上的应用程序能够为用户提供一种导航式(引导式）回应。一个辅助性服务能够传达给<br>用户关于这个应用程序的利益，例如把文本转换成语音、当用户手指停留屏幕的一个重要区域时的haptic反馈。这一节涵盖了怎样去创建一个辅助性服务，如何处理应用程序的信息接收，还有如何把信息反馈给用户。<br>创建自己的辅助性服务</p>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android中adb push和adb install的使用区别]]></title>
    <link href="http://androidperformance.com/2014/03/10/android-adb-push-and-adb-install-different/"/>
    <id>http://androidperformance.com/2014/03/10/android-adb-push-and-adb-install-different/</id>
    <published>2014-03-10T15:41:41.000Z</published>
    <updated>2015-03-27T05:26:09.000Z</updated>
    <content type="html"><![CDATA[<p>本篇文章由史迎春(<a href="http://weibo.com/ctj13513871718" target="_blank" rel="external">@三俗小女子</a>)投稿。转载请注明原文地址。</p>
<p>在Android实际开发中，经常会使用adb命令，安装应用程序可以使用adb push 或者adb install。下面就来讲讲这两种安装方式的区别。</p>
<ol>
<li>adb push 能够指定安装目录。比如执行”adb push xxx.apk system/app” 后，xxx.apk被安装到了system/app目录下，此目录下的软件为上文中提到的system application。（注意，system/app是只读的，所以只有有root权限才能push apk进去，而且在push进去的apk会把原本的apk覆盖掉。）adb push本身的意思是将文件复制到系统中的某个文件夹下，但是将apk push到system/app下并且重启手机以后会注册应用程序。</li>
<li>adb install 用此命令安装的软件位于 data/app 目录，带有参数 -r才能强制安装，为user application。<br>由以上两条可知，adb install和adb push的apk主要区别有：<br><table cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td valign="middle"></td><br><td valign="middle">push</td><br><td valign="middle">install</td><br></tr><br><tr><br><td valign="middle">目录</td><br><td valign="middle">system/app</td><br><td valign="middle">data/app</td><br></tr><br><tr><br><td valign="middle">权限</td><br><td valign="middle">系统级（权限全开）</td><br><td valign="middle">用户级（没全开）</td><br></tr><br><tr><br><td valign="middle">卸载</td><br><td valign="middle">root后删除</td><br><td valign="middle">可卸载</td><br></tr><br><tr><br><td valign="middle">大小</td><br><td valign="middle">无限制，自定义</td><br><td valign="middle">有限制</td><br></tr><br><tr><br><td valign="middle">安装</td><br><td valign="middle">pm重新注册</td><br><td valign="middle">不会重新弄注册</td><br></tr><br></tbody><br></table><br>手动安装的APK版本号和系统内置API版本号一样。</li>
</ol>
<a id="more"></a>
<p>更深一层的分析：</p>
<p><strong>1**</strong>、<strong><strong>Android</strong></strong>系统应用更新机制**</p>
<ul>
<li><p>系统为每个应用在AndroidMainfest.xml提供了versionName、versionCode两个属性。</p>
<ul>
<li>versionName：String类型，用来给应用的使用者来查看版本.</li>
<li>versionCode：Integer类型，作为系统判断应用是否能升级的依据。<br><strong>2**</strong>、<strong><strong>Android</strong></strong>系统内置应用更新判断代码**</li>
</ul>
</li>
<li><p>代码来自frameworks/base/services/java/com/android/server/PackageManagerService.java 中 scanPackageLI函数的package更新判断条件<br>由以上资料分析：</p>
</li>
</ul>
<ol>
<li>同一个AP，若在data/app下有更高版本的app，但是system下有旧版本，则follow旧版本。</li>
<li>又已知如果有两个以上的AP在同一个进程但是只有一个AP更改了API version则编译会出错</li>
<li>假设有两个AP：AP1和AP2.两个AP都在API Version更新以后build通过且install进手机。且系统中有内置AP1是旧版本的，重新开机的时候还是会注册旧版本的AP1。则此时，系统中就会出现相同进程但是不同版本的AP1（system/app）和AP2（data/app）<br>综上，编译会出错。</li>
</ol>
<p>猜测：</p>
<ol>
<li>若同一个进程的AP都用同一版本的SDK编译，push进手机，则可以运行（已验证）。</li>
<li>若同一进程的AP都用同一个版本的SDK编译。install进手机，则可以运行，前提是删除system/app内所有同一进程AP。（已验证）</li>
<li>若同一个进程的AP都用同一个版本的SDK编译，push/install进手机都可以（待验证）。<br>&nbsp;</li>
</ol>
<p>作者介绍：</p>
<p>史迎春，女程序员，主要研究Android系统Framework层，目前任职于HTC。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇文章由史迎春(<a href="http://weibo.com/ctj13513871718">@三俗小女子</a>)投稿。转载请注明原文地址。</p>
<p>在Android实际开发中，经常会使用adb命令，安装应用程序可以使用adb push 或者adb install。下面就来讲讲这两种安装方式的区别。</p>
<ol>
<li>adb push 能够指定安装目录。比如执行”adb push xxx.apk system/app” 后，xxx.apk被安装到了system/app目录下，此目录下的软件为上文中提到的system application。（注意，system/app是只读的，所以只有有root权限才能push apk进去，而且在push进去的apk会把原本的apk覆盖掉。）adb push本身的意思是将文件复制到系统中的某个文件夹下，但是将apk push到system/app下并且重启手机以后会注册应用程序。</li>
<li>adb install 用此命令安装的软件位于 data/app 目录，带有参数 -r才能强制安装，为user application。<br>由以上两条可知，adb install和adb push的apk主要区别有：<br><table cellspacing="0" cellpadding="0"><br><tbody><br><tr><br><td valign="middle"></td><br><td valign="middle">push</td><br><td valign="middle">install</td><br></tr><br><tr><br><td valign="middle">目录</td><br><td valign="middle">system/app</td><br><td valign="middle">data/app</td><br></tr><br><tr><br><td valign="middle">权限</td><br><td valign="middle">系统级（权限全开）</td><br><td valign="middle">用户级（没全开）</td><br></tr><br><tr><br><td valign="middle">卸载</td><br><td valign="middle">root后删除</td><br><td valign="middle">可卸载</td><br></tr><br><tr><br><td valign="middle">大小</td><br><td valign="middle">无限制，自定义</td><br><td valign="middle">有限制</td><br></tr><br><tr><br><td valign="middle">安装</td><br><td valign="middle">pm重新注册</td><br><td valign="middle">不会重新弄注册</td><br></tr><br></tbody><br></table><br>手动安装的APK版本号和系统内置API版本号一样。</li>
</ol>]]>
    
    </summary>
    
      <category term="Android" scheme="http://androidperformance.com/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[大学 毕业 工作]]></title>
    <link href="http://androidperformance.com/2014/03/01/life-and-college-about-gracker/"/>
    <id>http://androidperformance.com/2014/03/01/life-and-college-about-gracker/</id>
    <published>2014-03-01T12:22:47.000Z</published>
    <updated>2015-03-27T05:24:41.000Z</updated>
    <content type="html"><![CDATA[<p>我是一个喜欢总结并且做计划的人。从我知道如何规划自己到现在，我做了无数的计划，这些计划雄心勃勃，大有上五天揽月下五洋捉鳖之势，仿佛自己就是救世主，亿万人民等着我去拯救。但现实总是那么的残酷，我做的计划很少有能够坚持下来并完成的，以至于大家都亲切地叫我：“三分钟热情”，每思及此，也没啥好的办法。还好每个人都有自己的缺点，也都有自己的优点，而且随着时间的变化，人也是会变的。这篇博客摘录了我大学期间，大学毕业，工作了一段时间三个时期的个人总结：变的是心态，是年龄，不变的是激情，是梦想。</p>
<p>第一篇是大三开学之前在学校的实验室写的，那个夏天去了大连东软进行实训，为期半个月左右，具体做了什么忘记了，就记得大连的雨，一下就是好几天。实训结束后为没有回家，直接搬了床和被子在实验室住下了。每天和看实验室的大爷做斗争，晚上一个人睡觉，饿了就煮泡面，现在想来，那段日子真是惬意。然后快开学的时候，写了这篇总结（最后一句真是亮瞎我的24K氪金狗眼阿）：</p>
<a id="more"></a>
<blockquote>
<p>转眼间，就已经是大三的人了，由于我们专业的教学计划与别的专业不同，我们在学校待的时间只有3年。也就是说，这是我在大学的最后一年了。</p>
<p>回顾前两年，从大一的迷茫，到大二的雄心壮志，一步步走来，对大学的理解也越来越深，对自己的了解也越来越深。大学里的学习完全要靠自己。师傅领进门修行在个人，古人说话不是没有道理的。</p>
<p>一直期待的大连实训，回来以后我觉得很失望，不是对住宿环境的不满，不是对大连见不到太阳的抱怨，而是对实训内容的失望：先是实训时间被削减，拉过去先听两年后才用得上的各种公司礼仪和处事方式，然后把大家圈在一起像做课程设计一样做一个被阉割过的项目。没有参与设计，需求分析什么的都是现成的，没有详细设计，写完代码补文档……总之就是有些失望，算了，还是要靠自己么。</p>
<p>从大连回来已经十天了，每天都在实验室宅着。这十天可以说是什么都没有做，看视频，看照片，玩游戏，就是没有看书和写代码。我突然意识到，这样的生活要是再持续下去，这个暑假我将一事无成：实训已经浪费了半个月了，难道我还要浪费时间？不行，不能再浪费时间了。我已经没有多少时间挥霍了。</p>
<p>我琢磨了一下，这个假期我还有三件事要完成：完成我们的齐鲁软件设计大赛的项目，实验室的两个android项目。二十八号开学，还有二十天，抓点紧，一定要完成！！！</p>
<p>昨天我喝水的杯子掉在地上打碎了，没有水喝了，也算是我安逸生活的一个结束，给自己一个惊醒把！（杯子应该会再去买一个，要不代码没写先渴死了就划不来了）。</p>
<p>总之，就要大三了，不能再像以前那样对自己不负责任了。</p>
<p>为了自己的将来，也为了我可爱的女朋友阿春，也为了我的父母的期待，为了所有关心我的同学们，朋友们，我不会辜负你们的。</p>
<p>最后用himi的座右铭：不要让任何事情成为你不去学习的理由！</p>
<p>加油吧！见证一个大神崛起的时刻到了！<br>第二篇总结是大四毕业后，即将入职的前一天写的，刚刚毕业，正直雄心壮志之时，当然脑子也比较混乱，便写下了这篇：<br>明天就入职了。</p>
<p>大学毕业半个月了，这半个月基本没有做什么事，于是看看书，顺便反省一下自己。</p>
<p>说到看书，我还是很喜欢看书的，历史，奇幻，人物传记，美食，旅游……都是我的最爱，技术书也买了不少，不过说来惭愧，技术书买得多，看完的不多。最近在Kindle上面看完了14本书，没有一本是技术书。这让我觉得，自己看书的方法还是不对，有点杂，什么都想去看，最后只把自己感兴趣的看了，其他的脑子一时热乎买得书反而没看几页。惭愧惭愧。前两天看Feng的小道消息，说到加班，说程序员加班归根结底还是一个效率的问题，程序员的效率其实并不高，但自己又没有发现，其中一个原因是程序员的工作很难去量化。比如一个问题，可能想不明白的时候，两三天都没用进展，结果吃午饭的时候突然就开窍了，于是三下五除二，问题迎刃而解。所以我联想到我看书的经过，还是没有去量化我的看书量，或者说是没有量化学习进度。想学某个东西，然后买了相关资料，看了几天就放下了，没有计划，没有量化，也就没有压力，没有动力。人都是容易懒散的动物，大家都想吃饱喝足去冬眠，没人想在冬天里打猎。</p>
<p>既然提到了量化，那就说说什么是量化。百度百科里这样说：日常生活中所说的“量化”：指的是目标或任务具体明确，可以清晰度量。根据不同情况，表现为数量多少，具体的统计数字，范围衡量，时间长度等等。例如，四万亿支出，960万平方公里，八个小时，完成任务……具体到学习上，比如说你要学英语，然后每天抱着单词本背单词，听英语原文，但是如果没有合适的计划，热情很快就会退却，最后不了了之。然则如果你将学英语这件事量化，比如每天背多少个单词，听多少篇原文，几个月后过四六级。量化之后每天就有了目标，今天哪些没有做完，就马上去做完它。</p>
<p>明天就要去入职了，大学一晃四年过去了。到现在还没有什么职业规划，之前想的是先干两年，然后再跳槽或者进行新的规划，至于这两年怎么过，要达到什么目标，学到什么知识，都一概没有想法和概念。我想是时候好好规划规划了，不能再像以前那样，做一个无头苍蝇。也不能看到什么好的技术就要去学。看到这篇文章的过来人，也可以教教我，怎么进行职业规划，怎么进行选择，在下感激不尽。</p>
<p>总之，梦想是要启航了，不管前方大风大浪，我无所畏惧！！<br>第三篇在2013年的年底写的，从七月份入职，到九月份跳槽，再到12月份离职，再到找到新的工作，这半年突出一个折腾。但是折腾并非没有好处，一辈子很短，再不折腾，就过去了：</p>
<div> 2013注定是不平凡的一年，也是我难以忘记的 一年。一年前的今天，我还在htc，收拾了一下自己的小屋子，发了条微博：新年新气象。12年的八月份份开始正式在htc实习，那是大四的第一学期，宣告着大学时代的终结。</div>

<div>大学三年有很多值得怀念的事情，一群好基友，一个漂亮的女朋友，一个最适宜居住的城市，一段一段难忘的记忆，当这一切都成为美好的记忆后，才发现时光飞速，转眼我已经离开威海，远赴魔都，当然，阿春和我一起。</div>

<div>和htc签的实习协议，是整个大四在htc实习，13年五月左右回去做毕业设计。HTC的生活还是蛮单调的，早上八点起床，九点左右到公司，工作到12点，吃午饭，工作到六点，晚饭，然后加班到大概八点。这几乎就是每个工作日的流程。实习期间也没多少钱，也就不怎么出去玩，最大的乐趣就是做饭和打dota。这期间还有一个小插曲，我们几个小愤青，一度想回去自己创业，最后不了了之。现在想想，那会还是太冲动了，没有想清楚，就去做，执行力也很差，技术也不过硬，诶，说多了都是泪。</div>

<div>13年过年，请了一个月假回家过年，实习生就是爽，今年过年就没有那么充裕的时间了。由于要回去学车，我和阿春过了年回公司呆一个月就回学校了。回学校的日子各种爽，没课，就是玩，毕业设计很轻松，学车的时候略苦逼，结果科目二还没有考过，留下了一个大遗憾。7月份准时毕业，拿了优秀论文。</div>

<div>回顾大学四年，没有什么遗憾，该做的都做了，玩的也很爽，技术上不是大牛，但也在平均水平之上，有一大群好哥们，虽然毕业后大家各奔东西，但这四年的友情，却比什么都重要，拜拜，大学，我要去另一所大学，学习真正的东西了。</div>

<div>七月到九月，是在htc正式工作的时间，工作时间之短，我自己都没有想到。注定不安分的我，跳槽到了一家创业公司，做视频导航，在徐家汇（我住在浦东），和孔先生一起去的。九月到十一月，在这家公司短短的两个月，真真切切学到了很多东西，接触到了很多东西，认识了一群有激情有理想有技术的人，最后的离开也很纠结，原因很多，上班比较远也是一方面。裸辞后，在家里呆了一段时间，一是保养一下身体，前一段时间身体差了很多，二是停下来想想，自己到底喜欢什么，想做什么，什么样的公司适合自己。最后思考的结果是：进一家移动互联网公司，规模不能太小，50-100人左右，有激情，有喜欢做的事。这时候乐蛙进入了视线，调研，准备，去面试，被录用，入职，上手工作，一切很顺利。12月11号正式入职，这是我的第三份工作。至今还没有告诉老妈这事，反正老妈也不知道我在上海哪个公司。以后混好了再说吧。现在回头想想，2013年的后半年，真心太折腾了。跳来跳去的，工资没有涨多少，经验也没有往深度积累多少，就是凭着自己那股折腾劲，到处乱闯，像个无头的苍蝇。有收获，也有损失。非常感谢阿春在背后的支持，不管我做什么决定，她都在背后坚定不移地支持我，鼓励我，即使那个决定是很鲁莽地，没有她的支持，我也走不到今天。</div>

<div></div>

<div>新公司叫乐蛙，是一个年轻的公司，有一群充满激情的人。</div>

<div>bye bye，2013</div>

<div>hello ，2014</div><br><div>三篇总结，每次我翻看这些存储在我笔记里面的文字的时候，都会被当时的我感动，当时的我很清楚自己做了什么，做错了什么，要做什么。有的事情现在还没有做，有的事情不知不觉中已经完成。我很高兴地发现，在我生活的每一个时期，激情和梦想都时刻伴随着我，同样伴随着我的还有阿春，不管我怎样折腾，她都在背后默默地支持我，谢谢你。</div><br><div></div><br><div>另：昨天看书，记了两条笔记：</div><br><div>关心你的技艺。care about your craft</div>

<div>思考！你的工作。 think ，about your work</div><br><div>大家自己感受一下。</div><br><div></div></blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>我是一个喜欢总结并且做计划的人。从我知道如何规划自己到现在，我做了无数的计划，这些计划雄心勃勃，大有上五天揽月下五洋捉鳖之势，仿佛自己就是救世主，亿万人民等着我去拯救。但现实总是那么的残酷，我做的计划很少有能够坚持下来并完成的，以至于大家都亲切地叫我：“三分钟热情”，每思及此，也没啥好的办法。还好每个人都有自己的缺点，也都有自己的优点，而且随着时间的变化，人也是会变的。这篇博客摘录了我大学期间，大学毕业，工作了一段时间三个时期的个人总结：变的是心态，是年龄，不变的是激情，是梦想。</p>
<p>第一篇是大三开学之前在学校的实验室写的，那个夏天去了大连东软进行实训，为期半个月左右，具体做了什么忘记了，就记得大连的雨，一下就是好几天。实训结束后为没有回家，直接搬了床和被子在实验室住下了。每天和看实验室的大爷做斗争，晚上一个人睡觉，饿了就煮泡面，现在想来，那段日子真是惬意。然后快开学的时候，写了这篇总结（最后一句真是亮瞎我的24K氪金狗眼阿）：</p>]]>
    
    </summary>
    
      <category term="生活感悟" scheme="http://androidperformance.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用Wordpress建立个人独立博客]]></title>
    <link href="http://androidperformance.com/2014/02/26/build-your-own-blog-by-wordpress/"/>
    <id>http://androidperformance.com/2014/02/26/build-your-own-blog-by-wordpress/</id>
    <published>2014-02-26T02:27:21.000Z</published>
    <updated>2015-03-27T05:20:57.000Z</updated>
    <content type="html"><![CDATA[<p><a href="\"><img src="\" alt="\"></a></p>
<p>配图来自网络。</p>
<h1 id="个人吐槽阶段">个人吐槽阶段</h1><p>说到建立独立博客，很多人都很不屑地说，CSDN、博客园不是也提供博客地址么？为什么要花这么大力气，自己搭建一个博客呢？举个不太恰当的例子，很多人刚毕业没钱，在外边租房子，提供租房服务的很多，一租好几年，但每个人都想拥有自己的房子。这独立博客就相当于自己的房子，自己的房子用起来，当然就要比租的房子用起来要那么用心一点，有空就搞个装修啊，买点家具啊，修个游泳池啊（想多了），养点花花草草猫猫狗狗之类的。租的房子，能住人绝对不养狗，能叫外面绝对不下厨。不能比啊不能比，这是个态度问题。</p>
<h1 id="准备阶段">准备阶段</h1><p>废话说了这么多，还是尽快切入主题。说到个人建站，网上教程一堆一堆的，我自然也不会自己一个一个地去摸索。我主要参考的文章是Mac君的《趣谈个人建站》：<a href="\" title="\">http://macshuo.com/?p=547</a>。Mac君使用的是godaddy+ubuntu+linode。而我的不一样的点是我在国内买的域名：阿里云万网：<a href="\" title="\">http://www.net.cn/</a>。下面的内容大部分都来自Mac君的博文《趣谈个人建站》：<a href="\" title="\">http://macshuo.com/?p=547</a>。</p>
<p>重复造轮子的行为是不被大家认可的，但我这里还是要重复造轮子，原因如下：1.本人的部分步骤和原文不太一样，直接说哪里哪里不一样，会有点麻烦。 2.原文中有些没有涉及到的东西，我会在这里讲清楚，因为我跟着他的步骤走的时候，有时候会掉到坑里，爬很久才出来。 3.各位想建站的同学可以直接跟着本文的教程就可以建好，不必再切来切去。里面红色的部分是我的注释，是我遇到的问题和解决办法，希望大家别再入黑胡同。</p>
<p>搭建个人站点，大致需要做这么几件事情：</p>
<ul>
<li>一台具备公网IP的服务器</li>
<li>安装操作系统，搭建环境</li>
<li>购买域名，域名绑定IP</li>
<li>部署应用程序</li>
</ul>
<p>基本上这四套组合拳打完，你的个人网站就算建起来了，后续的事情就是添砖加瓦和蓬荜生辉了。</p>
<a id="more"></a>
<p>好把我们依次介绍：</p>
<h1 id="服务器">服务器</h1><p>大部分公司都会有自己的服务器和公网IP，要么托管要么自建机房。但对于个人用户来说，就没必要费时费力做这个事情了，购买一个VPS（Virtual Private Server）即可。什么是VPS，建议大家去维基百科上查一下，简单来说就是你会拥有一台虚拟主机，除了看不见机箱之外，你可以像操作一台实体服务器那样操作它，独立操作系统和硬盘空间、独立内存和CPU资源、独立的执行程序和系统配置等，可以自己安装操作系统和软件，独立重启等等。</p>
<p>在VPS的选择上，我用的是Linode。Linode是一家来自于米帝的专注于提供 Linux VPS 的服务提供商， 虚拟化技术采用了Xen，Linode的含义是Linux Node。注意，这里的操作系统是Linux，我推荐所有个人建站都采用Linux，不解释，如果你想采用Windows Server，后面的内容就不用看了。</p>
<p>Linode在国内外口碑都不错，价格适中，质量可靠，童叟无欺。Linode提供了各种Linux操作系统供选择，比如Ubuntu、Redhat、Debian、CentOS等等，装系统和重装系统都非常简单。</p>
<p>好，我们下面简单说一下步骤，访问<a href="\" title="\">https://manager.linode.com/session/signup</a><br>填写邮箱、用户名密码，就算注册成功了，Linode会给你发封邮件确认，打开那个确认链接，剩下的大家都会。</p>
<p>Linode通过它的ticket system（一套支持系统）提供7 x 24 x 365的支持服务，看清楚，不是7 x 24 x 365的不停机服务，我现在特别烦一些企业客户，一谈就说永不宕机，特么除了上帝谁能保证永不宕机？时间长了自个都得宕！另外Linode还提供了4小时的免费试用服务，比较厚道，如果你试试觉得不爽还可以选择不玩。</p>
<p>选择继续，就可以选机房了，Linode目前提供了东京和欧美等地的机房选择，我选了东京机房，据说是针对亚太地区用户的需求新开辟的，速度很快。然后选操作系统，设置硬盘大小、root密码等，点击「Rebuild」，你就进入了VPS的控制台，等Host Job Queue的所有任务都是绿色的Success，就可以点击「Boot」，启动系统。然后找到Remote Access这个标签，点进去就可以找到这台服务器的访问IP，打开终端，输入ssh root@x.x.x.x，就可以登录系统了，看到了吧，very simple！<span style="\"color:" #ff6600;\"="">（现在Linode已经不提供免费试用服务了，你只能先付款，然后才能使用。不过可以七天内退款）</span></p>
<p>试用之后，如果你觉得可以，点击Account标签，完善自己的信息，选择服务器配置，支付信息，然后就可以完整支付流程了。</p>
<p>我选的是Linode 1024套餐（24 GB DISK, 2000 GB），按照年付费的话230刀左右，大家这两天赞助的碎银子，差不过够一年年费了：）支付方式包括Visa，MasterCard，American Express，只有要信用卡还是很方便的。</p>
<p>另外需要注意的一点是，拿到了IP之后，一定要在不翻##墙的情况下测试一下是否可以正常访问。我就遇到这个问题了，在国内没法访问，但是挂了VPN的就可以，我估计是哪个倒霉孩子以前用过，被墙之后不用了。</p>
<p>不得已我发起了一个Ticket（支持问题），说我在中国大陆不能访问这个IP，但通过VPN可以，那哥们响应倒是挺快，但显然不懂我朝行情，让我执行mtr –r x.x.x.x，mtr可以结合ping、nslookup、tracert诊断网络传输问题。我只得把数据返给他，结果人家还要其他数据，我就不耐烦了，用蹩脚的英文给丫解释了一下什么是伟大的墙，基本意思就是少特么废话，赶紧给我换个IP。那哥们看我气势挺盛，赶紧给我换了个IP，我一试没问题了，说了声三克油，他说威尔卡姆，这事算结了。两人共交手五个回合，用时2小时，效率还可以。</p>
<p>好，服务器部分就介绍到这里。以下是我的linode推荐码，如果大家要购买Linode服务，可以用这个链接。</p>
<p><a href="\">http://www.linode.com/?r=6bd100da844d8d2c191680a4792610467ce9052</a></p>
<p><span style="\"color:" #ff6600;\"="">（上面的是Mac君的推荐码，我的推荐码是: a96df99ce34b5e0f76695558608c87fb2db5cc03。推荐链接是：<a href="https://www.linode.com/?r=a96df99ce34b5e0f76695558608c87fb2db5cc03" target="_blank" rel="external">https://www.linode.com/?r=a96df99ce34b5e0f76695558608c87fb2db5cc03</a></span>）</p>
<hr>
<h1 id="搭建环境">搭建环境</h1><blockquote>
<p>我选用的服务器是Ubuntu12.04，64位。以下内容均基于该环境描述。</p>
</blockquote>
<p>拿到了主机IP，你就算拿到了新房的钥匙，但是离入住还远着呢，因为你那个主机现在就是个毛坯房，除了进去看看，什么都不能干。好，下面我们做一下简装修。</p>
<p>1、创建用户</p>
<p>第一次登录需要root用户，什么是root？root就是整个Linux操作系统最牛逼的主，他想干嘛就干嘛，他想删谁就删谁，他是光他是电他是唯一的神话，他就是我朝就是我D，所以非常危险，你们懂的。如果用root执行一下rm -rf，那整个锡安就会被抹掉，尼奥也拯救不了，如果root愿意，他可以抹掉你曾经存在过的所有痕迹。所以，我们不能没事就用root进去耍，为了解决这个问题，我们必须要建立一个agent，平时是普通用户，关键时刻充当root的角色。</p>
<p>具体操作如下：</p>
<p>首先用root登录系统</p>
<pre><code>ssh root@x.x.x.x`&lt;/pre&gt;

创建一个新用户，用户名随你喜欢，比如叫做mactalk

&lt;pre&gt;`adduser mactalk`&lt;/pre&gt;

按照提示信息输入密码和相关信息，就可以完成操作。完成之后系统就会自动建立/home/mactalk路径。

然后是授权，输入

&lt;pre&gt;`visudo`&lt;/pre&gt;

在编辑器中找到如下内容：

&lt;pre&gt;`root    ALL=(ALL:ALL) ALL`&lt;/pre&gt;

在下面加一行

&lt;pre&gt;`mactalk    ALL=(ALL:ALL) ALL`&lt;/pre&gt;

通过ctrl+x保存退出即可。然后就可以退出root，用mactalk重新登录（ssh mactalk@x.x.x.x），登录进来默认目录在/home/mactalk下，当你想行使root权限时，请在命令之前增加sudo，按照系统提示输入密码即可执行操作。

2、选择<span class="keyword">shell</span>

用户建好了，下面我们为用户选择一种<span class="keyword">shell</span>，估计小白看到这个又毛了，啥是<span class="keyword">shell</span>？

<span class="keyword">shell</span>就是Linux的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序。比如你对<span class="keyword">shell</span>说，「你好」，<span class="keyword">shell</span>就跑到内核那说，「老大，有人问候你呢」，内核就不耐烦的说，「有事说事，我特么忙着呢」，<span class="keyword">shell</span>就把这条信息反馈给你，大致就是这样。以前讲<span class="keyword">Mac</span>技巧的时候，经常跟大家说在终端里输入一些命令，那就是<span class="keyword">Mac</span>的<span class="keyword">shell</span>，都是一脉相承的。

Linux提供了很多种<span class="keyword">Shell</span>，你要问我为什么要有这么多，我只能告诉你，你为毛同类型的衣服有那么多件？花色，质地还不一样。写程序比买衣服复杂多了，而且程序员是不惮于把事情搞复杂的，牛程序员看到不爽的<span class="keyword">shell</span>，就会自己重新写一套，慢慢形成了一些标准，常用的<span class="keyword">shell</span>有这么几种，<span class="keyword">sh</span>、bash、csh、zsh等，想知道你的系统有几种<span class="keyword">shell</span>，可以通过以下命令查看：

&lt;pre&gt;`<span class="keyword">cat</span> /etc/shells`&lt;/pre&gt;

这些<span class="keyword">shell</span>我就不解释了，维基百科和百度百科都写的很清楚，总之，坊间流传，普通程序员用bash，文艺程序员用zsh，XX程序员直接用原生的<span class="keyword">sh</span>，我建议大家文艺一点，用zsh好一些，功能也最强大。目前各个版本的Linux默认的<span class="keyword">shell</span>都是bash，如果你想用zsh，需要安装一下，如下：

&lt;pre&gt;`sudo apt-get install zsh`&lt;/pre&gt;

具体的配置我就不介绍了，感兴趣的读者，可以参考

[http:<span class="comment">//leeiio.me/bash-to-zsh-for-mac/](\)</span>

3、通用工具

介绍几个简单的工具，建站必备。
</code></pre><ul>
<li>wget，命令行下载工具，安装<code>sudo apt-get install wget</code>，使用方式后面会介绍。</li>
<li>tmux，一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再「浪费」多余的终端来连接这台远程主机。好吧，这句话有点绕，简单说就是用tmux打开的会话可以一直驻留在服务器上，下次去看时还是上次来的样子。就像你是某个酒店的VIP客户，住完之后不会人走茶凉，也不会断电，下次去时茶还热着，灯也亮着，就这样。安装方式<code>sudo apt-get install tmux</code>，对使用方式感兴趣的读者去查一下吧，中文介绍很多，记住，热键是ctrl+b。</li>
<li><p>vim，在Linux上少不了编辑文件，我推荐Vim和Emacs，一个是编辑器之神，一个是神的编辑器（或者是伪装成操作系统的编辑器），我是Vim党，目前在学习Emacs。我之前写过一个Vim系列，有兴趣的可以去看：<a href="\">http://www.cnblogs.com/chijianqiang/tag/vim/</a>从原理到配置、使用都有非常详细的介绍，那也是个大坑，还没写完，但写了MacTalk就变成顾此坑失彼坑了。</p>
<p>差不多就这几个，其他的工具随用随装吧。</p>
<p><span style="\"color:" #ff6600;\"="">（上面基本照着做就可以了，记住你的用户名，别乱起就可以了。ssh不懂的自己去脑补，至于Vim这个东西，如果以前没有接触过，那google一下基本用法也是很有必要的。酷壳博主的这篇《简明Vim练级攻略》给大家推荐一下：<a href="http://coolshell.cn/articles/5426.html）" target="_blank" rel="external">http://coolshell.cn/articles/5426.html）</a></span></p>
<hr>
<h1 id="域名和DNS">域名和DNS</h1><p>服务器和环境构建都写完了，今天介绍一下域名和DNS的那点事儿，稍微复杂一点的软件部分放在最后说。</p>
<p>域名是什么东西呢？就是一个网站的标识和入口，由「.」分隔开的字符串构成，洋名叫Domain Name，比如苹果公司网站的域名就是<a href="\" title="\">apple.com</a>，在浏览器地址栏输入这个域名，就可以访问苹果的网站了。为什么要有域名呢，有了公网IP，不就可以访问网站了么？</p>
<p>咳，这么说吧，如果有人说找个地方聚聚，你说，咱们经度116.46、纬度39.92，不见不散！地方倒是对，但是估计实名菜刀和无名臭鞋就飞过来了。IP地址就是你的服务器在互联网世界的经纬度，域名就是对应IP的门牌号码，就像人们能记住门牌号记不住经纬度一样，在网络世界里，大家都是记域名的。与现实世界不同的是，门牌号和实际地址正常情况都是一对一的，而域名和IP地址是多对一的，也就是说，只要你有一个公网IP，就可以申请多个域名，对应多个应用，非常方便。</p>
<p>现在你知道了吧，要建站，必须要有域名。能够提供域名的厂商很多，国内外都有。不过我强烈推荐大家购买国外厂商的域名，免去提交材料和备案之苦，国外动动鼠标和小手分分钟搞定的事情，国内要提交各种材料、备案、定期监管balabala……具体差异大家看看<a href="\" title="\">www.apple.com.cn</a>和<a href="\">www.apple.com</a>两个网站的底部知道了，苹果中国的底部有「京公安网安备 11010500896|京ICP备10214630」，再看看米帝的网站，毛都没有，都是自己的网站信息，我们只能说，米帝的监管制度太不健全了，真为他们捉鸡！</p>
<p>国外的域名厂商推荐<a href="\">www.godaddy.com</a>和<a href="\">www.name.com</a>，都不错。我使用的是<a href="\">Godaddy</a>。</p>
<p>Godaddy是全球最大的域名注册服务商，全球市场占有率超过30%，一般情况下不会被我朝屏蔽。如果屏蔽了Godaddy，会导致在大陆无法访问全球近三分之一的网站，所以相对安全，相对，你懂的。另外Godaddy开始支持支付宝了，对我朝臣民来说付费变得方便无比。</p>
<p>在域名选择上，最好满足这几点要求：有意义、好记、简短，另外尽可能使用com（通用顶级域名）。申请步骤也很简单，访问<a href="\">www.godaddy.com</a>，在搜索框输入你想要购买的域名，点击搜索，你会看到这个域名的具体信息，是否被使用，相关域名，价格等信息，域名后缀一般有com、net、me、us、info等，建议选com，不建议选info，据说info结尾的网站大部分是垃圾网站，会被搜索引擎屏蔽。</p>
<p>选好域名后，点Add，加入购物车，如果不需要其他服务，一路Continue即可，最后设置支付信息，支付宝在最后一列，然后「Place Your Order」，根据提示注册和支付即可。价格与域名信息相关，一般几美元到10几美元不等。</p>
<p>购买完成之后，进入Godaddy的域名管理控制台，找到你购买的域名，把域名和你的IP地址绑定起来，就可以通过域名访问你的网站了。这里就涉及到DNS了。</p>
<p>DNS的洋名一般说成Domain Name System，就是给域名提供服务的。光有域名没用，还得有相关的服务能够把域名解析成IP地址才行，DNS就干这事。DNS的扩展性非常好，不依靠单一的巨型主机索引，而是通过分布式系统提供服务，全球能够提供DNS服务的服务器多如牛毛数不胜数，但大哥级别的根服务只有13台，目前的分布是：主根服务器美国1个，设置在弗吉尼亚州的杜勒斯；辅根服务器美国9个，瑞典、荷兰、日本各1个，旗下是各个级别的域名服务器。</p>
<p>DNS的工作方式挺复杂，有兴趣的直接去Google吧，我简单描述一下，大致的场景是这样的，比如小明是个DNS服务器，有一天你想访问<a href="\" title="\">macshuo.com</a>，就问，「小明啊，我想去听听MacTalk，怎么走呢？」，作为忠诚的DNS战士，小明的服务态度是值得赞赏的，如果他知道的话，就会立刻告诉你地址，比如从这个街区左转左转左转再左转balabala……如果丫不知道也没关系，他会反馈给上级主管，说「最近有人新建了个MacTalk网站，我这还没记录地址，你晓得不？」，上级部门如果知道就会把地址发给小明，说「你丫长点记性，把这地址记下来行不？别特么老问了，最近自媒体网站可真多啊，哎……」，这样小明就会把地址告诉你，并且用心的把这个地址记到自己的小本本上，下次有人再问，就直接告诉人家答案了。如果上级部门也不知道，那就继续问，直到反馈到根服务器为止，反正只要你注册了，总能找到。差不多就这样吧。</p>
<p>Godaddy默认提供了DNS服务，点击DNS Manager，在弹出的设置面板中设置你的网站IP即可，具体的图文教程网络上很多，我就不费那事了。但是我的使用结果是，Godaddy提供的DNS在国内访问不太稳定，时不时就不能访问了，具体为啥我也不清楚。因为购买了Linode服务，我最后采用了Linode的DNS，具体的做法是：</p>
</li>
</ul>
<ol>
<li>登录<a href="\" title="\">linode.com</a>，点击DNS Manager标签，进入管理控制台</li>
<li>选择Add a domain zone</li>
<li>填写域名、邮件地址和IP</li>
<li><p>点击Add a Master Zone，就算完成了</p>
<p>最后一步就是在Godaddy的控制台里设置一下Linode的DNS服务器，很简单就不描述了。</p>
<p><span style="\"color:" #ff6600;\"="">（Mac君在Godaddy买的域名，Godaddy买的域名货真价实，童叟无欺，但我当时贪图便宜，在万网买了个域名，价格大家可以自己去两个网站对比一下，万网的性价比要高一些。在Linode中设置好域名后，需要到万网那里设置一下DNS，我是设置的Linode提供的DNS（在linode的控制台里面可以看到），将此DNS复制到万网管理台的DNS设置里面即可）</span></p>
<hr>
<h1 id="应用程序和部署">应用程序和部署</h1><p>经过前面三篇系列文章的介绍之后，我们现在房子也有了，做了简装修，还申请了地址和门牌号，最后一步就是入住，也就是部署你的应用程序。</p>
<p>针对网站提供的服务不同，需要不同的技术选型，我的需求就是做个风格简约的博客，用来存放MacTalk的文章，同时有个地方能够随意发表一些个人观点，就这么简单，所以针对这个需求进行选择即可。大家将来建站的时候也是一样，明确自己的需求，不要为未来买单，尽量搞的轻量级一些，最忌讳给的是龙套的钱，您自个却按照男猪脚进行角色扮演，不提倡。</p>
<p>搭建轻量级的博客不建议使用.Net或JavaEE的技术，这些技术都比较重，必要性不大。Php、Python、Ruby相关的框架都是可选的技术。因为我对Python相对熟悉一些，最初想找个开源的Python Blog框架，不过后来综合对比了一下，发现在个人博客领域，WordPress基本上无出其右，技术成熟、安装方便、性能稳定、插件众多，实在是居家建站、个人扯淡之必备良药，就是它了。</p>
<p>在确定了基本需求和工具之后，我们看看涉及到哪些技术：</p>
<p>1、Nginx Nginx是一款高性能的HTTP服务器软件，由俄罗斯的一位大牛Igor Sysoev开发的，源代码以类BSD许可证的形式发布。Nginx的设计非常轻量级，由内核和模块组成，内核微小简洁，模块功能强大，静态编译。Nginx做的事情简单来说就是，接收客户端（浏览器）的HTTP请求，然后通过映射机制把不同类型的请求交给不同的模块去处理，比如html、图片、css等可以交给静态资源模块处理，还可以做压缩、缓存等，php、python等类型的请求则交给FastCGI模块去处理，完成业务逻辑。</p>
<p>什么是FastCGI呢？这玩意就等于是HTTP服务器和动态脚本语言通信的接口，就像一个粘合剂一样把HTTP请求和动态脚本处理整合在一起，顾名思义，处理速度非常Fast！</p>
<p>Nginx可以说是HTTP服务器软件市场的新贵，目前国内很多大型网站都采用了Nginx作为默认的web服务器，比如阿里、腾讯、新浪等等，国外就更多了。当然，在Nginx未涉足江湖之前，这个领域的大哥叫做Apache，那时候几乎所有的HTTP Server都是清一色的Apache，一时之间风头无两。但是这哥们大哥做久了就不思进取，跟国内很多大佬一个德性，没竞争对手时就特么不知道改进，直到Nginx出来抢了丫半壁江山，现在知道努力了，当初干嘛去了？</p>
<p>那么Nginx比Apache优秀在哪呢？</p>
</li>
</ol>
<ul>
<li>Nginx的所有模块都是全静态编译的，启动Nginx后，Nginx的模块被自动加载，静态库执行效率更高。</li>
<li>Nginx支持epoll（Linux系列）和kqueue（BSD系列）I/O事件通知机制。完，又特么出现两个名词！这让人情何以堪、文何以完啊？简单说说epoll吧。epoll是Linux2.6正式引入的提高网络I/O的处理方法，它的几个优点是：单一进程打开的FD（文件描述符）数量仅受限于操作系统，1GB内存的机器上大约是10万左右，这一点大大提升了处理海量请求的能力；采用共享内存的模式避免内存拷贝；随着打开FD的数量增加，I/O效率不会线性下降。总之，大家知道epoll很牛逼就是了。</li>
<li><p>Nginx支持多进程的工作方式，Nginx启动后会有一个master进程，多个worker进程。worker进程一般对应服务器的CPU数量，你有个8核的CPU，最好把worker设置为8。master负责接收外界信号，并向worker发送信号，监控worker的运行状况，当worker挂掉的时候，启动新的worker。写到这我发现，这特么活脱脱就是一个地主老财打压长工的模式啊！<br>尤其是Nginx的不中断重启机制，当系统配置变化需要重新启动Nginx时，我们就给地主（master）发个消息，说这批长工（worker）太老了，都得换掉，你看着办。地主收到消息后就开始偷偷雇佣新的长工（worker），然后假惺惺的告诉老长工，把手头的活干完就行了，别太累了，啊。这时候如果有新的请求，就会交给新长工干，等所有的老长工把活都干完了，就直接fire，绝不留情。这样，整个服务无中断重启过程就完成了，就特么一个字，黑！<br>当然长工（worker）也不是省油的等，他们干活的过程非常复杂，会用到我们上文中提到的epoll机制，如果有人感兴趣，以后再讲吧，这么写下去这个系列就没完了。</p>
<p>Nginx功能非常强大，一本书也写不完，我简单就说这么几句。老话，有兴趣的，用Google百度一下！</p>
<p>大概了解了Nginx的工作机制，下面安装就比较简单了，Nginx可以编译安装，也可以在线安装，对于普通用户来说，使用apt-get在线安装即可，省得自己去找依赖关系。</p>
<pre>`#安装
sudo apt-get install nginx
#启动
sudo service nginx start`</pre>

<p>如果安装和启动都没有问题，我们再调整几个参数就可以了。</p>
<p>找到/etc/nginx/nginx.conf，做以下几个改动：</p>
</li>
<li><p>把worker_processes设置为服务器的CPU核数</p>
</li>
<li>在event里增加use epoll</li>
<li><p>把worker_connections的值设置大一点，如果是1G内存，不要大于100000/worker_processes。</p>
<p>其他的采用默认值即可，然后重新加载参数：</p>
<pre>`sudo nginx -s reload`</pre>

<p>好，Nginx就算妥了，后续在安装PHP和WordPress时还要做一些配置。</p>
<blockquote>
<p>我有时候觉得，当我们在计算机领域遇到问题的时候，总会出现一些技术神山上的神人，他们时不时会俯视一下凡人的IT世界，高兴了就顺手解决几个bug，发明几个新玩意，epoll和Nginx就是这些玩意，我们用好就已经心满意足袅。</p>
</blockquote>
<p>2、MySQL</p>
<p>MySQL是应用最为广泛的开源数据库，这个没什么可说的，非常成熟的技术，直接安装即可：</p>
<pre>`sudo apt-get install mysql-server`</pre>

<p>安装过程中，MySQL会提示你设置root密码（root的作用参考之前介绍的，把操作系统换成数据库即可）。如果安装时没设置密码，等MySQL起来后用mysqladmin改也行，用sql改也行，简单不啰嗦。</p>
<p><span style="\"color:" #ff6600;\"="">(注：这里Mac君没有说sql的基本操作，我这里简单说一下。安装好mySql之后，执行 ：</span></p>
<p><span style="\"color:" #ff6600;\"="">mysql -u root -p+你安装时的密码     </span></p>
<p><span style="\"color:" #ff6600;\"=""> -p和密码之间没有分隔符。进入后 ,就是MySql的基本操作，记得每一条命令以；结尾</span></p>
<p><span style="\"color:" #ff6600;\"="">1、 显示数据库：show databases;</span></p>
<p><span style="\"color:" #ff6600;\"="">2、 建数据库：create database  [if not exists] 数据库名;</span><br><span style="\"color:" #ff6600;\"="">3、 建数据表： create table [if not exists] 表名 (字段名1   类型。。。。。。。。)</span><br><span style="\"color:" #ff6600;\"="">create table student (编号 int auto_increment primary key, 姓名 varchar(10));</span><br><span style="\"color:" #ff6600;\"="">注意:设置了自动增长,就要定为主键,如果选择了BIT 类型,0不显示,非0显示为一个特殊符号!</span><br><span style="\"color:" #ff6600;\"="">4、 显示数据表:show tables;</span><br><span style="\"color:" #ff6600;\"="">5、 删除库: drop database [if exists] 库名; </span><br><span style="\"color:" #ff6600;\"="">6、 删除表: drop table   [if exists] 表名;</span><br><span style="\"color:" #ff6600;\"="">7、 显示表结构: desc 表名</span><br><span style="\"color:" #ff6600;\"="">8、 如何修改表结构:增长一个字段; alter table 表名 add 字段名  类型</span><br><span style="\"color:" #ff6600;\"="">9、 删除一个字段: alter table  表名 drop 字段名</span><br><span style="\"color:" #ff6600;\"="">10、修改一个字段的属性:  alter table 表名modify 字段 新属性</span><br><span style="\"color:" #ff6600;\"="">11、修改主键: 增加一个主键  alter table 表名 add primary key(字段名)</span><br><span style="\"color:" #ff6600;\"="">12、删除一个主键  alter table 表名  drop primary key(字段名)</span></p>
<p><span style="\"color:" #ff6600;\"="">之后还要修改一下字符集，可以参照这里：<a href="\" title="\">http://database.51cto.com/art/201010/229167.htm</a>)</span></p>
<p>3、PHP</p>
<p>WordPresss是基于PHP开发的，所以我们得为WordPress准备好环境，安装PHP。</p>
<pre>`sudo apt-get install php5
sudo apt-get install php5-fpm`</pre>

<p>php5-fpm是PHP FastCGI的实现之一，能够更好的管理PHP进程，控制内存使用，平滑重载等，现在我们都用它！</p>
<p>下面做一点简单配置，打开php.ini文件：</p>
<pre>`sudo vim /etc/php5/fpm/php.ini`</pre>

<p>找到cgi.fix_pathinfo=1这一行，把1改为0。 值为1时，php的解释器会尽可能的去解析客户端请求的文件各种类型，这会引发一些安全漏洞，设置为0时，解释器只会去解析特定的文件类型，设置为0是一种相对安全的处理策略。</p>
<p>修改www.conf：</p>
<pre>`sudo vim /etc/php5/fpm/pool.d/www.conf`</pre>

<p>把 <code>listen = 127.0.0.1:9000</code> 修改为 <code>listen = /var/run/php5-fpm.sock</code>，前者是走TCP socket，后者是Unix domain socket，如果服务都在同一台机器上，建议使用后者，效率更好一些。</p>
<p>重新启动PHP，这部分的配置就算完成了：</p>
<pre>`sudo service php5-fpm restart`</pre>

<p>4、WordPress</p>
<p>好的，我们从后场断球后左冲右突，盘过对方和我方的所有进攻和防守队员，来到球门前面，发现就差最后一关：WordPress。下面我们看看如何安装和配置WordPress。</p>
<p>首先下载WordPress的最新版本，我用了中文版，下载和解压缩：</p>
<pre>`wget http://cn.wordpress.org/wordpress-3.5.1-zh_CN.tar.gz
tar -xzvf wordpress-3.5.1-zh_CN.tar.gz 

<span style="\"font-family:" georgia,="" \'times="" new="" roman\',="" \'bitstream="" charter\',="" times,="" serif;="" font-size:="" 14px;="" line-height:="" 1.5em;="" color:="" #ff6600;\"="">（注：这里Mac君用的3.5.1，现在3.8.1为最新版本，建议用最新版本即可
</span>`
<span style="\"color:" #ff6600;\"="">`wget http://cn.wordpress.org/wordpress-3.8.1-zh_CN.tar.gz
tar -xzvf wordpress-3.8.1-zh_CN.tar.gz `</span>
`<span style="\"font-family:" georgia,="" \'times="" new="" roman\',="" \'bitstream="" charter\',="" times,="" serif;="" font-size:="" 14px;="" line-height:="" 1.5em;\"=""><span style="\"color:" #ff6600;\"="">）</span>
在MySQL中为WordPress创建用户和数据库，这部分很简单就不描述了。我们设定数据库为wordpress，用户名为mactalk，并且把数据库编码改为UTF-8。</span>`</pre>

<p>在解压好的wordpress文件夹下，执行：</p>
<pre>`cp wp-config-sample.php wp-config.php
vim ~/wordpress/wp-config.php`</pre>

<p>按照文件内容注释填写数据库名称、用户名、密码、数据库编码使用UTF-8，然后保存退出。</p>
<p>为wordpress创建www文件夹，并且把完整的wordpress目录复制到www文件夹下，并设置相关权限：</p>
<pre>`sudo mkdir -p /var/www

sudo cp -r ~/wordpress/* /var/www

cd /var/www/

sudo chown www-data:www-data * -R 

sudo usermod -a -G www-data username   <span style="\"color:" #ff6600;\"="">（注：这里的username就是你当前登录的用户名）</span>`</pre>

<p>安装php的MySQL驱动</p>
<pre>`sudo apt-get install php5-mysql`</pre>

<p>设置虚拟主机：</p>
<p>在/etc/nginx/sites-available下创建文件wordpress</p>
<pre>`sudo vim wordpress`</pre>

<p>内容如下：</p>
<pre>`server {
    listen   80;

    root /var/www;
    index index.php index.html index.htm;

    #根据 IP 或域名自定义 <span style="\"color:" #ff6600;\"=""> （注：这里只需要修改后面的3.3.3.3\. 改成你的ip或者域名都可以）
</span>    server_name 3.3.3.3;

    location / {
        try_files $uri $uri/ /index.php?q=$uri&amp;$args;
    }

    error_page 404 /404.html;

    error_page 500 502 503 504 /50x.html;
    location = /50x.html {
          root /usr/share/nginx/www;
    }

    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9$
    location ~ .php$ {
        #fastcgi_pass 127.0.0.1:9000;
        # With php5-fpm:
        fastcgi_pass unix:/var/run/php5-fpm.sock;
        fastcgi_index index.php;
        include fastcgi_params;
    }
}`</pre>

<p>这个文件的作用就是把Nginx和WordPress粘合在一起，接收客户端的请求并反馈响应结果。有几点要注意的是，root设置为/var/www/，index部分增加index.php，fastcgi_pass对应之前设置的unix socket：unix:/var/run/php5-fpm.sock。<span style="\"color:" #ff6600;\"="">（注：这段话只是说明一下上面的文件有什么改动，并不需要自己去操作，特别注意最后要删除default文件，不然在重启nginz时会报一个80端口已经被其他server占用的错误。）</span></p>
<p>为wordpress文件建立软连接：</p>
<pre>`sudo ln -s /etc/nginx/sites-available/wordpress /etc/nginx/sites-enabled/wordpress`</pre>

<p>最后重新启动nginx和php5-fpm，就算大功告成了：</p>
<p><pre>`sudo service nginx restartsudo<br>service php5-fpm restart</pre></p>
</li>
</ul>
<p>如果一切正常的话，访问你的域名或者公网IP，就可以看到wordpress的提示页面，根据信息提示初始化数据库，创建管理员，基本框架就算建好了，之后就是完善和优化，比如性能优化、主题选择、配置信息、插件选择、扩展开发等等，大家慢慢体会吧。<span style="\"line-height:" 1.5em;\"=""> </span></p>
<p>下面是本人配置好wordpress之后的画面：一段很有趣的话，开始你的博客之旅把。</p>
<p><a href="\"><img src="\" alt="\"></a></p>
<p>之后会有一个系列，来讲wordpress使用过程中遇到的问题和心得。有问题欢迎留言交流。</p>
<blockquote>
<p><span style="\"color:" #ff0000;\"="">作者：<a href="\" title="\">Gracker</a></span><br><span style="\"color:" #ff0000;\"="">出处：<a href="\" title="\">androidperformance.com</a></span><br><span style="\"color:" #ff0000;\"="">本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。</span><br><span style="\"color:" #ff0000;\"="">打赏一下： <a href="\">微博打赏</a></span></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><a href="\"><img src="\" alt="\"></a></p>
<p>配图来自网络。</p>
<h1 id="个人吐槽阶段">个人吐槽阶段</h1><p>说到建立独立博客，很多人都很不屑地说，CSDN、博客园不是也提供博客地址么？为什么要花这么大力气，自己搭建一个博客呢？举个不太恰当的例子，很多人刚毕业没钱，在外边租房子，提供租房服务的很多，一租好几年，但每个人都想拥有自己的房子。这独立博客就相当于自己的房子，自己的房子用起来，当然就要比租的房子用起来要那么用心一点，有空就搞个装修啊，买点家具啊，修个游泳池啊（想多了），养点花花草草猫猫狗狗之类的。租的房子，能住人绝对不养狗，能叫外面绝对不下厨。不能比啊不能比，这是个态度问题。</p>
<h1 id="准备阶段">准备阶段</h1><p>废话说了这么多，还是尽快切入主题。说到个人建站，网上教程一堆一堆的，我自然也不会自己一个一个地去摸索。我主要参考的文章是Mac君的《趣谈个人建站》：<a href="\" title="\">http://macshuo.com/?p=547</a>。Mac君使用的是godaddy+ubuntu+linode。而我的不一样的点是我在国内买的域名：阿里云万网：<a href="\" title="\">http://www.net.cn/</a>。下面的内容大部分都来自Mac君的博文《趣谈个人建站》：<a href="\" title="\">http://macshuo.com/?p=547</a>。</p>
<p>重复造轮子的行为是不被大家认可的，但我这里还是要重复造轮子，原因如下：1.本人的部分步骤和原文不太一样，直接说哪里哪里不一样，会有点麻烦。 2.原文中有些没有涉及到的东西，我会在这里讲清楚，因为我跟着他的步骤走的时候，有时候会掉到坑里，爬很久才出来。 3.各位想建站的同学可以直接跟着本文的教程就可以建好，不必再切来切去。里面红色的部分是我的注释，是我遇到的问题和解决办法，希望大家别再入黑胡同。</p>
<p>搭建个人站点，大致需要做这么几件事情：</p>
<ul>
<li>一台具备公网IP的服务器</li>
<li>安装操作系统，搭建环境</li>
<li>购买域名，域名绑定IP</li>
<li>部署应用程序</li>
</ul>
<p>基本上这四套组合拳打完，你的个人网站就算建起来了，后续的事情就是添砖加瓦和蓬荜生辉了。</p>]]>
    
    </summary>
    
      <category term="Wordpress" scheme="http://androidperformance.com/categories/Wordpress/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gracker的个人博客开通了！]]></title>
    <link href="http://androidperformance.com/2014/02/24/hello-gracker-blog-was-build/"/>
    <id>http://androidperformance.com/2014/02/24/hello-gracker-blog-was-build/</id>
    <published>2014-02-24T07:54:49.000Z</published>
    <updated>2015-03-26T12:45:53.000Z</updated>
    <content type="html"><![CDATA[<p>计划了很久，终于把博客开通了。</p>
<p>自从接触到<a href="http://apple.com" target="_blank" rel="external">Mac OS</a>之后，便对苹果佩服的五体投地，硬件上突出一个高大上，而且携带方便，软件上更是无人出其右。有时候你用他就觉得是一种享受。这不是我有意夸大，谁用谁知道。</p>
<p>然后顺理成章地知道了Mac君，微信上MacTalk也是每一篇都一字不差地看完，最后买了多看版，也买了实体书，一本书有这样的魔力，我也很惊奇。同样是搞技术的，为何他就能写出这样的文字，而我却只能对着程序发呆。究其原因，这里面有人生经历的原因，更重要的是他的热情和坚持，让我这种三分钟热情的人表示很汗颜。想想自己最能坚持的事，就是一局又一局的DOTA。每思及此，痛心疾首，所以下决心要做点什么。</p>
<p>Mac君的书中有一段：“即便是最简单的坚持，最后的结果也都是惊人的。这世界上一直存在一条路，让我们的能力从平庸到杰出，这条路漫长而且艰辛，只有少数人愿意走下去，所以，优秀的人永远是少数”。这段话让我感触很多，也让我下定决定要把这个博客搭建起来，养成写作的习惯。少刷点微博，少打两把DOTA，时间就那么多，再浪费下去，以后的我，会痛恨现在的我的。</p>
<p>现在计划每周更新博客两次，周一到周五发一篇，周末发一篇。尽量做到言之有物，对别人有实质性的帮助，不讲空话，技术上用实例说明问题。可能初期的文笔不是很好，但我相信，简单的坚持，借用红米的一句话：“永远相信美好的事情即将发生”。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>计划了很久，终于把博客开通了。</p>
<p>自从接触到<a href="http://apple.com" target="_blank" rel="external">Mac OS</a>之后，便对苹果佩服的五体投地，硬件上突出一个高大上，而且携带方便，软件上更是无人出]]>
    </summary>
    
      <category term="生活感悟" scheme="http://androidperformance.com/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
</feed>